{"version":3,"file":"main.bundle.js","mappings":";;;;;;;;;;;;;;AAAA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AAC+D;AACQ;AAChE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0BAA0B,cAAc,YAAY;AACtG;AACA;AACA;AACA;AACA,6CAA6C,yCAAO;AACpD;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yBAAyB;AAC9E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,6CAA6C,IAAI;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+EAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oCAAoC;AACxF;AACA,mFAAmF,oCAAoC;AACvH;AACA;AACA;AACA,+EAA+E,0CAA0C;AACzH;AACA,SAAS,UAAU;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+EAAY;AAC5C;AACA,8EAA8E,yBAAyB;AACvG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+EAAY;AAChD;AACA,oCAAoC,yCAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,gEAAgE,iBAAiB,EAAE,oBAAoB,aAAa,aAAa;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+EAAY;AAChD;AACA,oCAAoC,yCAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,mEAAmE,iBAAiB,EAAE,oBAAoB,aAAa,aAAa;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAY;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAc;AAClC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,6CAA6C;AACjG;AACA,CAAC;;;;;;;;;;;;;;;;AC3RD,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACyD;AACzD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oCAAoC;AACnE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,eAAe;AAChC;AACA;AACA,uDAAuD,iEAAgB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,UAAU,oCAAoC,GAAG;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA,uEAAuE,YAAY;AACnF,wEAAwE,YAAY;AACpF,6BAA6B;AAC7B;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA,gDAAgD,MAAM,uCAAuC,WAAW,SAAS,WAAW,qBAAqB,OAAO;AACxJ;AACA;AACA,wDAAwD,MAAM,qBAAqB,sBAAsB,mBAAmB,aAAa;AACzI;AACA;AACA,6CAA6C,aAAa,oBAAoB,OAAO,UAAU,aAAa;AAC5G;AACA,yBAAyB;AACzB;AACA;AACA,4DAA4D,aAAa,aAAa,MAAM;AAC5F,yBAAyB;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB,yBAAyB,oCAAoC,IAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU,KAAK;AACf;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;;;;;;;;;;;;;;;;;;;;;AC5OA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+E;AACtB;AACQ;AACV;AACqB;AACP;AAC9D;AACP;AACA;AACA;AACA,4BAA4B,oFAAmB;AAC/C;AACA,6BAA6B,qFAAgB;AAC7C,6CAA6C,4DAAO;AACpD;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oBAAoB,8EAAe;AACnC,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA,0CAA0C,sEAAY;AACtD;AACA,gBAAgB,oFAAmB;AACnC;AACA;AACA;AACA,wCAAwC,8DAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACrDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACqB;AAC3B;AACyC;AACnF;AACP;AACA,qBAAqB,0DAAoB;AACzC;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACzCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6D;AACN;AACqB;AACP;AAC9D;AACP;AACA,yBAAyB,kEAAU;AACnC;AACA,yBAAyB,qFAAgB;AACzC;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC3CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmB;AACL;AAC9D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+EAAY;AAC/D;AACA;AACA,oCAAoC,4DAAO;AAC3C,qCAAqC,4DAAO;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,8EAAe;AAC3B,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;;;;;;;ACvID,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACqB;AACP;AAC9D;AACP;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACmC;AACZ;AAC5D;AACf;AACA;AACA;AACA;AACA,yBAAyB,uFAAkB;AAC3C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,qDAAqD,gBAAgB;AACrE;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACmC;AACZ;AAC5D;AACf;AACA;AACA;AACA;AACA,yBAAyB,uFAAkB;AAC3C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACvCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmC;AACnF;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,qEAAqE,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC8C;AACS;AACmC;AACG;AACtF;AACP;AACA;AACA,yBAAyB,sGAAiC;AAC1D,2BAA2B,4DAAO;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,qEAAqE,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AC9CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACS;AAC0B;AACf;AACkB;AACnF;AACP;AACA;AACA;AACA,yBAAyB,sGAAiC;AAC1D,yCAAyC,4DAAO;AAChD;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA,4BAA4B,mBAAmB;AAC/C,gBAAgB,qEAAY;AAC5B;AACA,YAAY,oFAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC7CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACX;AACqB;AACc;AAChF;AACP;AACA;AACA;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,mBAAmB;AACnD,oBAAoB,qEAAY;AAChC;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AC9CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACd;AACgC;AACX;AACc;AAChF;AACP;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gGAA0B;AACtC;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb,kEAAkE,4DAAO;AACzE;AACA,gBAAgB,8EAAe;AAC/B,kDAAkD,gBAAgB;AAClE;AACA;AACA,4BAA4B,mBAAmB;AAC/C,gBAAgB,0EAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;ACnEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACd;AACkC;AAC2B;AAC7B;AACX;AACc;AACnC;AAC7C;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,yCAAyC,iBAAiB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6HAAyC;AAC/E;AACA;AACA,QAAQ,gGAA0B;AAClC,cAAc,kGAA2B;AACzC;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,mBAAmB;AACnD,oBAAoB,0EAAc;AAClC;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACtEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuF;AACd;AACxC;AAC1B;AACP;AACA;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,yCAAO,sDAAsD,UAAU;AAChH;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,yCAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC7CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuF;AACd;AACxC;AAC1B;AACP;AACA;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,yCAAO,sDAAsD,UAAU;AAChH;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,yCAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC7CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACd;AACmC;AACnC;AAC7C;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,kDAAkD,iCAAiC;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,mBAAmB;AACnD,oBAAoB,0EAAc;AAClC;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACtDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACX;AACqB;AACC;AACa;AACvF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,iBAAiB,IAAI;AAClE;AACA;AACA;AACA,yBAAyB,0DAAoB;AAC7C,mCAAmC,qEAAY;AAC/C,wBAAwB,qEAAY;AACpC;AACA;AACA;AACA;AACA,6BAA6B,qFAAgB;AAC7C,+CAA+C,4DAAO;AACtD;AACA;AACA,6CAA6C,4DAAO;AACpD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,qEAAY;AACpC;AACA;AACA,wBAAwB,qEAAY;AACpC;AACA;AACA;AACA;AACA,oBAAoB,8EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;ACpEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACX;AACqB;AACc;AACvD;AACoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,qBAAqB,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD,2CAA2C,qEAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qFAAgB;AACjD,iDAAiD,4DAAO;AACxD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA,gCAAgC,qEAAY;AAC5C;AACA;AACA;AACA;AACA,wBAAwB,wCAAM;AAC9B;AACA;AACA;AACA;AACA,wBAAwB,wCAAM;AAC9B,wBAAwB,8EAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAM;AAClB,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,4DAAO;AACpD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA;AACA;AACA;AACA;AACA,oBAAoB,8EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kFAAmB,QAAQ,4DAAO;AAClD;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AC9IA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACX;AACqB;AACc;AACnC;AAC7C;AACP;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,mCAAmC,wBAAwB;AACxG;AACA;AACA;AACA,gCAAgC,qEAAY;AAC5C;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA,6BAA6B,qFAAgB;AAC7C,6CAA6C,4DAAO;AACpD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB,qEAAY;AAChC;AACA;AACA,0DAA0D,gBAAgB;AAC1E,oBAAoB,8EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC1DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACX;AACN;AACyC;AAChF;AACP;AACA,qBAAqB,0DAAoB;AACzC;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,qEAAY;AAChC;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC7CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACc;AACO;AACc;AAChF;AACP;AACA,2BAA2B,0EAAc;AACzC;AACA;AACA;AACA;AACA;AACA,6BAA6B,qFAAgB;AAC7C;AACA;AACA,6CAA6C,4DAAO;AACpD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB,0EAAc;AAClC;AACA;AACA,oBAAoB,8EAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AClDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoE;AAChB;AACkC;AACb;AACc;AACnC;AACpD;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,wBAAwB,eAAe;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D,2CAA2C,0EAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qFAAgB;AACjD,iDAAiD,4DAAO;AACxD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA,gCAAgC,0EAAc;AAC9C;AACA;AACA;AACA;AACA,wBAAwB,8EAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,cAAc,kGAA2B;AACzC;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACtFA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACqB;AACc;AACnC;AAC7C;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,gCAAgC,8CAA8C;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD,mDAAmD,eAAe;AAClE,2CAA2C,OAAO;AAClD,2CAA2C,OAAO;AAClD,yCAAyC,KAAK;AAC9C,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACrDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsE;AAClB;AACqB;AACc;AAChF;AACP;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,kDAAkD,gBAAgB;AAClE;AACA;AACA,4BAA4B,mBAAmB;AAC/C,gBAAgB,8EAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACxCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACR;AACqB;AACc;AAChF;AACP;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B,kDAAkD,gBAAgB;AAClE;AACA;AACA,4BAA4B,mBAAmB;AAC/C,gBAAgB,oEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACxCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkF;AAC3B;AACqB;AAC1B;AACmB;AAC9D;AACP;AACA,qBAAqB,2DAAqB;AAC1C;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA,yCAAyC,eAAe;AACxD,aAAa;AACb;AACA;AACA;AACA,oBAAoB,qFAAiB;AACrC;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC9CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACmB;AACgB;AAChF;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,+EAAY;AAC5B;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC/CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACmC;AACd;AAClE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAgB;AAC5C;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AC1CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACqB;AACD;AACuC;AACxB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sBAAsB,oFAAoB;AAC1C;AACA;AACA,4BAA4B,2HAAgC;AAC5D;AACA,6BAA6B,qFAAgB;AAC7C,6CAA6C,4DAAO;AACpD;AACA;AACA,kCAAkC,KAAK;AACvC,iBAAiB;AACjB;AACA,oBAAoB,8EAAe;AACnC,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACQ;AACqF;AACxE;AACe;AACpC;AAC7C;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kCAAkC,oEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAgB;AAC5C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iCAAiC,qGAAuC;AACxE;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kCAAkC,oEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAgB;AAC5C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iCAAiC,oHAAsD;AACvF;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kCAAkC,oEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAgB;AAC5C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kCAAkC,oEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAgB;AAC5C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kCAAkC,oEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAgB;AAC5C,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA,KAAK;AACL;AACO;AACP,4GAA4G;AAC5G;;;;;;;;;;;;;;;;;;;;ACtQA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACX;AACqB;AAC3B;AACyC;AACnF;AACP;AACA,sBAAsB,0DAAoB;AAC1C;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA,yCAAyC,eAAe,eAAe,YAAY;AACnF,aAAa;AACb;AACA;AACA;AACA,gBAAgB,qEAAY;AAC5B;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC9CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmC;AACG;AACtF;AACP;AACA,qBAAqB,sGAAiC;AACtD,yBAAyB,4DAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6F;AACtC;AACmC;AACnF;AACP;AACA,qBAAqB,sGAAiC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAO;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACzCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoC;AACsD;AACG;AACtF;AACP;AACA,qBAAqB,sGAAiC;AACtD,uBAAuB,yCAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;AACO;AACP;AACA,qBAAqB,sGAAiC;AACtD,uBAAuB,yCAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC/DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmC;AACoB;AACmC;AACG;AACtF;AACP;AACA;AACA,qBAAqB,sGAAiC;AACtD,yBAAyB,4DAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,wCAAM;AACtB;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA,gBAAgB,wCAAM;AACtB;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAM;AAClB,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC5CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmC;AACG;AACtF;AACP;AACA,qBAAqB,sGAAiC;AACtD,yBAAyB,4DAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoC;AACsD;AACG;AACtF;AACP;AACA,uBAAuB,yCAAO;AAC9B,qBAAqB,sGAAiC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4E;AACrB;AACmC;AACnF;AACP;AACA;AACA,yBAAyB,qFAAgB;AACzC;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,KAAK,4DAAO;AAC3C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACpCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmC;AACd;AACrE;AACP;AACA;AACA,yBAAyB,qFAAgB;AACzC;AACA;AACA;AACA,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,KAAK,4DAAO;AAC3C;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuF;AACtD;AAClB;AACf;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACrDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuF;AACtD;AAClB;AACf;AACA,8CAA8C,yCAAO;AACrD;AACA,KAAK;AACL;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB;AAC/B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,yCAAO;AAC/B,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACjJA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACmC;AACG;AAC9B;AACxD;AACP;AACA,qBAAqB,0DAAoB;AACzC;AACA,yBAAyB,sGAAiC;AAC1D,yCAAyC,4DAAO;AAChD;AACA;AACA,4BAA4B,UAAU;AACtC,aAAa;AACb;AACA;AACA;AACA,oBAAoB,8CAAY;AAChC;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAmB,QAAQ,4DAAO;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC9CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACc;AACO;AACjC;AACpC;AACP;AACA;AACA;AACA,yBAAyB,qFAAgB;AACzC,yCAAyC,4DAAO;AAChD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA,oBAAoB,oDAAc;AAClC;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA,gBAAgB,8EAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACpDO;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNP;AACO;;;;;;;;;;;;;;;ACDA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxLA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACtB;AACvB;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChHA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AAC9B;AACsB;AACX;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uCAAI;AAC3B,gCAAgC,uCAAI;AACpC,QAAQ,qEAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yCAAyC,GAAG;AAC5C;AACA;AACA,gBAAgB,qDAAe;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClFA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACwD;AACgB;AACpB;AACd;AAC/B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kBAAkB,IAAI,sBAAsB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS,KAAK,uBAAuB;AACpF;AACA;AACA,gBAAgB,qDAAe,aAAa,uBAAuB;AACnE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA,4CAA4C,mDAAa;AACzD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oFAAoB;AAC9C,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnN8C;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAY;AAC3C,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgF;AACL;AACP;AAC7D;AACP;AACA;AACA;AACA,2BAA2B,oFAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA,gCAAgC,yFAAiB;AACjD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,6EAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6DAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChDgE;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjLiC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6E;AACnC;AACkB;AACV;AACsB;AACpB;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qEAAgB;AAC5B;AACA;AACA;AACA;AACA,kBAAkB,mDAAU;AAC5B,SAAS;AACT;AACA;AACA,YAAY,+CAAa;AACzB,wBAAwB,iDAAW,+BAA+B,SAAS,GAAG;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAU;AACtB,YAAY,2DAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAU;AACtB,YAAY,2DAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA,QAAQ,uEAAkB;AAC1B;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,+BAA+B,IAAI;AAChF;AACA;AACA;AACA,4BAA4B,oFAAoB;AAChD,6BAA6B,mDAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,oFAAoB;AAC9C,uBAAuB,qEAAmB;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,oFAAoB;AAC9C,uBAAuB,qEAAmB;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,oFAAoB;AAC9C;AACA,4BAA4B,2DAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,oFAAoB;AAC9C,6BAA6B,qEAAmB;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,iCAAiC,gBAAgB;AAC9F;AACA;AACA;AACA;AACA,gCAAgC,2DAAc;AAC9C;AACA,SAAS;AACT;AACA;AACA,eAAe,qEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpMwE;AACpC;AAC7B;AACP;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAO;AACpC,oBAAoB,oFAAoB;AACxC,yBAAyB,oFAAoB;AAC7C,yBAAyB,oFAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqD;AACH;AAC3C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;ACnF4C;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gCAAgC;AACjE;AACA,QAAQ,qDAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzagD;AACzC,+BAA+B,yDAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4C;AACU;AACtD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+DAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+DAAgB;AACzD;AACA;AACA,qCAAqC,IAAI;AACzC;AACA;AACA,YAAY,qDAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;AClGgD;AACzC,iCAAiC,yDAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0D;AACnD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mEAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mEAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACrHA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACX;AACyB;AACnC;AACyC;AACF;AACF;AACxE;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAoB;AAChC,YAAY,wFAAkB;AAC9B,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4FAAoB;AAChC,YAAY,wFAAkB;AAC9B,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAkB;AAC9B,YAAY,4FAAoB;AAChC;AACA,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA,QAAQ,0FAAmB;AAC3B;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,yDAAyD,wBAAwB;AAC9H;AACA;AACA;AACA,8BAA8B,0FAAmB;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,wFAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4FAAoB;AACnC;AACA;AACA,eAAe,wFAAkB;AACjC;AACA;AACA;AACA,kBAAkB,4FAAoB;AACtC,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,uEAAa;AACzB,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,oCAAoC,IAAI;AACrF;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA,mCAAmC,mDAAU;AAC7C,6BAA6B,4FAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,uDAAuD,IAAI;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D,qCAAqC,4FAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,8CAA8C,IAAI;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD,iCAAiC,4FAAoB;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClNO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACVO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACVqC;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5BiD;AACZ;AAC9B;AACP;AACA;AACA;AACA,6BAA6B,6CAAO;AACpC,oBAAoB,0DAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxhBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACd;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B,+CAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5FA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqD;AACZ;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAK;AAC5B,gCAAgC,+CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;AClFA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACvB;AACzB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B,yCAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjGA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmF;AAC/B;AACkB;AACV;AACuB;AACrC;AACQ;AACM;AACZ;AACzC;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAgB;AAC5B,YAAY,6DAAe;AAC3B,YAAY,+EAAwB;AACpC,YAAY,qEAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAe;AAC3B,YAAY,+EAAwB;AACpC,YAAY,qEAAmB;AAC/B,YAAY,+DAAgB;AAC5B,6BAA6B,0EAAkB;AAC/C,YAAY,sDAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAe;AACnC,oBAAoB,+EAAwB;AAC5C,oBAAoB,qEAAmB;AACvC,0BAA0B,0EAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAe;AACnC,oBAAoB,+EAAwB;AAC5C,oBAAoB,qEAAmB;AACvC,oBAAoB,yDAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,6DAAe;AAC3B,YAAY,+EAAwB;AACpC,YAAY,qEAAmB;AAC/B;AACA;AACA;AACA;AACA,4BAA4B,4FAAqB;AACjD,6BAA6B,6DAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,6DAAe;AAC3B,SAAS;AACT;AACA;AACA;AACA,4BAA4B,4FAAqB;AACjD,6BAA6B,+DAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,4FAAqB;AAC/C,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA,uBAAuB,+EAAwB;AAC/C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,4FAAqB;AAC/C;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA,6BAA6B,+EAAwB;AACrD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,4FAAqB;AAC/C,6BAA6B,+EAAwB;AACrD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA,gCAAgC,qEAAmB;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,qEAAmB;AAC/B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC3LA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACE;AAC4C;AAC1D;AACE;AACL;AACzC;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA,QAAQ,yDAAa;AACrB;AACA;AACA;AACA,YAAY,0EAAkB;AAC9B,YAAY,2DAAc,eAAe,sHAAkC;AAC3E;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7IA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqD;AACZ;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;ACnEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AAC2E;AACnI;AACP;AACA;AACA,QAAQ,wEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+GAAgC;AAC9D;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,gDAAgD,gCAAgC;AAChF,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+GAAgC;AAC1D;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA,4CAA4C,gCAAgC;AAC5E,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iHAAkC;AAChE;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iHAAkC;AAC5D;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA,+CAA+C,gCAAgC;AAC/E,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzHA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqF;AACtB;AACR;AAC+B;AAC1B;AACrD;AACP;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAa;AACjC,sCAAsC,iDAAW,oCAAoC,eAAe;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA,0BAA0B,gEAAiB;AAC3C;AACA;AACA;AACA,mCAAmC,8FAAwB;AAC3D;AACA;AACA,gCAAgC,qBAAqB;AACrD,oBAAoB,gEAAiB;AACrC;AACA,gCAAgC,wBAAwB;AACxD,oBAAoB,qEAAmB;AACvC;AACA;AACA;AACA,gBAAgB,wCAAM;AACtB;AACA;AACA;AACA;AACA,gBAAgB,wCAAM;AACtB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gEAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gEAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gEAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gEAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gEAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAqB;AACjD,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE,oBAAoB,wEAAgB;AACpC;AACA;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE,oBAAoB,wEAAgB;AACpC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,2CAA2C,eAAe;AACvG;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,4CAA4C,wBAAwB;AACjH;AACA;AACA;AACA;AACA,yDAAyD,WAAW,2CAA2C;AAC/G;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,yCAAyC,wBAAwB;AAC9G;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/TO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/iBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACTA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC2E;AACpB;AAChD;AACP;AACA;AACA;AACA,gCAAgC,mEAAc;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,0CAA0C,uFAAwB;AAClE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9CqC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6CAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjByD;AAClD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAM;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACXO;AACP;AACA;;;;;;;;;;;;;;;ACFO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACNO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACHA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0D;AACc;AACM;AACjC;AACK;AACE;AAC7C;AACP;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,+BAA+B;AAC5E;AACA;AACA,4BAA4B,mCAAmC;AAC/D,gBAAgB,sDAAY;AAC5B;AACA,4BAA4B,qCAAqC;AACjE,gBAAgB,2DAAc;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,oFAAmB;AACnC;AACA;AACA,kCAAkC,oCAAoC;AACtE;AACA;AACA;AACA;AACA,sBAAsB,0FAAsB;AAC5C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE,oBAAoB,oEAAe;AACnC;AACA;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE,oBAAoB,oEAAe;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtHO;AACP;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzKA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsC;AACiB;AAChD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,6DAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjFO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1JA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACtB;AAC/B;AACP,WAAW,+CAAO;AAClB;AACO;AACP;AACO;AACP,2BAA2B,oEAAW;AACtC;AACA;AACO;AACP;AACO;AACP;AACA,KAAK;AACL;AACO;AACP;AACA,KAAK;AACL;AACO;AACP;AACO;AACP;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;ACnCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAO,iCAAiC,yCAAO;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,oEAAoE,eAAe,GAAG;AACtF;AACA;AACA;AACA,+DAA+D;AAC/D,uEAAuE,eAAe,GAAG;AACzF;AACA;AACA;AACA,uDAAuD;AACvD,+DAA+D,eAAe,GAAG;AACjF;AACA;AACA;AACA;AACA,4CAA4C,wBAAwB;AACpE,4CAA4C,wBAAwB;AACpE,6CAA6C,yCAAyC;AACtF,4CAA4C,kBAAkB,yCAAO,kBAAkB;AACvF;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,+CAA+C,wBAAwB;AACvE,KAAK;AACL;AACO;AACP;AACA,+CAA+C,yBAAyB;AACxE;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;ACnSA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACR;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAO,4BAA4B,4DAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,oEAAoE,eAAe,GAAG;AACtF;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,uEAAuE,eAAe,GAAG;AACzF;AACA;AACA;AACA;AACA;AACA,mEAAmE,eAAe,GAAG;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oEAAW;AAClD;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;ACxT0D;AACc;AACjE;AACP,uBAAuB,oFAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B,kEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B,kEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3HO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACpBe;AACf;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0C;AACnC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,mDAAM;AAClB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAM;AAClB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAM;AAClB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,mDAAM;AACtB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sEAAsE;AACtE,gBAAgB,mDAAM;AACtB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;ACvFA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2CAA2C;AAC3E,+CAA+C,oCAAoC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA,gCAAgC,2CAA2C;AAC3E,+CAA+C,oCAAoC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,aAAa;AAC7E;AACA;AACA;AACA,gCAAgC,2CAA2C;AAC3E,+CAA+C,oCAAoC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,aAAa;AAC/E;AACA;AACA;AACA,gCAAgC,2CAA2C;AAC3E,+CAA+C,oCAAoC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,aAAa;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mCAAmC;AACnC,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjSO;AACP,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;ACZkF;AAC3E;AACP;AACA,gCAAgC,uFAAkB;AAClD;AACA;AACA;AACA;AACA,gCAAgC,uFAAkB;AAClD;AACA;AACA;AACA;AACO;AACP;AACA,gCAAgC,uFAAkB;AAClD;AACA;AACA;AACA;AACA,gCAAgC,uFAAkB;AAClD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzBO;AACP;AACA,qCAAqC;AACrC;AACA,wBAAwB;AACxB;;;;;;;;;;;;;;;;;;ACLA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgE;AACW;AACH;AACxE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mEAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mEAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mEAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qEAAY;AACtE;AACA;AACA;AACA;AACA,gEAAgE,mEAAa;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kBAAkB,oFAAoB;AACtC,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AClIA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgE;AAC0B;AAC1B;AACd;AACK;AACJ;AACwB;AACoB;AAC/B;AAChE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oGAAqB;AAC7C;AACA,4BAA4B,qEAAY;AACxC;AACA,wCAAwC,2DAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mGAA8B;AAC3E;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oGAAqB;AAC7C;AACA,4BAA4B,qEAAY;AACxC;AACA,wCAAwC,2DAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mGAA8B;AAC3E;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qCAAqC,yEAAiB;AACtD;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gCAAgC,gFAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oEAAiB;AAC9C;AACA,QAAQ,oGAAqB;AAC7B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,iFAAiF;AACzG,qCAAqC,qEAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAoB;AACpD;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC7LA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACY;AACZ;AACU;AACzE;AACO;AACP;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAoB;AAC9C;AACA;AACA,8BAA8B,gFAAW;AACzC;AACA;AACA;AACA,4CAA4C,mEAAsB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kFAAmB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mEAAsB;AAClE;AACA;AACA,+CAA+C,kFAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACzEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkF;AACyC;AAC9C;AACtE;AACP;AACA,sBAAsB,0DAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,4BAA4B,8CAAY;AACxC;AACA,4BAA4B,2FAA0B;AACtD;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,4BAA4B,8CAAY;AACxC;AACA,4BAA4B,oIAAyC;AACrE;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACrD6D;AACE;AACQ;AAChE;AACP;AACA,qBAAqB,mFAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,2EAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,kEAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgD;AACc;AACD;AACO;AACpE;AACA;AACA;AACe;AACf;AACA;AACA,oCAAoC,0EAAqB;AACzD;AACA,gCAAgC,wBAAwB;AACxD;AACA,oBAAoB,qEAAY;AAChC;AACA;AACA,YAAY,4EAAe;AAC3B,YAAY,4EAAe;AAC3B,YAAY,4EAAe;AAC3B;AACA;AACA,kBAAkB,4DAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;ACzCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6E;AACjB;AACF;AACJ;AACQ;AACY;AAChB;AACd;AACkB;AACvD;AACP;AACA;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,yCAAyC,iDAAiD;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mEAAsB;AACvE,oCAAoC,kEAAU;AAC9C,YAAY,8DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mEAAsB;AAC5D,gCAAgC,kEAAU;AAC1C,QAAQ,8DAAQ;AAChB;AACA,QAAQ,wCAAM;AACd;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mEAAsB;AACpE,sCAAsC,yFAAyB;AAC/D;AACA;AACA,2BAA2B,2EAAoB;AAC/C,wBAAwB,wBAAwB;AAChD,kCAAkC,0DAAa;AAC/C;AACA;AACA;AACA,iCAAiC,mEAAsB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAsB;AACvD,4BAA4B,wBAAwB;AACpD,gBAAgB,uEAAoB;AACpC;AACA;AACA,gCAAgC,kEAAU;AAC1C,cAAc,8DAAQ;AACtB,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mEAAsB;AACvE,oCAAoC,kEAAU;AAC9C,YAAY,8DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mEAAsB;AAC5D,kCAAkC,uFAA0B;AAC5D;AACA,KAAK;AACL;;;;;;;;;;;;;;;;ACxHoD;AAC7C;AACP;AACA;AACA,sBAAsB,4DAAO;AAC7B;AACA;;;;;;;;;;;;;;;;;;;ACNA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACU;AACF;AACE;AAC/C;AACf;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,2BAA2B,2FAA2F;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAoB;AAC9C;AACA;AACA;AACA;AACA,8CAA8C,mEAAsB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mEAAsB;AACpE;AACA;AACA,0BAA0B,yEAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mEAAsB;AAChE;AACA,sBAAsB,yEAAmB;AACzC;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;AC1DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACwE;AACpB;AACQ;AACN;AAChB;AACvB;AACf;AACA,uBAAuB,oEAAW;AAClC;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAO;AACjC;AACA,QAAQ,8DAAQ;AAChB;AACA,KAAK;AACL;AACO;AACP;AACA,uBAAuB,oEAAW;AAClC;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAO;AACjC;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,uBAAuB,oEAAW;AAClC;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAO;AACjC,QAAQ,8CAAY;AACpB,QAAQ,oFAAmB;AAC3B;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvD0D;AACJ;AACM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,yBAAyB,kEAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAQ;AAChB;AACA;AACA,QAAQ,yEAAmB;AAC3B;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0D;AACY;AACS;AACzB;AAC/C;AACP;AACA;AACA;AACA,2BAA2B,8EAAqB;AAChD,iCAAiC,kEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAQ;AACpB;AACA;AACA;AACA,sBAAsB,uFAAkB;AACxC;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;AClCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACwE;AACjB;AACqB;AAClB;AACQ;AAC+B;AAC1B;AAC3B;AACrC;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,wBAAwB,IAAI;AACrE;AACA;AACA;AACA;AACA,gCAAgC,0DAAa;AAC7C;AACA;AACA;AACA,sBAAsB,0EAAc;AACpC,sBAAsB,oFAAmB;AACzC;AACA,sBAAsB,iEAAgB;AACtC,sBAAsB,kEAAU;AAChC,sBAAsB,yGAAmB;AACzC;AACA;AACA;AACA,YAAY,mDAAiB;AAC7B;AACA,KAAK;AACL;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,iBAAiB,IAAI;AAC9D;AACA;AACA;AACA;AACA,YAAY,oFAAmB;AAC/B;AACA;AACA,YAAY,mDAAiB;AAC7B;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACxDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6D;AACsC;AACjB;AAC9B;AACC;AAC9C;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,2BAA2B,IAAI;AACxE;AACA;AACA;AACA;AACA,mCAAmC,kEAAiB;AACpD,kBAAkB,oEAAmB;AACrC;AACA,YAAY,2GAAoB;AAChC;AACA;AACA,YAAY,0FAAmB;AAC/B;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AChCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqG;AACJ;AACuC;AACxI;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,6BAA6B,YAAY;AAClF;AACA;AACA;AACA,wCAAwC,iHAAqC;AAC7E,wBAAwB,gCAAgC;AACxD,YAAY,gDAAc;AAC1B;AACA,gCAAgC,gDAAc;AAC9C,4BAA4B,2DAAqB;AACjD;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C,YAAY,0DAAoB;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,gDAAgD,qBAAqB;AAC9G;AACA;AACA;AACA;AACA;AACA,4CAA4C,6GAAmC;AAC/E,gCAAgC,2DAAqB;AACrD,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iHAAqC;AACjF,4BAA4B,gCAAgC;AAC5D,gBAAgB,gDAAc;AAC9B;AACA,oCAAoC,gDAAc;AAClD,gCAAgC,2DAAqB;AACrD,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AChFA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACvD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mEAAc;AAChC;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC7BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACc;AAC3D;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,gDAAgD,iBAAiB;AAC1G;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA,uCAAuC,0EAAc;AACrD;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+C;AACwC;AAC1B;AACK;AACC;AAC5D;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,yBAAyB,IAAI;AACtE;AACA;AACA;AACA;AACA;AACA,yCAAyC,mGAA8B;AACvE;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,qBAAqB,IAAI;AAClE;AACA;AACA;AACA;AACA;AACA,yCAAyC,mGAA8B;AACvE;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA,yCAAyC,mGAA8B;AACvE;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,+BAA+B,IAAI;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,qCAAqC,IAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,qCAAqC,IAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0EAAc;AACjD;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA,gCAAgC,qEAAY;AAC5C;AACA,0CAA0C,2DAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,8CAA8C,oBAAoB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,qCAAqC,IAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,wCAAwC,IAAI;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,4CAA4C,IAAI;AACzF;AACA;AACA;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,2BAA2B,IAAI;AACxE;AACA;AACA;AACA;AACA;AACA,yCAAyC,mGAA8B;AACvE;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA,8CAA8C,qEAAY;AAC1D;AACA,sDAAsD,2DAAU;AAChE;AACA;AACA;AACA;AACA;AACA,0DAA0D,qEAAY;AACtE;AACA;AACA,8DAA8D,2DAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA,8CAA8C,qEAAY;AAC1D;AACA,sDAAsD,2DAAU;AAChE;AACA;AACA;AACA;AACA;AACA,0DAA0D,qEAAY;AACtE;AACA;AACA,8DAA8D,2DAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD,oCAAoC,mDAAa;AACjD,sCAAsC,mDAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA,0CAA0C,qEAAY;AACtD;AACA;AACA,8CAA8C,2DAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA,8CAA8C,qEAAY;AAC1D;AACA,sDAAsD,2DAAU;AAChE;AACA;AACA;AACA;AACA;AACA,0DAA0D,qEAAY;AACtE;AACA;AACA,8DAA8D,2DAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,sCAAsC,2DAAU;AAChD;AACA;AACA;AACA;AACA;AACA,0CAA0C,qEAAY;AACtD;AACA;AACA,8CAA8C,2DAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA,0CAA0C,qEAAY;AACtD;AACA,kDAAkD,2DAAU;AAC5D;AACA;AACA;AACA;AACA;AACA,sDAAsD,qEAAY;AAClE;AACA;AACA,0DAA0D,2DAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACp4BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+F;AAClC;AACuB;AACmB;AAC+I;AACtP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,2GAAkC;AAChD;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,yEAAwB;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc,2GAAkC;AAChD;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,+EAA8B;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,8CAA8C,2BAA2B;AAClH;AACA;AACA;AACA,mCAAmC,yEAAiB;AACpD,mCAAmC,oHAAyC;AAC5E;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,+EAA8B;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,6DAA6D,2BAA2B;AACjI;AACA;AACA;AACA,mCAAmC,yEAAiB;AACpD;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,6FAA4C;AACzE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,mDAAmD,2BAA2B;AACvH;AACA;AACA;AACA,mCAAmC,yEAAiB;AACpD;AACA,mCAAmC,oHAAyC;AAC5E;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,+EAA8B;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mCAAmC,yEAAiB;AACpD;AACA,mCAAmC,oHAAyC;AAC5E;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,yEAAwB;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,4DAA4D,2BAA2B;AAChI;AACA;AACA;AACA,mCAAmC,yEAAiB;AACpD;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,wFAAuC;AACpE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,gCAAgC,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD,mCAAmC,gDAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yEAAiB;AACzD;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA,cAAc,oDAAc;AAC5B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,cAAc,yEAAiB;AAC/B;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,+EAA8B;AAC3D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,cAAc,yEAAiB;AAC/B;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,kFAAiC;AAC9D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,cAAc,yEAAiB;AAC/B;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,yEAAwB;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,cAAc,yEAAiB;AAC/B;AACA;AACA,wBAAwB,uBAAuB;AAC/C,6BAA6B,+EAA8B;AAC3D;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5SA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmE;AAC4B;AAClC;AACgB;AAC2B;AACZ;AACE;AAClB;AAC5E;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,yBAAyB,uCAAuC;AACzG;AACA;AACA;AACA,4BAA4B,kEAAqB;AACjD;AACA;AACA,kBAAkB,+EAAoB;AACtC,oCAAoC,qEAAY;AAChD;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA,kBAAkB,2GAAkC;AACpD,oCAAoC,wBAAwB;AAC5D;AACA,gDAAgD,yEAAwB;AACxE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,mCAAmC,6DAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,kCAAkC,uCAAuC;AAClH;AACA;AACA;AACA,iCAAiC,6EAA0B;AAC3D,kCAAkC,kEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qFAAiB;AACtD;AACA;AACA,kBAAkB,+EAAoB;AACtC,sCAAsC,qEAAY;AAClD;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,+BAA+B,uCAAuC;AAC/G;AACA;AACA;AACA,4BAA4B,kEAAqB;AACjD;AACA;AACA,kBAAkB,+EAAoB;AACtC,oCAAoC,qEAAY;AAChD;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA,kBAAkB,2GAAkC;AACpD,oCAAoC,wBAAwB;AAC5D;AACA,gDAAgD,+EAA8B;AAC9E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,4BAA4B,oFAA4B;AACxD;AACA;AACA,kBAAkB,+EAAoB;AACtC,oCAAoC,qEAAY;AAChD;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA,kBAAkB,2GAAkC;AACpD,oCAAoC,wBAAwB;AAC5D;AACA,gDAAgD,+EAA8B;AAC9E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gCAAgC,6CAA6C;AAC7E;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD,wCAAwC,+DAAyB;AACjE;AACA;AACA,cAAc,2GAAkC;AAChD,gCAAgC,6CAA6C;AAC7E;AACA,4CAA4C,+EAA8B;AAC1E;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACjNA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+E;AAC3B;AACS;AAC9C;AACf;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,4BAA4B,gBAAgB;AACrF;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC,kCAAkC,eAAe;AACjD;AACA,kBAAkB,2FAA0B;AAC5C,4BAA4B,qEAAY;AACxC;AACA,gCAAgC,qEAAY;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,mCAAmC,gBAAgB;AAC5F;AACA;AACA;AACA,4BAA4B,qEAAY;AACxC,kCAAkC,eAAe;AACjD;AACA,kBAAkB,2FAA0B;AAC5C,4BAA4B,qEAAY;AACxC;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC9CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACiH;AAChB;AACnC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,4CAA4C,yDAAyD;AAC9I;AACA;AACA;AACA,0BAA0B,0DAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mEAAsB;AACtD;AACA;AACA,gCAAgC,2DAAqB;AACrD;AACA;AACA;AACA,gCAAgC,6HAA2C;AAC3E;AACA,gCAAgC,6HAA2C;AAC3E;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACxDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACV;AACO;AACM;AAC3D;AACP;AACA;AACA;AACA;AACA,YAAY,uEAAa;AACzB;AACA;AACA;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,wBAAwB,IAAI;AACrE;AACA;AACA;AACA,+BAA+B,0EAAc;AAC7C;AACA,yCAAyC,iEAAa;AACtD;AACA;AACA;AACA,QAAQ,wCAAM;AACd;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACrCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACgB;AACZ;AACR;AACvD;AACP;AACA;AACA,uCAAuC,0EAAqB;AAC5D;AACA,gCAAgC,2BAA2B;AAC3D,oBAAoB,0EAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,uCAAuC,kFAA0B;AACjE;AACA,gCAAgC,2BAA2B;AAC3D,oBAAoB,0FAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;ACtDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmF;AACN;AACJ;AAC7B;AACmD;AACnC;AACrD;AACP;AACA;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,cAAc,0BAA0B;AACjF;AACA;AACA,YAAY,wCAAM;AAClB;AACA;AACA;AACA;AACA,4BAA4B,0DAAa;AACzC;AACA,yCAAyC,+FAA4B;AACrE;AACA;AACA,0CAA0C,yFAAyB;AACnE;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA,kBAAkB,2GAAkC;AACpD,4BAA4B,wBAAwB;AACpD;AACA,sCAAsC,0DAAa;AACnD,2CAA2C,sFAAqC;AAChF;AACA;AACA;AACA;AACA,QAAQ,wCAAM;AACd;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,4BAA4B,0DAAa;AACzC;AACA,yCAAyC,+FAA4B;AACrE;AACA;AACA,0CAA0C,yFAAyB;AACnE;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA,sCAAsC,0DAAa;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC3EA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqG;AACJ;AACrD;AACrC;AACP;AACA,gCAAgC,iHAAqC;AACrE,wBAAwB,wBAAwB;AAChD;AACA;AACA,gCAAgC,0DAAa;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,gCAAgC,6GAAmC;AACnE,wBAAwB,wBAAwB;AAChD;AACA;AACA,gCAAgC,0DAAa;AAC7C;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;ACnCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6E;AACJ;AAC7B;AACmD;AACM;AACjD;AAC7C;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,kBAAkB,4BAA4B;AACvF;AACA;AACA;AACA;AACA,4BAA4B,0DAAa;AACzC,yCAAyC,kHAAgC;AACzE;AACA;AACA,0CAA0C,yFAAyB;AACnE;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA,kBAAkB,2GAAkC;AACpD,4BAA4B,wBAAwB;AACpD;AACA,sCAAsC,0DAAa;AACnD,2CAA2C,sFAAqC;AAChF;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,qBAAqB,4BAA4B;AAC1F;AACA;AACA;AACA;AACA,4BAA4B,0DAAa;AACzC,yCAAyC,kHAAgC;AACzE;AACA;AACA,0CAA0C,yFAAyB;AACnE;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA,sCAAsC,0DAAa;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACtEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AAChB;AAC2D;AAC7C;AACC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAa;AAC7B;AACA;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,oBAAoB,YAAY;AAC7E;AACA;AACA;AACA,0BAA0B,2EAAoB;AAC9C;AACA,qCAAqC,oDAAc;AACnD,0BAA0B,kEAA4B;AACtD;AACA;AACA,4BAA4B,qEAAY;AACxC;AACA,0CAA0C,2DAAU;AACpD;AACA;AACA;AACA;AACA,4CAA4C,qEAAY;AACxD;AACA,sDAAsD,2DAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAM;AAClB;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAM;AAClB;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AC3EA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6C;AACe;AACN;AAC0C;AACzB;AACxD;AACf;AACA;AACA,kBAAkB,iEAAY;AAC9B,kBAAkB,oEAAW;AAC7B;AACA,sCAAsC,gFAA2B;AACjE;AACA;AACA;AACA;AACA,sBAAsB,yDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,QAAQ,8DAAQ;AAChB,8BAA8B,oEAAW,CAAC,8DAAQ;AAClD,QAAQ,iEAAY;AACpB,KAAK;AACL;;;;;;;;;;;;;;;;AC/C6D;AACtD;AACP,yBAAyB,kEAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACTA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC8G;AACrD;AAClD;AACP,uHAAuH,+BAA+B;AACtJ;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,8CAA8C,mDAAmD;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iEAA2B;AAChF,mCAAmC,8DAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iEAA2B;AACrE,sCAAsC,8DAAwB;AAC9D;AACA,YAAY,8DAAM;AAClB;AACA;AACA;AACA;AACA,YAAY,8DAAM;AAClB;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;ACtDuD;AAChD;AACP;AACA;AACA,sBAAsB,4DAAO;AAC7B;AACA;;;;;;;;;;;;;;;;;;;;;;ACNA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuE;AACS;AACnB;AAC8B;AAC/B;AAC5D;AACA;AACA;AACe;AACf;AACA;AACA;AACA,oCAAoC,kFAA0B;AAC9D;AACA,gCAAgC,wBAAwB;AACxD;AACA,oBAAoB,qFAAiB;AACrC;AACA;AACA,YAAY,4EAAe;AAC3B,YAAY,4EAAe;AAC3B,YAAY,4EAAe;AAC3B;AACA;AACA,kBAAkB,4DAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kFAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAO;AACnC;AACA;AACA,oEAAoE,2CAA2C;AAC/G;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,8CAA8C;AAC9C,4BAA4B,kEAAO;AACnC,kCAAkC,wEAAgB;AAClD;AACA;AACA;AACA;AACA,wBAAwB,yCAAO;AAC/B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC,kFAA0B;AAC7D;AACA;AACA;AACA;AACA,4BAA4B,kEAAO;AACnC,kCAAkC,wEAAgB,cAAc,0CAA0C;AAC1G;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,8CAA8C;AAC9C,4BAA4B,kEAAO;AACnC,kCAAkC,wEAAgB;AAClD;AACA;AACA;AACA;AACA,wBAAwB,yCAAO;AAC/B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;AC3JA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+D;AACQ;AACD;AACM;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iOAAiO,+BAA+B;AAChQ;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,gCAAgC,oGAAoG;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mFAAqB;AAC/C;AACA;AACA;AACA;AACA,8CAA8C,yFAA2B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yFAA2B;AACzE;AACA,0BAA0B,mFAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yFAA2B;AACrE;AACA,sBAAsB,mFAAwB;AAC9C;AACA;AACA;AACA,QAAQ,wCAAM;AACd;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AC7EA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACA;AACyB;AACnB;AACJ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,2KAA2K,+BAA+B;AAC1M;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,4BAA4B,0FAA0F;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kEAAO;AAClC;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAO;AACzC;AACA;AACA,8BAA8B,4DAAO;AACrC;AACA;AACA,YAAY,qFAAiB;AAC7B;AACA;AACA;AACA,YAAY,8DAAM;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACxEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6D;AACwB;AACxB;AACJ;AACa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yJAAyJ,+BAA+B;AACxL;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,+BAA+B,8EAA8E;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kEAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kEAAU;AAC3C;AACA,iCAAiC,kEAAU;AAC3C;AACA;AACA,gBAAgB,+CAAa;AAC7B,gBAAgB,0FAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC1EA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACyB;AACtB;AACnD;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,yBAAyB,IAAI;AACtE;AACA;AACA;AACA,4BAA4B,uEAAkB;AAC9C,QAAQ,qFAAiB;AACzB,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACtBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACyB;AACO;AACjB;AACtE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,8BAA8B,yBAAyB;AAChG;AACA;AACA;AACA;AACA,gCAAgC,uEAA0B;AAC1D;AACA;AACA,wCAAwC,qFAAiB;AACzD,gCAAgC,wBAAwB;AACxD,gDAAgD,yEAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,oCAAoC,yBAAyB;AACtG;AACA;AACA;AACA;AACA,gCAAgC,uEAA0B;AAC1D;AACA;AACA,wCAAwC,qFAAiB;AACzD,gCAAgC,wBAAwB;AACxD,gDAAgD,+EAAyB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;ACxEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgF;AACK;AACL;AAC7B;AACI;AAChD;AACP;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,0BAA0B,IAAI;AAC3E;AACA;AACA;AACA;AACA;AACA,mCAAmC,0FAAmB;AACtD;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA,gCAAgC,qFAAiB;AACjD;AACA,wCAAwC,yFAAoB;AAC5D;AACA,iCAAiC,+DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,gCAAgC,IAAI;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0FAAmB;AACtD;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA,gCAAgC,qFAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAiB;AAC7C;AACA;AACA;AACA,0CAA0C,qFAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA,0CAA0C,qFAAiB;AAC3D;AACA;AACA;AACA,sDAAsD,qFAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;AC1IA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkG;AAClB;AACY;AAC7E;AACf;AACA,4BAA4B,qFAAiB;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,4CAA4C,WAAW;AAChG;AACA;AACA;AACA,uBAAuB,2DAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,sBAAsB,qFAAiB;AACvC;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,gCAAgC,qFAAiB;AACjD,sCAAsC,eAAe;AACrD;AACA,sBAAsB,2GAA+B;AACrD,gCAAgC,qFAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AC1EA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqF;AAC9E;AACP;AACA;AACA,oCAAoC,0FAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACpBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmH;AACjC;AAC3E;AACP;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW;AAC7C;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oCAAoC,2EAAqC;AACzE;AACA;AACA,yCAAyC,+FAA8B;AACvE;AACA;AACA,4BAA4B,6BAA6B;AACzD,iCAAiC,yDAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACrCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgF;AACD;AACsB;AACxB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,gBAAgB,+CAAa;AAC7B,kCAAkC,iDAAW,yBAAyB,IAAI;AAC1E;AACA;AACA;AACA,2BAA2B,2DAAqB;AAChD;AACA,iCAAiC,qFAAiB;AAClD;AACA,0CAA0C,oFAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAa;AACjD,2BAA2B,yFAA4B;AACvD;AACA;AACA,YAAY,wCAAM;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACvDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACyB;AACpB;AAC7C;AACf,0HAA0H,+BAA+B;AACzJ;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW;AACzC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qFAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAqB;AACvD;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACC;AACmB;AACF;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wKAAwK,+BAA+B;AACvM;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,kCAAkC,0FAA0F;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0EAAuB;AACrE;AACA,0CAA0C,kEAAqB;AAC/D;AACA;AACA;AACA,8CAA8C,0EAAuB;AACrE;AACA,0CAA0C,kEAAqB;AAC/D;AACA;AACA;AACA,8CAA8C,0EAAuB;AACrE;AACA,oDAAoD,qFAAiB;AACrE;AACA;AACA;AACA,8CAA8C,kEAAqB;AACnE;AACA;AACA;AACA;AACA,YAAY,+CAAa;AACzB;AACA,YAAY,wCAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AC7FA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACyB;AACtC;AACS;AACD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mHAAmH,+BAA+B;AAClJ;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW;AACzC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kGAAqC;AACzE;AACA;AACA,0CAA0C,2DAAY;AACtD;AACA,wCAAwC,gEAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;ACjEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC4D;AACqE;AACvC;AAC3C;AACc;AACW;AACI;AACoD;AACd;AAClH;AACO;AACP,uFAAuF,+BAA+B;AACtH;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW;AACzC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAqB;AAC/C,4BAA4B,2DAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mGAA8B;AACzE;AACA,wBAAwB,mCAAmC;AAC3D,gCAAgC,+FAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD,YAAY,iEAAkB;AAC9B,YAAY,iEAAkB;AAC9B,YAAY,iEAAkB;AAC9B;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD,wCAAwC,0DAAa;AACrD;AACA;AACA,8BAA8B,yFAA4B;AAC1D;AACA;AACA,gCAAgC,yFAA4B;AAC5D;AACA,6BAA6B,yFAA4B;AACzD;AACA;AACA;AACA;AACA,mCAAmC,2DAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yFAA2B;AACpE,sBAAsB,qFAAyB;AAC/C;AACA;AACA;AACA,yCAAyC,yFAA2B;AACpE;AACA;AACA,qCAAqC,yFAAiC;AACtE;AACA,4BAA4B,6BAA6B;AACzD;AACA,gDAAgD,sGAA8C;AAC9F;AACA;AACA;AACA;AACA;AACA,2CAA2C,8DAAwB;AACnE;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA,kBAAkB,uEAAoB;AACtC;AACA;AACA,QAAQ,wCAAM;AACd,cAAc,+CAAa;AAC3B,KAAK;AACL;;;;;;;;;;;;;;;;;AC1HA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0D;AACZ;AAC/B;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iEAAoB;AAChE,sBAAsB,2DAAc;AACpC;AACA;AACA,4CAA4C,iEAAoB;AAChE;AACA;AACA,0CAA0C,2DAAc;AACxD;AACA;AACA;AACA,0CAA0C,2DAAc;AACxD;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;AC1CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsE;AACR;AAC/C;AACf;AACA;AACA;AACA;AACA;AACA,+BAA+B,sEAAY;AAC3C,2BAA2B,kFAAkB;AAC7C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;ACtBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmF;AACjC;AACnC;AACf;AACA,kCAAkC,+FAA4B;AAC9D;AACA;AACA,kCAAkC,6DAAgB;AAClD;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;ACrBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACiE;AACkB;AAChB;AACb;AAC6B;AACrB;AACmB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAqB;AAC/D;AACA,sCAAsC,6DAAgB;AACtD;AACA;AACA;AACA,0CAA0C,2DAAqB;AAC/D;AACA,sCAAsC,6DAAgB;AACtD;AACA,mCAAmC,8DAAQ;AAC3C,YAAY,6EAAc;AAC1B;AACA;AACA,0CAA0C,2DAAqB;AAC/D;AACA,gDAAgD,+FAA4B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4EAAyB;AACnE;AACA,gBAAgB,+EAAoB,gBAAgB,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAM;AACd;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC/GA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC2E;AACb;AAChB;AACvC;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,uBAAuB,wDAAwD;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2DAAqB;AAC3D;AACA,kCAAkC,2DAAc;AAChD;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACoD;AACW;AACH;AACV;AACJ;AACvC;AACP;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,yBAAyB,8CAA8C;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAqB;AACzD;AACA;AACA,0CAA0C,2DAAY;AACtD;AACA;AACA,kDAAkD,6DAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,4EAAyB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AChDuD;AAChD;AACP,QAAQ,4DAAO;AACf,QAAQ,4DAAO;AACf;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACLA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0C;AACgB;AAC1D;AACA;AACA;AACA;AACA;AACA,oGAAoG,MAAM;AAC1G;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA,qCAAqC,mDAAa;AAClD,qCAAqC,mDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,MAAM;AAC1G;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA,qCAAqC,mDAAa;AAClD,qCAAqC,mDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,MAAM;AACzG;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA,qCAAqC,mDAAa;AAClD,qCAAqC,mDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA,qCAAqC,mDAAa;AAClD,qCAAqC,mDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA,qCAAqC,mDAAa;AAClD,qCAAqC,mDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sEAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sEAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA,qCAAqC,mDAAa;AAClD,qCAAqC,mDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA,qCAAqC,mDAAa;AAClD,qCAAqC,mDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sEAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sEAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA,qCAAqC,mDAAa;AAClD,qCAAqC,mDAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sEAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sEAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACr7BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6F;AAChD;AACtC;AACP;AACA;AACA,4CAA4C,gFAAiB;AAC7D,4BAA4B,sDAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,4CAA4C,mFAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;AClCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+E;AACQ;AACkB;AACkJ;AACzL;AAC3D;AACP,0GAA0G,8DAAM;AAChH;AACA,YAAY,+CAAa;AACzB,8BAA8B,iDAAW,4BAA4B,oCAAoC;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wFAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6IAA6I,8DAAM;AACnJ;AACA,wCAAwC,8EAAyB;AACjE;AACA;AACA,sBAAsB,gEAAQ;AAC9B,6BAA6B,0FAAqC;AAClE;AACA;AACA,2BAA2B,8DAAM;AACjC,6BAA6B,gGAA2C;AACxE;AACA;AACA;AACA,6BAA6B,uGAAkD;AAC/E;AACA;AACA,2BAA2B,kEAAU;AACrC,wBAAwB,+EAAqB;AAC7C;AACA;AACA,6BAA6B,oGAA+C;AAC5E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,MAAM;AACzG;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,MAAM;AAC1G;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,MAAM;AAC1G;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC,uDAAiB;AACjD;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA,cAAc,oDAAc;AAC5B;AACA;AACA,SAAS;AACT,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;ACpcA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACuD;AACgJ;AACkF;AAClL;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,gEAA0B;AACrD;AACA;AACA;AACA;AACA;AACA,wCAAwC,8EAAyB;AACjE,6BAA6B,oGAA+C;AAC5E,2BAA2B,sFAAiC;AAC5D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,gEAA0B;AACrD;AACA;AACA;AACA;AACA;AACA,wCAAwC,8EAAyB;AACjE,6BAA6B,0FAAqC;AAClE,2BAA2B,iFAA4B;AACvD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,8EAAyB;AACjE,6BAA6B,oGAA+C;AAC5E,2BAA2B,sFAAiC;AAC5D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,8EAAyB;AACjE,6BAA6B,gGAA2C;AACxE,2BAA2B,iFAA4B;AACvD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,8EAAyB;AACjE,6BAA6B,gGAA2C;AACxE,2BAA2B,iFAA4B;AACvD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,8EAAyB;AACjE;AACA;AACA,gCAAgC,2DAAc;AAC9C,gCAAgC,kEAAqB;AACrD,2BAA2B,mFAAsC;AACjE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,8EAAyB;AACjE;AACA;AACA,gCAAgC,2DAAc;AAC9C,gCAAgC,4EAA+B;AAC/D,2BAA2B,4FAA+C;AAC1E;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,8EAAyB;AACjE;AACA;AACA,gCAAgC,+DAAkB;AAClD,gCAAgC,sEAAyB;AACzD,2BAA2B,sFAAyC;AACpE;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACxK0E;AACnE;AACP;AACA;AACA,qCAAqC,+EAAY;AACjD;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,+EAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gBAAgB,+EAAY;AAC5B;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACZA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC8L;AACvL;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAa;AAC/B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAa;AAC/B,6BAA6B;AAC7B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,kBAAkB,+CAAa;AAC/B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAa;AAC/B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iEAA2B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6DAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6EAAuC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8DAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAyB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrJA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACyD;AACmE;AAC9B;AAChC;AACyB;AAC3C;AACkB;AACF;AACF;AACJ;AACsC;AACpB;AACa;AACjC;AACpD;AACe;AACf;AACA,YAAY,gDAAa;AACzB,8BAA8B,kDAAW;AACzC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAoB;AAC9C,4BAA4B,2EAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0DAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mGAA8B;AACzE;AACA;AACA,qCAAqC,iFAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD,YAAY,iEAAkB;AAC9B,YAAY,iEAAkB;AAC9B,YAAY,iEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD,wCAAwC,0DAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2EAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mEAAsB;AAC/D;AACA;AACA,yCAAyC,wFAAgC;AACzE;AACA,gCAAgC,6BAA6B;AAC7D;AACA,oDAAoD,qGAA6C;AACjG;AACA;AACA;AACA;AACA,sBAAsB,mGAA6B;AACnD;AACA;AACA;AACA,yCAAyC,mEAAsB;AAC/D;AACA,yCAAyC,wFAAgC;AACzE;AACA,gCAAgC,6BAA6B;AAC7D;AACA,oDAAoD,qGAA6C;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yEAAmB;AACxD;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA,YAAY,kFAAwB;AACpC;AACA,YAAY,uEAAoB;AAChC;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA,YAAY,+EAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qGAAqB;AAC7B,QAAQ,8DAAQ;AAChB;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;AC7JA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqF;AACT;AACrE;AACP;AACA,6BAA6B,+EAAc;AAC3C;AACA,0BAA0B,4FAAqB;AAC/C;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,QAAQ,+EAAc;AACtB,KAAK;AACL;;;;;;;;;;;;;;;;;AC/BA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACyE;AACf;AACnD;AACP;AACA;AACA;AACA,oCAAoC,kFAAmB;AACvD;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA;AACA;AACA;AACA,oCAAoC,oDAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mDAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACnDA;AACO;AACP;AACA;AACA;AACA,wDAAwD,GAAG;AAC3D;AACA;AACA;AACA;AACA,+CAA+C,IAAI;AACnD,eAAe,EAAE,IAAI,EAAE,IAAI,EAAE;AAC7B;AACA,kBAAkB,GAAG,qDAAqD;AAC1E,2JAA2J,IAAI,GAAG,EAAE,aAAa,IAAI;AACrL,wBAAwB,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,GAAG;AACvF;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChDA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsD;AACuB;AAC/B;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAqB;AAC1D;AACA;AACA,gCAAgC,kEAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAgB;AAC9C;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,UAAU;AACxF;AACA;AACA;AACA,iEAAiE,WAAW;AAC5E;AACA;AACA;AACA,+EAA+E,SAAS;AACxF;AACA;AACA;AACA,4EAA4E,SAAS;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,yBAAyB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAM;AAClB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yKAAyK;AACjM;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAM;AAClB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;AClLO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzB8C;AACvC,yBAAyB,uDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkD;AACqF;AACvG;AACwB;AACjD,oCAAoC,2DAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa,GAAG,aAAa;AACjF;AACA;AACA;AACA,iCAAiC,8CAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iDAAe;AACpD;AACA;AACA;AACA,0CAA0C,iDAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wCAAM;AACrD,gBAAgB,yDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,OAAO;AACP;AACA,iCAAiC,iCAAK;AACtC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,QAAQ,qEAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,OAAO;AACP;AACA,6BAA6B,iCAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,OAAO;AACP;AACA,6BAA6B,iCAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6DAAuB;AACnE,kBAAkB,8DAAwB;AAC1C;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;AC9TA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC0C;AAC1C;AACA;AACA;AACA;AACO,6BAA6B,mDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjKA,WAAW,wBAAwB;AAC6B;AACzD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAAqB;AAC/C;AACA;;;;;;;;;;;;;;;;;ACrBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACwC;AACc;AACtD;AACA;AACA;AACA;AACA;AACO;AACP;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,iCAAiC;AACjC;AACA,sBAAsB,8DAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA,kDAAkD,gDAAc;AAChE,wCAAwC,0BAA0B;AAClE,kCAAkC,gDAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA,kDAAkD,gDAAc;AAChE,wCAAwC,0BAA0B;AAClE;AACA,sCAAsC,gDAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;AC/LA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmE;AACwD;AACrE;AACgF;AAC3E;AAC3D;AACA;AACA;AACO,2CAA2C,oEAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2DAAqB;AACzD;AACA,0BAA0B,+EAAoB;AAC9C;AACA,4CAA4C,8CAAY;AACxD;AACA;AACA,4CAA4C,6BAA6B;AACzE;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAkC;AACxD;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAAQ;AACvC,6CAA6C,kCAAkC;AAC/E;AACA,oDAAoD,kFAAwB;AAC5E;AACA;AACA;AACA;AACA,oCAAoC,wCAAM;AAC1C,6CAA6C,kCAAkC;AAC/E;AACA,oDAAoD,wFAA8B;AAClF;AACA;AACA;AACA;AACA,oCAAoC,wCAAM;AAC1C,6CAA6C,kCAAkC;AAC/E;AACA,oDAAoD,wFAA8B;AAClF;AACA;AACA;AACA;AACA;AACA,6CAA6C,kCAAkC;AAC/E;AACA,oDAAoD,kFAAwB;AAC5E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO,oFAAoF,0CAAQ;AACnG;AACA;AACA;AACA;AACA,IAAI,8DAAM;AACV;AACA;;;;;;;;;;;;;;;;;;;AC1GA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkE;AACwF;AAC/F;AACpD,uCAAuC,oEAAkB;AAChE,6BAA6B,0CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,4EAAkB;AACjE;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D,gDAAgD,gDAAc;AAC9D;AACA,+BAA+B,0CAAQ;AACvC;AACA,kCAAkC,kFAAwB;AAC1D;AACA,oCAAoC,wCAAM;AAC1C,kCAAkC,wFAA8B;AAChE;AACA,oCAAoC,wCAAM;AAC1C,kCAAkC,wFAA8B;AAChE;AACA;AACA,kCAAkC,kFAAwB;AAC1D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6CAA6C,0CAAQ;AAC5D;AACA;;;;;;;;;;;;;;;;;;;;ACjEA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmH;AAC5C;AACmC;AAC/C;AACpD,oCAAoC,oEAAkB;AAC7D,8DAA8D,wCAAM;AACpE;AACA;AACA,sBAAsB,wCAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+EAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAc;AAC1C,gDAAgD,2BAA2B;AAC3E;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oCAAoC,2DAAqB;AACzD,mCAAmC,gEAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB,oDAAc;AAChC,+BAA+B,wCAAM;AACrC,kCAAkC,+FAAqB;AACvD;AACA;AACA,kCAAkC,+FAAqB;AACvD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2EAA2E,wCAAM;AACxF;AACA;;;;;;;;;;;;;;;;;;;;ACxGA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC8L;AAClH;AAC0B;AAC3C;AAC3D;AACA;AACA;AACO,gCAAgC,oEAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAa;AACjD;AACA,iDAAiD,kEAA4B;AAC7E;AACA;AACA,kDAAkD,+DAAyB;AAC3E;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC,uDAAiB;AACtD,4BAA4B,6BAA6B;AACzD;AACA,sCAAsC,mDAAa;AACnD;AACA,mCAAmC,8DAAM;AACzC,+CAA+C,wFAA8B;AAC7E;AACA;AACA,wCAAwC,gEAAQ;AAChD,+CAA+C,kFAAwB;AACvE;AACA;AACA,wCAAwC,kEAAU;AAClD,+CAA+C,2EAAqC;AACpF;AACA;AACA;AACA,+CAA+C,2EAAqC;AACpF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,gHAAgH;AACrL,kEAAkE;AAClE;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4DAA4D,8DAAM;AACzE;AACA;AACA;AACA;AACA,SAAS;AACT;;;;;;;;;;;;;;;;;ACnJA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACgJ;AAC7F;AACnD,wCAAwC,oDAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gDAAc;AAChE,wCAAwC,0BAA0B;AAClE,kCAAkC,gDAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAiB;AAC1D;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8CAA8C,2DAAG;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6EAAuC;AACzE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;AC9IA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC6D;AACU;AAC0D;AACtE;AACpD,8CAA8C,oEAAkB;AACvE;AACA;AACA;AACA,yBAAyB,iDAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6DAAK;AAC/C,mCAAmC,wDAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,+BAA+B,8DAAM;AACrC,kCAAkC,iGAAuB;AACzD;AACA,oCAAoC,gEAAQ;AAC5C,kCAAkC,iGAAuB;AACzD;AACA;AACA,kCAAkC,2FAAiB;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;AC9DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AAC+C;AACO;AACK;AACpD,8CAA8C,oEAAkB;AACvE,6CAA6C,8DAAM;AACnD;AACA;AACA,sBAAsB,8DAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAqB;AACnD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mEAAmE,8DAAM;AAChF;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACmC;AACkD;AAClB;AACQ;AACpB;AACsC;AACqB;AAC5B;AACqC;AACrB;AACvB;AACQ;AACuD;AAC1E;AACkB;AACK;AACY;AACX;AACR;AAC3B;AACc;AACK;AACT;AACC;AACuD;AAC9D;AACM;AACG;AACR;AACC;AACmI;AACuD;AACnM;AACM;AACkC;AACjD;AAC+B;AAC3B;AACA;AACL;AACgC;AACpB;AACS;AACkF;AACvF;AACU;AACD;AACO;AACkB;AACf;AACI;AACE;AAC+C;AAClD;AACkB;AAC3B;AACQ;AACqG;AACjH;AAC+B;AAChC;AACC;AAC8C;AAClB;AACkB;AAC1C;AACgC;AAChC;AACkD;AACzC;AACR;AACU;AACuB;AACtC;AACa;AACN;AACqD;AAC5C;AACQ;AACT;AACb;AACgB;AACR;AAC1B;AACF;AACQ;AACM;AACR;AACG;AACK;AACR;AACE;AACU;AACF;AACI;AACoB;AACZ;AACV;AACC;AACT;AACa;AACE;AAC8B;AAC4B;AAC3E;AACR;AACmB;AACT;AACR;AACiC;AAC/B;AACiB;AACG;AAC/B;AACM;AACM;AACL;AACO;AAC4D;AAC5C;AACL;AACU;AAC7B;AACI;AACQ;AACvD;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gFAAY;AAChB;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAwE;AAC5F;AACA;AACA;AACA;AACA,YAAY,6DAAO;AACnB,YAAY,6DAAO;AACnB,YAAY,6DAAO;AACnB,YAAY,6DAAO;AACnB,YAAY,gFAAY;AACxB;AACA;AACA;AACA,YAAY,6DAAO;AACnB;AACA,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,4EAAe;AAC/B,gBAAgB,kEAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,UAAU;AACvE;AACA;AACA,iCAAiC;AACjC;AACA,iCAAiC;AACjC;AACA;AACA,0DAA0D;AAC1D,iCAAiC;AACjC;AACA;AACA,8BAA8B;AAC9B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4JAA4J;AAC5J;AACA;AACA,uCAAuC,gFAAe,gCAAgC,6IAA6I;AACnO;AACA;AACA,uCAAuC,oFAAmB,gCAAgC,6IAA6I;AACvO;AACA;AACA,kEAAkE,MAAM,EAAE,wBAAwB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA,oDAAoD,2BAA2B;AAC/E;AACA;AACA;AACA,uDAAuD,2BAA2B;AAClF,oDAAoD,2BAA2B;AAC/E;AACA,wEAAwE,eAAe;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,eAAe;AAC1E;AACA,sHAAsH,eAAe;AACrI;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA,6EAA6E,KAAK;AAClF;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,oCAAoC,WAAW,6BAA6B;AAC5E;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,eAAe;AACzE,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA,oCAAoC,iBAAiB;AACrD,cAAc;AACd,YAAY;AACZ,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAO;AACxB,mBAAmB,6DAAO;AAC1B,yBAAyB,gFAAY;AACrC,qBAAqB,6DAAO;AAC5B;AACA,6BAA6B,6DAAO;AACpC,SAAS;AACT,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wEAAgB;AACpB,gBAAgB,gBAAgB;AAChC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6CAA6C,KAAK;AAClD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8EAAkC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0FAAgC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc,6FAA8B;AAC5C;AACA,YAAY,4EAAe;AAC3B,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc,kHAAkC;AAChD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wFAAyB;AACvC;AACA,YAAY,4EAAe;AAC3B,YAAY,4EAAe;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC;AAC7C;AACA;AACA,oCAAoC,GAAG;AACvC,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA,QAAQ,wEAAgB,eAAe,kCAAkC,MAAM;AAC/E;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA,KAAK;AACL;;;;;;;SC1oBA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;SENA;SACA;SACA;SACA","sources":["webpack://mftsccs-browser/./src/AccessTracker/accessTracker.ts","webpack://mftsccs-browser/./src/Anomaly/anomaly.ts","webpack://mftsccs-browser/./src/Api/Create/CreateTheCharacter.ts","webpack://mftsccs-browser/./src/Api/Create/CreateTheConceptApi.ts","webpack://mftsccs-browser/./src/Api/Create/CreateTheConnectionApi.ts","webpack://mftsccs-browser/./src/Api/Create/CreateTheGhostConceptApi.ts","webpack://mftsccs-browser/./src/Api/Create/CreateTheTextData.ts","webpack://mftsccs-browser/./src/Api/DeleteTheConcept.ts","webpack://mftsccs-browser/./src/Api/DeleteTheConnection.ts","webpack://mftsccs-browser/./src/Api/Delete/DeleteConceptInBackend.ts","webpack://mftsccs-browser/./src/Api/Delete/DeleteUserInBackend.ts","webpack://mftsccs-browser/./src/Api/GetAiData.ts","webpack://mftsccs-browser/./src/Api/GetAllConceptsByType.ts","webpack://mftsccs-browser/./src/Api/GetAllConnectionsOfComposition.ts","webpack://mftsccs-browser/./src/Api/GetAllConnectionsOfCompositionBulk.ts","webpack://mftsccs-browser/./src/Api/GetAllLinkerConnectionsFromTheConcept.ts","webpack://mftsccs-browser/./src/Api/GetAllLinkerConnectionsToTheConcept.ts","webpack://mftsccs-browser/./src/Api/GetCompositionConnectionsBetweenTwoConcepts.ts","webpack://mftsccs-browser/./src/Api/GetConcept.ts","webpack://mftsccs-browser/./src/Api/GetConceptBulk.ts","webpack://mftsccs-browser/./src/Api/GetConceptByCharacterAndType.ts","webpack://mftsccs-browser/./src/Api/GetConceptByCharacterValue.ts","webpack://mftsccs-browser/./src/Api/GetConnection.ts","webpack://mftsccs-browser/./src/Api/GetConnectionBulk.ts","webpack://mftsccs-browser/./src/Api/GetConnectionOfTheConcept.ts","webpack://mftsccs-browser/./src/Api/GetReservedConnectionIds.ts","webpack://mftsccs-browser/./src/Api/GetReservedIds.ts","webpack://mftsccs-browser/./src/Api/Local/GetLocalConceptByCharacterValue.ts","webpack://mftsccs-browser/./src/Api/Login.ts","webpack://mftsccs-browser/./src/Api/MakeTheNameInBackend.ts","webpack://mftsccs-browser/./src/Api/MakeTheTypeConceptApi.ts","webpack://mftsccs-browser/./src/Api/RecursiveSearch.ts","webpack://mftsccs-browser/./src/Api/SearchConcept/GetConceptByCharacterAndCategoryDirect.ts","webpack://mftsccs-browser/./src/Api/Search/FreeschemaQueryApi.ts","webpack://mftsccs-browser/./src/Api/Search/Search.ts","webpack://mftsccs-browser/./src/Api/Search/SearchInternalApi.ts","webpack://mftsccs-browser/./src/Api/Search/SearchLinkMultipleApi.ts","webpack://mftsccs-browser/./src/Api/Search/SearchWithLinker.ts","webpack://mftsccs-browser/./src/Api/Search/SearchWithTypeAndLinker.ts","webpack://mftsccs-browser/./src/Api/Session/CreateSession.ts","webpack://mftsccs-browser/./src/Api/Session/CreateSessionVisit.ts","webpack://mftsccs-browser/./src/Api/Signin.ts","webpack://mftsccs-browser/./src/Api/Signup.ts","webpack://mftsccs-browser/./src/Api/Translate/TranslateLocalToReal.ts","webpack://mftsccs-browser/./src/Api/View/ViewInternalDataApi.ts","webpack://mftsccs-browser/./src/Constants/AccessConstants.ts","webpack://mftsccs-browser/./src/Constants/FormatConstants.ts","webpack://mftsccs-browser/./src/Constants/general.const.ts","webpack://mftsccs-browser/./src/DataStructures/BaseUrl.ts","webpack://mftsccs-browser/./src/DataStructures/BinaryCharacterTree.ts","webpack://mftsccs-browser/./src/DataStructures/BinaryTree.ts","webpack://mftsccs-browser/./src/DataStructures/BinaryTypeTree.ts","webpack://mftsccs-browser/./src/DataStructures/CharacterRepository.ts","webpack://mftsccs-browser/./src/DataStructures/Composition/Composition.ts","webpack://mftsccs-browser/./src/DataStructures/Composition/CompositionBinaryTree.ts","webpack://mftsccs-browser/./src/DataStructures/Composition/CompositionNode.ts","webpack://mftsccs-browser/./src/DataStructures/Concept.ts","webpack://mftsccs-browser/./src/DataStructures/ConceptData.ts","webpack://mftsccs-browser/./src/DataStructures/Connection.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/ConnectionBinaryTree.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/ConnectionNode.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/ConnectionOfNode.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/ConnectionOfTheTree.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/ConnectionTypeNode.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/ConnectionTypeTree.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionBinaryTree/NodePrimitive.ts","webpack://mftsccs-browser/./src/DataStructures/ConnectionData.ts","webpack://mftsccs-browser/./src/DataStructures/FilterSearch.ts","webpack://mftsccs-browser/./src/DataStructures/IdentifierFlags.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LConcept.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LConnection.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LNode.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalBinaryCharacterTree.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalBinaryTree.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalBinaryTypeTree.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalConceptData.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalConnectionData.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalGhostIdTree.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalId.ts","webpack://mftsccs-browser/./src/DataStructures/Local/LocalSyncData.ts","webpack://mftsccs-browser/./src/DataStructures/Node.ts","webpack://mftsccs-browser/./src/DataStructures/PatcherStructure.ts","webpack://mftsccs-browser/./src/DataStructures/ReservedIds.ts","webpack://mftsccs-browser/./src/DataStructures/Responses/ErrorResponse.ts","webpack://mftsccs-browser/./src/DataStructures/Returner.ts","webpack://mftsccs-browser/./src/DataStructures/SearchQuery.ts","webpack://mftsccs-browser/./src/DataStructures/Search/FreeschemaQuery.ts","webpack://mftsccs-browser/./src/DataStructures/Search/SearchStructure.ts","webpack://mftsccs-browser/./src/DataStructures/Security/TokenStorage.ts","webpack://mftsccs-browser/./src/DataStructures/Session/SessionData.ts","webpack://mftsccs-browser/./src/DataStructures/SettingData.ts","webpack://mftsccs-browser/./src/DataStructures/Settings.ts","webpack://mftsccs-browser/./src/DataStructures/SyncData.ts","webpack://mftsccs-browser/./src/DataStructures/TheCharacter.ts","webpack://mftsccs-browser/./src/DataStructures/TheTexts.ts","webpack://mftsccs-browser/./src/DataStructures/TypeNode.ts","webpack://mftsccs-browser/./src/DataStructures/User/UserBinaryTree.ts","webpack://mftsccs-browser/./src/DataStructures/User/UserNode.ts","webpack://mftsccs-browser/./src/Database/NoIndexDb.ts","webpack://mftsccs-browser/./src/Database/indexdblocal.ts","webpack://mftsccs-browser/./src/Database/indexeddb.ts","webpack://mftsccs-browser/./src/Helpers/CheckIfExists.ts","webpack://mftsccs-browser/./src/Helpers/RemoveFromArray.ts","webpack://mftsccs-browser/./src/Helpers/UniqueInsert.ts","webpack://mftsccs-browser/./src/Middleware/EventLogger.ts","webpack://mftsccs-browser/./src/Middleware/logger.service.ts","webpack://mftsccs-browser/./src/Services/CheckForConnectionDeletion.ts","webpack://mftsccs-browser/./src/Services/Common/DelayFunction.ts","webpack://mftsccs-browser/./src/Services/Common/ErrorPosting.ts","webpack://mftsccs-browser/./src/Services/Common/RegexFunction.ts","webpack://mftsccs-browser/./src/Services/Composition/BuildComposition.ts","webpack://mftsccs-browser/./src/Services/Composition/CompositionCache.ts","webpack://mftsccs-browser/./src/Services/Composition/CreateCompositionCache.ts","webpack://mftsccs-browser/./src/Services/ConceptFinding/GetConceptByCharacterAndCategory.ts","webpack://mftsccs-browser/./src/Services/Conversion/ConvertConcepts.ts","webpack://mftsccs-browser/./src/Services/CreateBinaryTreeFromData.ts","webpack://mftsccs-browser/./src/Services/CreateConnectionBetweenTwoConcepts.ts","webpack://mftsccs-browser/./src/Services/CreateDefaultConcept.ts","webpack://mftsccs-browser/./src/Services/CreateTheComposition.ts","webpack://mftsccs-browser/./src/Services/CreateTheConcept.ts","webpack://mftsccs-browser/./src/Services/CreateTheConnection.ts","webpack://mftsccs-browser/./src/Services/CreateTheConnectionGeneral.ts","webpack://mftsccs-browser/./src/Services/DeleteConcept.ts","webpack://mftsccs-browser/./src/Services/DeleteConnection.ts","webpack://mftsccs-browser/./src/Services/DeleteConnectionByType.ts","webpack://mftsccs-browser/./src/Services/FindConeceptsFromConnection.ts","webpack://mftsccs-browser/./src/Services/FindConnectionsOfCompositionBulkInMemory.ts","webpack://mftsccs-browser/./src/Services/GetComposition.ts","webpack://mftsccs-browser/./src/Services/GetCompositionBulk.ts","webpack://mftsccs-browser/./src/Services/GetCompositionList.ts","webpack://mftsccs-browser/./src/Services/GetConceptByCharacter.ts","webpack://mftsccs-browser/./src/Services/GetConnectionBetweenTwoConceptsLinker.ts","webpack://mftsccs-browser/./src/Services/GetConnections.ts","webpack://mftsccs-browser/./src/Services/GetDataFromIndexDb.ts","webpack://mftsccs-browser/./src/Services/GetLink.ts","webpack://mftsccs-browser/./src/Services/GetLinkerConnectionFromConcept.ts","webpack://mftsccs-browser/./src/Services/GetRelation.ts","webpack://mftsccs-browser/./src/Services/GetTheConcept.ts","webpack://mftsccs-browser/./src/Services/InitializeSystem.ts","webpack://mftsccs-browser/./src/Services/Local/ConvertFromLConnectionToConnection.ts","webpack://mftsccs-browser/./src/Services/Local/CreateConnectionBetweenTwoConceptsLocal.ts","webpack://mftsccs-browser/./src/Services/Local/CreateDefaultLConcept.ts","webpack://mftsccs-browser/./src/Services/Local/CreateLocalBinaryTreeFromData.ts","webpack://mftsccs-browser/./src/Services/Local/CreateTheCompositionLocal.ts","webpack://mftsccs-browser/./src/Services/Local/CreateTheConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/CreateTheConnectionLocal.ts","webpack://mftsccs-browser/./src/Services/Local/DeleteConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetCompositionListLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetCompositionLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetConceptByCharacterLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetConnectionOfTheConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetRelationLocal.ts","webpack://mftsccs-browser/./src/Services/Local/GetTheConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/MakeTheConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/MakeTheInstanceConceptLocal.ts","webpack://mftsccs-browser/./src/Services/Local/MakeTheTypeLocal.ts","webpack://mftsccs-browser/./src/Services/Local/UpdateCompositionLocal.ts","webpack://mftsccs-browser/./src/Services/MakeTheCharacter.ts","webpack://mftsccs-browser/./src/Services/MakeTheCharacterData.ts","webpack://mftsccs-browser/./src/Services/MakeTheConcept.ts","webpack://mftsccs-browser/./src/Services/MakeTheInstanceConcept.ts","webpack://mftsccs-browser/./src/Services/MakeTheTimestamp.ts","webpack://mftsccs-browser/./src/Services/MakeTheTypeConcept.ts","webpack://mftsccs-browser/./src/Services/Mqtt/publishMessage.ts","webpack://mftsccs-browser/./src/Services/Search/FormatData.ts","webpack://mftsccs-browser/./src/Services/Search/SearchLinkInternal.ts","webpack://mftsccs-browser/./src/Services/Search/SearchLinkMultiple.ts","webpack://mftsccs-browser/./src/Services/Search/SearchWithTypeAndLinker.ts","webpack://mftsccs-browser/./src/Services/Security/GetRequestHeader.ts","webpack://mftsccs-browser/./src/Services/SplitStrings.ts","webpack://mftsccs-browser/./src/Services/Transaction/LocalTransaction.ts","webpack://mftsccs-browser/./src/Services/UpdateComposition.ts","webpack://mftsccs-browser/./src/Services/User/UserTranslation.ts","webpack://mftsccs-browser/./src/Services/View/ViewInternalData.ts","webpack://mftsccs-browser/./src/Validator/constant.ts","webpack://mftsccs-browser/./src/Validator/utils.ts","webpack://mftsccs-browser/./src/Validator/validator.ts","webpack://mftsccs-browser/./src/Widgets/BaseObserver.ts","webpack://mftsccs-browser/./src/Widgets/BaseWidget.ts","webpack://mftsccs-browser/./src/Widgets/BuilderSpeceficFunctions.ts","webpack://mftsccs-browser/./src/Widgets/BuilderStatefulWidget.ts","webpack://mftsccs-browser/./src/Widgets/StatefulWidget.ts","webpack://mftsccs-browser/./src/Widgets/WidgetTree.ts","webpack://mftsccs-browser/./src/WrapperFunctions/DepenedencyObserver.ts","webpack://mftsccs-browser/./src/WrapperFunctions/GetCompositionListObservable.ts","webpack://mftsccs-browser/./src/WrapperFunctions/GetCompositionObservable.ts","webpack://mftsccs-browser/./src/WrapperFunctions/GetLinkListObservable.ts","webpack://mftsccs-browser/./src/WrapperFunctions/GetLinkObservable.ts","webpack://mftsccs-browser/./src/WrapperFunctions/RecursiveSearchObservable.ts","webpack://mftsccs-browser/./src/WrapperFunctions/SchemaQueryObservable.ts","webpack://mftsccs-browser/./src/WrapperFunctions/SearchLinkMultipleAllObservable.ts","webpack://mftsccs-browser/./src/app.ts","webpack://mftsccs-browser/webpack/bootstrap","webpack://mftsccs-browser/webpack/runtime/define property getters","webpack://mftsccs-browser/webpack/runtime/hasOwnProperty shorthand","webpack://mftsccs-browser/webpack/runtime/make namespace object","webpack://mftsccs-browser/webpack/before-startup","webpack://mftsccs-browser/webpack/startup","webpack://mftsccs-browser/webpack/after-startup"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nimport { BaseUrl, ConceptsData, ConnectionData } from \"../app\";\nimport { TokenStorage } from \"../DataStructures/Security/TokenStorage\";\nexport class AccessTracker {\n    /**\n     * Increments the count for a specific conceptId.\n     */\n    static incrementConcept(conceptId) {\n        // console.log(\"Inside incrementConcept with : \", conceptId);\n        if (conceptId) {\n            this.conceptsData[conceptId] = (this.conceptsData[conceptId] || 0) + 1;\n            // this.saveDataToLocalStorage()\n        }\n    }\n    /**\n     * Increments the count for a specific connectionId.\n     */\n    static incrementConnection(connectionId) {\n        // console.log(\"Inside incrementConnection with : \", connectionId);\n        if (connectionId) {\n            this.connectionsData[connectionId] = (this.connectionsData[connectionId] || 0) + 1;\n            // this.saveDataToLocalStorage()\n        }\n    }\n    /**\n     * Retrieves the top N concepts by their counts.\n     */\n    static getTopConcepts(n) {\n        return Object.entries(this.conceptsData)\n            .map(([key, value]) => [parseInt(key), value])\n            .sort((a, b) => b[1] - a[1])\n            .slice(0, n);\n    }\n    /**\n     * Retrieves the top N connections by their counts.\n     */\n    static getTopConnections(n) {\n        return Object.entries(this.connectionsData)\n            .map(([key, value]) => [parseInt(key), value])\n            .sort((a, b) => b[1] - a[1])\n            .slice(0, n);\n    }\n    /**\n     * Saves the concept and connection data to localStorage.\n     */\n    static saveDataToLocalStorage() {\n        const data = {\n            concepts: this.conceptsData,\n            connections: this.connectionsData\n        };\n        localStorage === null || localStorage === void 0 ? void 0 : localStorage.setItem('trackerData', JSON.stringify(data));\n    }\n    /**\n     * Loads the concept and connection data from localStorage.\n     */\n    static loadDataFromLocalStorage() {\n        const savedData = localStorage === null || localStorage === void 0 ? void 0 : localStorage.getItem('trackerData');\n        if (savedData) {\n            const data = JSON.parse(savedData);\n            this.conceptsData = data.concepts || {};\n            this.connectionsData = data.connections || {};\n        }\n    }\n    /**\n     * Syncs the concept and connection data with the server.\n     */\n    static syncToServer(accessToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!Object.keys(this.conceptsData).length && !Object.keys(this.connectionsData).length) {\n                // console.log(\"No data to sync. Skipping...\");\n                return;\n            }\n            try {\n                // console.log(`Sync started at ${new Date().toISOString()} with token: ${accessToken}`);\n                // Ensure conceptsData and connectionsData are not undefined or null\n                const conceptsToSend = this.conceptsData && Object.keys(this.conceptsData).length > 0 ? this.conceptsData : {};\n                const connectionsToSend = this.connectionsData && Object.keys(this.connectionsData).length > 0 ? this.connectionsData : {};\n                // console.log(\"I am getting url : \", BaseUrl.PostPrefetchConceptConnections());\n                const response = yield fetch(BaseUrl.PostPrefetchConceptConnections(), {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        Authorization: `Bearer ${accessToken}`,\n                    },\n                    body: JSON.stringify({\n                        concepts: conceptsToSend,\n                        connections: connectionsToSend\n                    }),\n                });\n                if (!response.ok) {\n                    throw new Error('Failed to sync data to the server.');\n                }\n                const serverData = yield response.json();\n                console.log(\"Server Data after sync : \", serverData);\n                this.conceptsData = {};\n                this.connectionsData = {};\n                // this.conceptsData = serverData.concepts;\n                // this.connectionsData = serverData.connections;\n                // this.saveDataToLocalStorage();\n                // console.log(`Sync successful at ${new Date().toISOString()}`);\n                this.setNextSyncTime();\n            }\n            catch (error) {\n                console.error('Sync error:', error);\n            }\n        });\n    }\n    /**\n     * Sets the next sync time based on the current time and sync interval.\n     */\n    static setNextSyncTime() {\n        // Calculate next sync time (current time + TimeToSync interval)\n        this.nextSyncTime = Date.now() + this.TimeToSync;\n        // console.log(`Next sync scheduled at: ${new Date(this.nextSyncTime).toLocaleString()}`); // Log next sync time\n    }\n    /**\n     * Starts auto-syncing to the server every specified time interval.\n     * This will automatically call `syncToServer` every 5 minutes\n     */\n    static startAutoSync() {\n        const tokenString = TokenStorage.BearerAccessToken;\n        if (tokenString) {\n            // console.log(\"[AUTO-SYNC] Auto-sync initialized.\");\n            this.syncNow().catch(console.error);\n        }\n        setInterval(() => {\n            const currentTime = Date.now();\n            // console.log(`[CHECK] Current Time: ${new Date(currentTime).toISOString()}`);\n            if (currentTime >= this.nextSyncTime) {\n                // console.log(`[SYNC TRIGGER] Time to sync! Triggering sync at: ${new Date(currentTime).toISOString()}`);\n                this.syncNow().catch(console.error);\n            }\n            else {\n                // console.log(`[WAIT] Not time to sync yet. Next Sync Time: ${new Date(this.nextSyncTime).toISOString()}`);\n            }\n        }, 10000); // Check every 10 Seconds\n    }\n    /**\n     * Sync immediately (called by setInterval when time to sync has arrived).\n     */\n    static syncNow() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tokenString = TokenStorage.BearerAccessToken;\n            if (tokenString) {\n                //   console.log(`[MANUAL SYNC] Sync manually triggered at: ${new Date().toISOString()}`);\n                yield this.syncToServer(tokenString);\n            }\n            else {\n                console.warn(\"[MANUAL SYNC] No valid access token found. Sync aborted.\");\n            }\n        });\n    }\n    /**\n     * Fetch suggested concepts from the server with proper error handling.\n     */\n    static GetSuggestedConcepts(top) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const accessToken = TokenStorage.BearerAccessToken;\n                // Construct the URL with the top parameter if it exists\n                const url = new URL(BaseUrl.GetSuggestedConcepts());\n                if (top !== undefined) {\n                    url.searchParams.append('top', top.toString());\n                }\n                const response = yield fetch(url.toString(), {\n                    method: 'GET',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        Authorization: `Bearer ${accessToken}`,\n                    },\n                });\n                if (!response.ok) {\n                    const errorDetails = yield response.text();\n                    throw new Error(`Failed to load concepts: ${response.status} ${response.statusText}. Details: ${errorDetails}`);\n                }\n                const concepts = (yield response.json()) || [];\n                yield this.addConceptToBinaryTree(concepts.data);\n                return concepts;\n            }\n            catch (error) {\n                if (error instanceof Error) {\n                    console.error('Error fetching suggested concepts:', error.message);\n                    throw new Error('Unable to fetch suggested concepts. Please try again later.');\n                }\n                else {\n                    console.error('An unexpected error occurred:', error);\n                    throw new Error('An unexpected error occurred while fetching suggested concepts.');\n                }\n            }\n        });\n    }\n    /**\n     * Fetch suggested connections from the server with proper error handling.\n     */\n    static GetSuggestedConnections(top) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const accessToken = TokenStorage.BearerAccessToken;\n                // Construct the URL with the top parameter if it exists\n                const url = new URL(BaseUrl.GetSuggestedConnections());\n                if (top !== undefined) {\n                    url.searchParams.append('top', top.toString());\n                }\n                const response = yield fetch(url.toString(), {\n                    method: 'GET',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        Authorization: `Bearer ${accessToken}`,\n                    },\n                });\n                if (!response.ok) {\n                    const errorDetails = yield response.text();\n                    throw new Error(`Failed to load connections: ${response.status} ${response.statusText}. Details: ${errorDetails}`);\n                }\n                const connections = (yield response.json()) || [];\n                yield this.addConnectionToBinaryTree(connections.data);\n                return connections;\n            }\n            catch (error) {\n                if (error instanceof Error) {\n                    console.error('Error fetching suggested Connections:', error.message);\n                    throw new Error('Unable to fetch suggested connections. Please try again later.');\n                }\n                else {\n                    console.error('An unexpected error occurred:', error);\n                    throw new Error('An unexpected error occurred while fetching suggested Connections.');\n                }\n            }\n        });\n    }\n    /**\n     * Add Concepts to Binary Tree\n     */\n    static addConceptToBinaryTree(conceptsDataArray) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // console.log(\"Concepts Data Array : \", conceptsDataArray);\n            try {\n                // console.log(\"Start Adding Concepts to Binary Tree...\");\n                conceptsDataArray.forEach(conceptObject => {\n                    // console.log(\"Concept Object : \", conceptObject);\n                    ConceptsData.AddConcept(conceptObject);\n                });\n            }\n            catch (error) {\n                console.error(\"Error on adding Concepts Data into tree\");\n            }\n        });\n    }\n    /**\n     * Add Concepts to Binary Tree\n     */\n    static addConnectionToBinaryTree(connectionsDataArray) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // console.log(\"Start Adding Connections to Binary Tree...\");\n                connectionsDataArray.forEach(connectionObject => {\n                    // console.log(\"Connection Object : \", connectionObject);\n                    ConnectionData.AddConnection(connectionObject);\n                });\n            }\n            catch (error) {\n                console.error(\"Error on adding Connections Data into tree\");\n            }\n        });\n    }\n}\n_a = AccessTracker;\nAccessTracker.conceptsData = {};\nAccessTracker.connectionsData = {};\nAccessTracker.TimeToSync = 300000;\nAccessTracker.nextSyncTime = Date.now();\n(() => {\n    // console.log(`[INIT] Next Sync Time set to: ${new Date(this.nextSyncTime).toLocaleString()}`);\n    _a.startAutoSync();\n})();\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DATA_TYPES_RULES } from \"../Validator/constant\";\n/**\n * Class representing the Anomaly detection logic for checking data validity based on predefined rules.\n * This class contains methods for initializing, caching, and fetching anomaly parameters from an external API,\n * as well as checking for anomalies in individual concepts and bulk data.\n */\nexport class Anomaly {\n    /**\n     * Constructor that initializes anomaly parameters if the cache is not yet initialized.\n     * It ensures that the anomaly parameters are loaded and cached for use.\n     */\n    constructor() {\n        if (!Anomaly.cacheInitialized) {\n            Anomaly.initializeAnomalyParameters();\n        }\n    }\n    /**\n     * Initializes the anomaly parameters by fetching them from the API.\n     * This method is only run once on startup to ensure the cache is ready for use.\n     * It will fetch the parameters from the API and store them in a static cache.\n     *\n     * @returns {Promise<void>} - A promise that resolves once the parameters have been initialized.\n     */\n    static initializeAnomalyParameters() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Fetch anomaly parameters once on startup\n                const anomalyData = yield Anomaly.getAnomalyParameters();\n                // console.log('Anomaly parameters initialized:', anomalyData);\n                // Refresh the cache to ensure it's up-to-date\n                Anomaly.refreshCache();\n                Anomaly.cacheInitialized = true;\n            }\n            catch (error) {\n                console.error('Error during anomaly parameter initialization:', error);\n            }\n        });\n    }\n    /**\n     * Fetches the anomaly parameters.\n     * It first checks if the parameters are cached and whether the cache is still valid (not expired).\n     * If the cache is valid, it returns the cached data. If not, it fetches the data from the API.\n     *\n     * @returns {Promise<any>} - A promise that resolves to the anomaly parameters.\n     */\n    static getAnomalyParameters() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentTime = Date.now();\n            if (Anomaly.anomalyParamsCache && (currentTime - Anomaly.lastFetchedTime < Anomaly.cacheExpiryThreshold)) {\n                console.log('Returning cached anomaly parameters');\n                return Anomaly.anomalyParamsCache;\n            }\n            try {\n                // If data is not cached or expired, fetch it from the API\n                const data = yield Anomaly.fetchAnomalyParameters();\n                return data;\n            }\n            catch (error) {\n                console.error('Error fetching anomaly parameters:', error);\n                throw error;\n            }\n        });\n    }\n    /**\n     * Fetches anomaly parameters directly from the backend API.\n     * This method is used internally by `getAnomalyParameters` to retrieve fresh data.\n     *\n     * @returns {Promise<any>} - A promise that resolves to the fetched anomaly parameters.\n     */\n    static fetchAnomalyParameters() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Fetching anomaly parameters from the API...'\n            const url = `https://devai.freeschema.com/v1/get-frontend-anomaly-parameters`;\n            try {\n                const response = yield fetch(url, {\n                    method: 'GET',\n                    headers: { 'Content-Type': 'application/json' },\n                });\n                if (!response.ok) {\n                    throw new Error(\"Failed to fetch anomaly parameters\");\n                }\n                const data = yield response.json();\n                // Cache the fetched data and update the timestamp\n                Anomaly.anomalyParamsCache = data.data;\n                Anomaly.lastFetchedTime = Date.now();\n                return data.data;\n            }\n            catch (error) {\n                console.error(\"API Fetch Error:\", error);\n                throw error;\n            }\n        });\n    }\n    /**\n     * Refreshes the anomaly parameters cache if the cache has expired.\n     * If the cache expiry threshold has been surpassed, the method re-fetches the data from the API.\n     *\n     * @returns {Promise<void>} - A promise that resolves when the cache has been refreshed.\n     */\n    static refreshCache() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const currentTime = Date.now();\n                if (currentTime - Anomaly.lastFetchedTime > Anomaly.cacheExpiryThreshold) {\n                    // Cache expired, re-fetch the data\n                    yield Anomaly.getAnomalyParameters();\n                }\n            }\n            catch (error) {\n                console.error(\"Error refreshing anomaly parameters cache:\", error);\n            }\n        });\n    }\n    /**\n     * Detects the data type of a given value based on predefined rules.\n     * It checks the value against the `DATA_TYPES_RULES` to find the matching data type.\n     *\n     * @param {string} value - The value to check.\n     * @returns {string | null} - The detected data type, or `null` if no match is found.\n     */\n    detectDataType(value) {\n        for (const [dataType, regex] of Object.entries(DATA_TYPES_RULES)) {\n            if (regex.test(value)) {\n                return dataType;\n            }\n        }\n        return null;\n    }\n    /**\n     * Checks whether a given concept and value pair contains an anomaly.\n     * An anomaly is detected based on the concept's length and type rules.\n     *\n     * @param {string} typeConcept - The concept type (e.g., `the_name`).\n     * @param {string} value - The value to check for anomalies.\n     * @returns {Promise<{ valid: boolean, warnings: string[] }>} - A promise that resolves to an object containing:\n     * - `valid`: A boolean indicating whether the value is valid according to the anomaly rules.\n     * - `warnings`: An array of warning messages related to the value's anomalies.\n     */\n    checkConceptAnomaly(typeConcept, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const warnings = [];\n            try {\n                if (!value) {\n                    warnings.push(\"Null value\");\n                    return { valid: false, warnings };\n                }\n                const typeDetails = Anomaly.anomalyParamsCache;\n                if (!typeConcept.startsWith('the_')) {\n                    typeConcept = `the_${typeConcept}`;\n                }\n                const conceptDetails = typeDetails[typeConcept];\n                console.log(\"Concept Details : \", conceptDetails);\n                if (!conceptDetails) {\n                    console.warn(`No concept details found for type: ${typeConcept}`);\n                    warnings.push(`No concept details found for type: ${typeConcept}`);\n                    return { valid: false, warnings };\n                }\n                const length = value.length;\n                const { min_length, max_length, data_types } = conceptDetails;\n                const lengthValid = length >= min_length && length <= max_length;\n                const detectedType = this.detectDataType(value);\n                const typeValid = data_types.includes(detectedType);\n                if (!lengthValid) {\n                    warnings.push(`Length of '${value}' is outside the allowed range (min: ${min_length}, max: ${max_length}). Current length: ${length}.`);\n                }\n                if (!typeValid) {\n                    warnings.push(`Type mismatch for '${value}'. Expected types: ${data_types.join(', ')}, detected type: ${detectedType}.`);\n                }\n                if (lengthValid && typeValid) {\n                    warnings.push(`Concept ${typeConcept} is valid. Length: ${length}, Type: ${detectedType}`);\n                }\n                return { valid: lengthValid && typeValid, warnings };\n            }\n            catch (error) {\n                console.error(`Error checking anomaly for ${typeConcept} with value ${value}:`, error);\n                return { valid: false, warnings };\n            }\n        });\n    }\n    /**\n     * Checks anomalies for multiple concepts in bulk.\n     * Iterates over a record of concept-value pairs and detects anomalies.\n     *\n     * @param {Record<string, string>} instanceData - An object where each key is a concept type and each value is the corresponding data value.\n     * @returns {Promise<Record<string, { valid: boolean, warnings: string[] }>>} - A promise that resolves to an object where each key is a concept type\n     * and the value is an object containing `valid` (boolean) and `warnings` (array of warning messages).\n     */\n    static checkAnomalyInBulk(formData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!Anomaly.cacheInitialized) {\n                yield Anomaly.initializeAnomalyParameters();\n            }\n            try {\n                const anomalyResults = {};\n                for (const [typeConcept, instanceData] of Object.entries(formData)) {\n                    const instanceValue = instanceData.value;\n                    const { valid, warnings } = yield new Anomaly().checkConceptAnomaly(typeConcept, instanceValue);\n                    anomalyResults[typeConcept] = { valid, warnings };\n                }\n                return anomalyResults;\n            }\n            catch (error) {\n                console.error(\"Bulk Anomaly Check Error:\", error);\n                throw error;\n            }\n        });\n    }\n}\n/**\n * Static cache for storing fetched anomaly parameters.\n * @type {any} - Stores the fetched anomaly parameters from the API.\n */\nAnomaly.anomalyParamsCache = null;\n/**\n * Flag indicating if the anomaly parameters cache has been initialized.\n * @type {boolean} - `true` if the cache is initialized, `false` otherwise.\n */\nAnomaly.cacheInitialized = false;\n/**\n * Timestamp indicating the last time the anomaly parameters were fetched.\n * @type {number} - Time in milliseconds.\n */\nAnomaly.lastFetchedTime = 0;\n/**\n * Cache expiry threshold, after which the data will be considered expired.\n * @type {number} - Cache expiry threshold in milliseconds (default is 10 minutes).\n */\nAnomaly.cacheExpiryThreshold = 10 * 60 * 1000;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CharacterRepository } from \"../../DataStructures/CharacterRepository\";\nimport { Returner } from \"../../DataStructures/Returner\";\nimport { TheCharacter } from \"../../DataStructures/TheCharacter\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateTheCharacter(characterData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var characterData;\n        try {\n            characterData = CharacterRepository.GetCharacter(characterData.data);\n            if (characterData.id == 0) {\n                var header = GetRequestHeader();\n                const response = yield fetch(BaseUrl.CreateTheCharacterDataUrl(), {\n                    method: 'POST',\n                    headers: header,\n                    body: JSON.stringify(characterData),\n                });\n                if (!response.ok) {\n                    HandleHttpError(response);\n                    throw new Error(`Error! status: ${response.status}`);\n                }\n                const resultString = yield response.json();\n                const result = resultString;\n                var savingCharacter = new TheCharacter(result.userId, characterData.data, 0, 0, 4, 4, 999, 999, \"\", false);\n                savingCharacter.id = result.id;\n                CharacterRepository.AddCharacter(savingCharacter);\n                return result;\n            }\n            else {\n                var returningData = new Returner(characterData.id, characterData.userId, 0, false);\n                return returningData;\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('create the character error message: ', error.message);\n            }\n            else {\n                console.log('create the character unexpected error: ', error);\n            }\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { CreateDefaultConcept } from \"../../app\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateTheConceptApi(conceptData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = CreateDefaultConcept();\n        try {\n            var header = GetRequestHeader();\n            const response = yield fetch(BaseUrl.CreateTheConceptUrl(), {\n                method: 'POST',\n                headers: header,\n                body: JSON.stringify(conceptData),\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Error! status: ${response.status}`);\n            }\n            const resultString = yield response.json();\n            result = resultString;\n            return result;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Create the concept api error message: ', error.message);\n            }\n            else {\n                console.log('Create the concept api unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.CreateTheConceptUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Connection } from \"../../DataStructures/Connection\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateTheConnectionApi(connectionData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = new Connection(0, 0, 0, 0, 0, 0, 0);\n        try {\n            var header = GetRequestHeader();\n            var jsonData = JSON.stringify(connectionData);\n            const response = yield fetch(BaseUrl.CreateTheConnectionUrl(), {\n                method: 'POST',\n                headers: header,\n                body: jsonData\n            });\n            if (response.ok) {\n                const result = yield response.json();\n            }\n            else {\n                console.log('Create the connection error message: ', response.status);\n                HandleHttpError(response);\n            }\n            return result;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Create the connection error message: ', error.message);\n            }\n            else {\n                console.log(' Create the connection unexpected error: ', error);\n            }\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { TokenStorage } from \"../../DataStructures/Security/TokenStorage\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateTheGhostConceptApi(conceptData, connectionData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const CHUNK_SIZE = 1000;\n            let result = {\n                \"concepts\": [],\n                \"connections\": []\n            };\n            // strip data\n            const stripedConcept = yield stripTypeFromConceptOrConnection(conceptData);\n            const stripedConnection = yield stripTypeFromConceptOrConnection(connectionData);\n            // sync all in one request if data is less\n            if (conceptData.length + connectionData.length <= (CHUNK_SIZE * 2)) {\n                const response = yield syncConceptConnection(stripedConcept, stripedConnection);\n                if (Array.isArray(response === null || response === void 0 ? void 0 : response.concepts))\n                    result.concepts = [...result.concepts, ...response.concepts];\n                if (Array.isArray(response === null || response === void 0 ? void 0 : response.connections))\n                    result.connections = [...result.connections, ...response.connections];\n                return result;\n            }\n            // split data \n            const splittedConcepts = chunkArrayByItemCount(stripedConcept, CHUNK_SIZE);\n            const splittedConnections = chunkArrayByItemCount(stripedConnection, CHUNK_SIZE);\n            const syncConceptPromises = [];\n            const syncConnectionPromises = [];\n            // sync concept\n            for (let i = 0; i < splittedConcepts.length; i++) {\n                const concepts = splittedConcepts[i];\n                syncConceptPromises.push(syncConceptConnection(concepts, []));\n            }\n            const conceptResponses = yield Promise.all(syncConceptPromises);\n            for (let i = 0; i < conceptResponses.length; i++) {\n                const conceptsRes = conceptResponses[i];\n                if (Array.isArray(conceptsRes === null || conceptsRes === void 0 ? void 0 : conceptsRes.concepts))\n                    result.concepts = [...result.concepts, ...conceptsRes.concepts];\n                if (Array.isArray(conceptsRes === null || conceptsRes === void 0 ? void 0 : conceptsRes.connections))\n                    result.connections = [...result.connections, ...conceptsRes.connections];\n            }\n            // sync connection\n            for (let i = 0; i < splittedConnections.length; i++) {\n                const connections = splittedConnections[i];\n                syncConnectionPromises.push(syncConceptConnection([], connections));\n            }\n            const connectionResponses = yield Promise.all(syncConnectionPromises);\n            for (let i = 0; i < connectionResponses.length; i++) {\n                const connectionsRes = connectionResponses[i];\n                if (Array.isArray(connectionsRes === null || connectionsRes === void 0 ? void 0 : connectionsRes.concepts))\n                    result.concepts = [...result.concepts, ...connectionsRes.concepts];\n                if (Array.isArray(connectionsRes === null || connectionsRes === void 0 ? void 0 : connectionsRes.connections))\n                    result.connections = [...result.connections, ...connectionsRes.connections];\n            }\n            return result;\n        }\n        catch (error) {\n            console.log(error);\n            throw error;\n        }\n    });\n}\n/**\n *\n * @param concepts Concept[]\n * @param connections Connection[]\n * @returns Promise<{concepts: [], connections: []}>\n */\nconst syncConceptConnection = (concepts, connections) => __awaiter(void 0, void 0, void 0, function* () {\n    let result = {\n        \"concepts\": [],\n        \"connections\": []\n    };\n    try {\n        const myHeaders = new Headers();\n        let myBody = {\n            \"concepts\": concepts,\n            \"connections\": connections\n        };\n        myHeaders.set(\"Content-Type\", \"application/json\");\n        myHeaders.set('Authorization', \"Bearer \" + TokenStorage.BearerAccessToken);\n        myHeaders.set('Accept', 'application/json');\n        //  myHeaders.set('Randomizer', BaseUrl.BASE_RANDOMIZER.toString());\n        myHeaders.set('Randomizer', BaseUrl.getRandomizer().toString());\n        const response = yield fetch(BaseUrl.CreateGhostConceptApiUrl(), {\n            method: 'POST',\n            headers: myHeaders,\n            body: JSON.stringify(myBody),\n        });\n        if (!response.ok) {\n            HandleHttpError(response);\n            throw new Error(`Error! status: ${response.status}`);\n        }\n        const resultString = yield response.json();\n        result.concepts = resultString.concepts;\n        result.connections = resultString.connections;\n        return result;\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            console.log('Create the concept api error message: ', error.message);\n        }\n        else {\n            console.log('Create the concept api unexpected error: ', error);\n        }\n        throw error;\n    }\n});\n// Function to split an array into chunks of 1024 items (500KB per chunk)\nfunction chunkArrayByItemCount(array, itemsPerChunk) {\n    const chunks = [];\n    for (let i = 0; i < array.length; i += itemsPerChunk) {\n        const chunk = array.slice(i, i + itemsPerChunk); // Slice the array into smaller chunks\n        chunks.push(chunk);\n    }\n    return chunks;\n}\n// method to strip type object from concept or connection\nconst stripTypeFromConceptOrConnection = (...args_1) => __awaiter(void 0, [...args_1], void 0, function* (items = []) {\n    return yield Promise.all(items.map(item => {\n        let newItem = JSON.parse(JSON.stringify(item));\n        delete newItem.type;\n        delete newItem.ofConcept;\n        delete newItem.toConcept;\n        return newItem;\n    }));\n});\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateTextData(textData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            var header = GetRequestHeader();\n            const response = yield fetch(BaseUrl.CreateTheTextDataUrl(), {\n                method: 'POST',\n                headers: header,\n                body: JSON.stringify(textData),\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Error! status: ${response.status}`);\n            }\n            const resultString = yield response.json();\n            const result = resultString;\n            return result;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Create the text error message: ', error.message);\n            }\n            else {\n                console.log('Create the text unexpected error: ', error);\n            }\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { GetOnlyTokenHeader } from \"../Services/Security/GetRequestHeader\";\nexport default function DeleteTheConcept(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const formdata = new FormData();\n            formdata.append(\"id\", id.toString());\n            let header = GetOnlyTokenHeader();\n            const response = yield fetch(BaseUrl.DeleteConceptUrl(), {\n                method: 'POST',\n                headers: header,\n                body: formdata\n            });\n            if (!response.ok) {\n                // throw new Error(`Error! status: ${response.status}`);\n                console.log(\"Delete concept error\", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Delete concept error message: ', error.message);\n            }\n            else {\n                console.log('Delete concept unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.DeleteConceptUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { GetOnlyTokenHeader } from \"../Services/Security/GetRequestHeader\";\nexport default function DeleteTheConnection(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const formdata = new FormData();\n            formdata.append(\"id\", id.toString());\n            let header = GetOnlyTokenHeader();\n            const response = yield fetch(BaseUrl.DeleteTheConnectionUrl(), {\n                method: 'POST',\n                headers: header,\n                body: formdata,\n                redirect: \"follow\"\n            });\n            if (!response.ok) {\n                console.log('Delete connection error status: ', response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Delete connection error message: ', error.message);\n            }\n            else {\n                console.log('Delete connection unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.DeleteTheConnectionUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nexport function TrashTheConcept(id, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const myHeaders = new Headers();\n            myHeaders.append('Authorization', 'Bearer ' + token);\n            const formdata = new FormData();\n            formdata.append('id', id.toString());\n            const response = yield fetch(BaseUrl.DeleteConceptUrl(), {\n                method: 'POST',\n                body: formdata,\n                headers: myHeaders,\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Delete composition Error! status: ${response.status}`);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Delete composition error message: ', error.message);\n            }\n            else {\n                console.log('Delete composition unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.DeleteConceptUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DeleteConceptById } from \"../../app\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nexport function DeleteUserInBackend(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            var header = GetRequestHeaderWithAuthorization(\"application/json\", \"\");\n            let queryUrl = BaseUrl.DeleteUserUrl();\n            queryUrl = queryUrl + '?conceptId=' + id + '&apiKey=freeschema';\n            const response = yield fetch(queryUrl, {\n                method: 'POST',\n                headers: header,\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Delete composition Error! status: ${response.status}`);\n            }\n            else {\n                let returnData = yield response.json();\n                ;\n                let DeleteEmail = Number(returnData.data);\n                console.log(\"this is the delete email concept\", DeleteEmail);\n                DeleteConceptById(DeleteEmail);\n                return DeleteEmail;\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Delete composition error message: ', error.message);\n            }\n            else {\n                console.log('Delete composition unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.DeleteConceptUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from '../DataStructures/BaseUrl';\nimport { ConceptsData } from '../DataStructures/ConceptData';\nimport { HandleHttpError, HandleInternalError } from '../Services/Common/ErrorPosting';\nimport { PurgatoryDatabaseUpdated } from '../Services/InitializeSystem';\nimport { GetRequestHeaderWithAuthorization } from '../Services/Security/GetRequestHeader';\nexport function GetAiData() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const start = new Date().getTime();\n            var header = GetRequestHeaderWithAuthorization('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetAllAiData(), {\n                method: 'GET',\n                headers: header,\n            });\n            if (!response.ok) {\n                console.log('Ai Error Message: ', \"Cannot get response\");\n                HandleHttpError(response);\n            }\n            const result = yield response.json();\n            for (var i = 0; i < result.length; i++) {\n                ConceptsData.AddConcept(result[i]);\n            }\n            PurgatoryDatabaseUpdated();\n            let elapsed = new Date().getTime() - start;\n            console.log(\"The time taken is \", elapsed);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Ai Error Message: ', error.message);\n            }\n            else {\n                console.log('Ai Error Message: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllAiData());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetAllConceptsByType(type, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            var urlencoded = new URLSearchParams();\n            urlencoded.append(\"type\", type);\n            urlencoded.append(\"user_id\", userId.toString());\n            var header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetAllConceptsByTypeUrl(), {\n                method: 'POST',\n                headers: header,\n                body: urlencoded\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                for (var i = 0; i < result.length; i++) {\n                    ConceptsData.AddConcept(result[i]);\n                }\n            }\n            else {\n                console.log(\"GetAllConceptsByType error\", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('GetAllConceptsByType error message: ', error.message);\n            }\n            else {\n                console.log('GetAllConceptsByType unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllConceptsByTypeUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from '../DataStructures/ConnectionData';\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { CheckForConnectionDeletion } from '../Services/CheckForConnectionDeletion';\nimport { GetRequestHeader } from '../Services/Security/GetRequestHeader';\nimport { HandleHttpError, HandleInternalError } from '../Services/Common/ErrorPosting';\nexport function GetAllConnectionsOfComposition(composition_id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var connectionList = [];\n        //connectionList = await ConnectionData.GetConnectionsOfCompositionLocal(composition_id);\n        connectionList = yield ConnectionData.GetConnectionsOfConcept(composition_id);\n        if (connectionList.length == 0) {\n            var connectionListString = yield GetAllConnectionsOfCompositionOnline(composition_id);\n            connectionList = connectionListString;\n        }\n        else {\n            var newConnectionsString = yield GetAllConnectionsOfCompositionOnline(composition_id);\n            var newConnections = newConnectionsString;\n            CheckForConnectionDeletion(newConnections, connectionList);\n            connectionList = newConnections;\n        }\n        return connectionList;\n    });\n}\nexport function GetAllConnectionsOfCompositionOnline(composition_id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var connectionList = [];\n        try {\n            var header = GetRequestHeader('application/json');\n            const myHeaders = new Headers();\n            const formdata = new FormData();\n            formdata.append(\"composition_id\", composition_id.toString());\n            const response = yield fetch(BaseUrl.GetAllConnectionsOfCompositionUrl(), {\n                method: 'POST',\n                headers: myHeaders,\n                body: formdata\n            });\n            console.log(\"this is getting connection from online\", BaseUrl.GetAllConnectionsOfCompositionUrl(), composition_id);\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Error! status: ${response.status}`);\n            }\n            const result = yield response.json();\n            for (var i = 0; i < result.length; i++) {\n                ConnectionData.AddConnection(result[i]);\n                connectionList.push(result[i]);\n            }\n            return connectionList;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get all connection of composition error : ', error.message);\n            }\n            else {\n                console.log('Get all connection of composition error : ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllConnectionsOfCompositionUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from '../DataStructures/ConnectionData';\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { FindConceptsFromConnections } from '../Services/FindConeceptsFromConnection';\nimport { FindConnectionsOfCompositionsBulkInMemory } from '../Services/FindConnectionsOfCompositionBulkInMemory';\nimport { CheckForConnectionDeletion } from '../Services/CheckForConnectionDeletion';\nimport { GetRequestHeader } from '../Services/Security/GetRequestHeader';\nimport { HandleHttpError, HandleInternalError } from '../Services/Common/ErrorPosting';\nimport { sendMessage, serviceWorker } from '../app';\nexport function GetAllConnectionsOfCompositionBulk() {\n    return __awaiter(this, arguments, void 0, function* (composition_ids = []) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetAllConnectionsOfCompositionBulk', { composition_ids });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        var connectionList = [];\n        var conceptList = [];\n        if (composition_ids.length <= 0) {\n            return connectionList;\n        }\n        var oldConnectionList = yield FindConnectionsOfCompositionsBulkInMemory(composition_ids);\n        var connectionListString = yield GetAllConnectionsOfCompositionOnline(composition_ids);\n        connectionList = connectionListString;\n        CheckForConnectionDeletion(connectionList, oldConnectionList);\n        yield FindConceptsFromConnections(connectionList);\n        return connectionList;\n    });\n}\nexport function GetAllConnectionsOfCompositionOnline() {\n    return __awaiter(this, arguments, void 0, function* (composition_ids = []) {\n        var connectionList = [];\n        try {\n            var header = GetRequestHeader();\n            const response = yield fetch(BaseUrl.GetAllConnectionsOfCompositionBulkUrl(), {\n                method: 'POST',\n                headers: header,\n                body: JSON.stringify(composition_ids)\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                for (var i = 0; i < result.length; i++) {\n                    ConnectionData.AddConnection(result[i]);\n                    connectionList.push(result[i]);\n                }\n            }\n            else {\n                console.log('Get all connections of composition bulk error message: ', \"Cannot get response\");\n                HandleHttpError(response);\n            }\n            return connectionList;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get all connections of composition bulk error message: ', error.message);\n            }\n            else {\n                console.log('Get all connections of composition bulk unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllConnectionsOfCompositionBulkUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { BaseUrl } from \"../app\";\nexport function GetAllLinkerConnectionsFromTheConcept(conceptId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var connections = [];\n        try {\n            const start = new Date().getTime();\n            var header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetAllLinkerConnectionOfConceptUrl() + `?conceptId=${conceptId}`, {\n                method: 'GET',\n                headers: header,\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                for (var i = 0; i < result.length; i++) {\n                    var connection = result[i];\n                    connections.push(connection);\n                }\n            }\n            else {\n                console.log(\"Get all linker connection from the concepts error\", \"cannot get respone\");\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get all linker connection from the concepts error: ', error.message);\n            }\n            else {\n                console.log('Get all linker connection from the concepts error(Unexpected): ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllLinkerConnectionOfConceptUrl());\n        }\n        return connections;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { BaseUrl } from \"../app\";\nexport function GetAllLinkerConnectionsToTheConcept(conceptId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var connections = [];\n        try {\n            const start = new Date().getTime();\n            var header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetAllLinkerConnectionToConceptUrl() + `?conceptId=${conceptId}`, {\n                method: 'GET',\n                headers: header,\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                for (var i = 0; i < result.length; i++) {\n                    var connection = result[i];\n                    connections.push(connection);\n                }\n            }\n            else {\n                console.log(\"Get all linker connection To the concepts error\", \"cannot get respone\");\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get all linker connection To the concepts error: ', error.message);\n            }\n            else {\n                console.log('Get all linker connection To the concepts error(Unexpected): ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllLinkerConnectionToConceptUrl());\n        }\n        return connections;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { sendMessage, serviceWorker } from \"../app\";\nexport function GetCompositionConnectionsBetweenTwoConcepts(ofConceptId, toConcept, mainKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionConnectionsBetweenTwoConcepts', { ofConceptId, toConcept, mainKey });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        var connectionList = [];\n        try {\n            var formdata = new FormData();\n            formdata.append(\"ofConceptId\", ofConceptId.toString());\n            formdata.append(\"mainKey\", mainKey.toString());\n            formdata.append(\"toConceptId\", toConcept.toString());\n            const response = yield fetch(BaseUrl.GetCompositionConnectionBetweenTwoConceptsUrl(), {\n                method: 'POST',\n                body: formdata,\n                redirect: \"follow\"\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                for (var i = 0; i < result.length; i++) {\n                    ConnectionData.AddConnection(result[i]);\n                    connectionList.push(result[i]);\n                }\n            }\n            else {\n                console.log(\"Get composition connection between two concepts\", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get composition connection between two concepts error message: ', error.message);\n            }\n            else {\n                console.log('Get composition connection between two concepts unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetCompositionConnectionBetweenTwoConceptsUrl());\n        }\n        return connectionList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { CreateDefaultConcept, sendMessage, serviceWorker } from \"../app\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\n/**\n * This function helps you get concept from the id. This can only be positive.\n * @param id The id that you want to get the concept of\n * @returns\n */\nexport function GetConcept(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            if (serviceWorker) {\n                const res = yield sendMessage('GetConcept', { id });\n                // console.log('data received from sw', res)\n                return res.data;\n            }\n            let result = CreateDefaultConcept();\n            var conceptUse = yield ConceptsData.GetConcept(id);\n            let isNpc = ConceptsData.GetNpc(id);\n            if (conceptUse.id != 0 || isNpc) {\n                return conceptUse;\n            }\n            else {\n                var header = GetRequestHeader();\n                console.log(\"this is the url\", BaseUrl.GetConceptUrl());\n                const formdata = new FormData();\n                formdata.append(\"id\", id.toString());\n                const response = yield fetch(BaseUrl.GetConceptUrl(), {\n                    method: 'POST',\n                    body: formdata\n                });\n                if (response.ok) {\n                    result = (yield response.json());\n                    if (result.id > 0) {\n                        ConceptsData.AddConcept(result);\n                    }\n                    else {\n                        ConceptsData.AddNpc(id);\n                    }\n                }\n                else {\n                    console.log(\"Get the concept error\", response.status);\n                    HandleHttpError(response);\n                }\n                return result;\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get the concept error message: ', error.message);\n            }\n            else {\n                console.log('Get the concept unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConceptUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { Logger } from \"../app\";\nimport { sendMessage, serviceWorker } from \"../app\";\n/**\n * This function takes in a list of ids and returns a list of concepts . This uses local memory to find concepts\n * namely in the concept binary tree. If it could not find the concepts in local memory then it fetches those from\n * the api. The fetched concepts from api are then stored in the memory for further use in future.\n * @param conceptIds list of concept ids that need to be fetched\n * @returns list of concepts\n */\nexport function GetConceptBulk(passedConcepts) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetConceptBulk', { passedConcepts });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let result = [];\n        let setTime = new Date().getTime();\n        let startTime = performance.now();\n        // let conceptIds = passedConcepts.filter((value, index, self) => {\n        //   return self.indexOf(value) === index;\n        // });\n        let conceptIds = Array.from(new Set(passedConcepts));\n        try {\n            if (conceptIds.length > 0) {\n                let bulkConceptFetch = [];\n                for (let i = 0; i < conceptIds.length; i++) {\n                    let conceptUse = yield ConceptsData.GetConcept(conceptIds[i]);\n                    if (conceptUse.id == 0) {\n                        bulkConceptFetch.push(conceptIds[i]);\n                    }\n                }\n                // let newAlgoTime = new Date().getTime();\n                //let remainingIds:any = {};\n                // for(let i=0; i< conceptIds.length; i++){\n                //     remainingIds[conceptIds[i]] = false;\n                // }\n                //await ConceptsData.GetConceptBulkData(conceptIds, result, remainingIds );\n                // for(let key in remainingIds){\n                //     if(remainingIds[key] == false){\n                //       bulkConceptFetch.push(Number(key));\n                //     }\n                // }\n                //bulkConceptFetch = conceptIds;\n                if (bulkConceptFetch.length == 0) {\n                    return result;\n                }\n                else {\n                    let header = GetRequestHeader();\n                    const response = yield fetch(BaseUrl.GetConceptBulkUrl(), {\n                        method: 'POST',\n                        headers: header,\n                        body: JSON.stringify(bulkConceptFetch)\n                    });\n                    if (response.ok) {\n                        result = yield response.json();\n                        if (result.length > 0) {\n                            for (let i = 0; i < result.length; i++) {\n                                let concept = result[i];\n                                ConceptsData.AddConcept(concept);\n                            }\n                        }\n                        console.log(\"added the concepts\");\n                        // Add Log\n                        Logger.logInfo(startTime, \"unknown\", \"read\", \"unknown\", undefined, 200, result, \"GetConceptBulk\", ['passedConcepts'], \"unknown\", undefined);\n                    }\n                    else {\n                        console.log(\"Get Concept Bulk error\", response.status);\n                        // Add Log\n                        Logger.logInfo(startTime, \"unknown\", \"read\", \"unknown\", undefined, response.status, response, \"GetConceptBulk\", ['passedConcepts'], \"unknown\", undefined);\n                        HandleHttpError(response);\n                    }\n                }\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get Concept Bulk  error message: ', error.message);\n            }\n            else {\n                console.log('Get Concept Bulk  unexpected error: ', error);\n            }\n            // Add Log\n            Logger.logInfo(startTime, \"unknown\", \"read\", \"unknown\", undefined, 500, error, \"GetConceptBulk\", ['passedConcepts'], \"unknown\", undefined);\n            HandleInternalError(error, BaseUrl.GetConceptBulkUrl());\n        }\n        return result;\n    });\n}\nexport function BulkConceptGetterApi(bulkConceptFetch) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const conceptList = [];\n        if (bulkConceptFetch.length > 0) {\n            const myHeaders = {\n                'Content-Type': 'application/json',\n            };\n            try {\n                const response = yield fetch(BaseUrl.GetConceptBulkUrl(), {\n                    method: 'POST',\n                    headers: myHeaders,\n                    body: JSON.stringify(bulkConceptFetch),\n                });\n                if (response.ok) {\n                    const result = yield response.json();\n                    if (result.length > 0) {\n                        for (let i = 0; i < result.length; i++) {\n                            const concept = result[i];\n                            conceptList.push(concept);\n                            ConceptsData.AddConcept(concept);\n                        }\n                    }\n                }\n                else {\n                    console.log('bulk concept getter api error: ', response.status);\n                    HandleHttpError(response);\n                }\n            }\n            catch (error) {\n                if (error instanceof Error) {\n                    console.log('bulk concept getter api error: ', error.message);\n                }\n                else {\n                    console.log('bulk concept getter api error: ', error);\n                }\n                HandleInternalError(error, BaseUrl.GetConceptBulkUrl());\n            }\n        }\n        return conceptList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { sendMessage, serviceWorker } from \"../app\";\nexport function GetConceptByCharacterAndType(characterValue, typeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            if (serviceWorker) {\n                const res = yield sendMessage('GetConceptByCharacterAndType', { characterValue, typeId });\n                // console.log('data received from sw', res)\n                return res.data;\n            }\n            let concept = yield ConceptsData.GetConceptByCharacterAndTypeLocal(characterValue, typeId);\n            if (concept == null || concept.id == 0) {\n                var json = {\n                    'character_value': `${characterValue}`,\n                    'type_id': typeId\n                };\n                var toSendJson = JSON.stringify(json);\n                var header = GetRequestHeader();\n                const response = yield fetch(BaseUrl.GetConceptByCharacterAndTypeUrl(), {\n                    method: 'POST',\n                    headers: header,\n                    body: toSendJson,\n                });\n                if (response.ok) {\n                    let conceptString = yield response.json();\n                    concept = conceptString;\n                    ConceptsData.AddConcept(concept);\n                }\n                else {\n                    //  throw new Error(`Error! status: ${response.status}`);\n                    HandleHttpError(response);\n                    console.log(\"This is the concept by type and character error\", response.status);\n                }\n            }\n            return concept;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log(' This is the concept by type and character error message: ', error.message);\n            }\n            else {\n                console.log(' This is the concept by type and character unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConceptByCharacterAndTypeUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { CreateDefaultConcept } from \"../app\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetConceptByCharacterValue(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = CreateDefaultConcept();\n        try {\n            const formdata = new FormData();\n            formdata.append(\"character_value\", characterValue);\n            const response = yield fetch(BaseUrl.GetConceptByCharacterValueUrl(), {\n                method: 'POST',\n                body: formdata\n            });\n            if (response.ok) {\n                result = (yield response.json());\n                if (result.id > 0) {\n                    ConceptsData.AddConcept(result);\n                }\n            }\n            else {\n                HandleHttpError(response);\n                console.log(\"Error in Getting concept by character value Error\", response.status);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Error in Getting concept by character value error message: ', error);\n            }\n            else {\n                console.log('Error in Getting concept by character value unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConceptByCharacterValueUrl());\n        }\n        return result;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetConnection(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = yield ConnectionData.GetConnection(id);\n        try {\n            if (result.id != 0) {\n                return result;\n            }\n            else {\n                let header = GetRequestHeader('application/x-www-form-urlencoded');\n                const formdata = new FormData();\n                formdata.append(\"id\", id.toString());\n                const response = yield fetch(BaseUrl.GetConnectionUrl(), {\n                    method: 'POST',\n                    headers: header,\n                    body: formdata\n                });\n                if (response.ok) {\n                    result = (yield response.json());\n                    ConnectionData.AddConnection(result);\n                }\n                else {\n                    HandleHttpError(response);\n                    console.log(\"Get Connection Error\", response.status);\n                }\n                return result;\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get Connection error message: ', error.message);\n            }\n            else {\n                console.log('Get Connection unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConnectionUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from \"./../DataStructures/ConnectionData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { FindConceptsFromConnections } from \"../Services/FindConeceptsFromConnection\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { sendMessage, serviceWorker } from \"../app\";\n/**\n * After fetching these connections it is saved in the local static ConnectionBinaryTree so it can be reused without being fetched\n * @param connectionIds array of connection ids that need to fetched by the local system\n * @returns the list of  connections that have been fetched\n */\nexport function GetConnectionBulk() {\n    return __awaiter(this, arguments, void 0, function* (connectionIds = []) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetConnectionBulk', { connectionIds });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let connectionList = [];\n        try {\n            if (connectionIds.length > 0) {\n                let bulkConnectionFetch = [];\n                // if the connections are already present in the local memory then take it from there \n                //else put it in a list called bulkConnectionFetch which will be used to call and api.\n                for (let i = 0; i < connectionIds.length; i++) {\n                    let conceptUse = yield ConnectionData.GetConnection(connectionIds[i]);\n                    if (conceptUse.id == 0) {\n                        bulkConnectionFetch.push(connectionIds[i]);\n                    }\n                    else {\n                        connectionList.push(conceptUse);\n                    }\n                }\n                // let remainingIds:any = {};\n                // await ConnectionData.GetConnectionBulkData(connectionIds, connectionList, remainingIds );\n                //bulkConnectionFetch = connectionIds;\n                // if the case that bulkConnectionFetch does not have any elements then we just return everything we have\n                if (bulkConnectionFetch.length == 0) {\n                    return connectionList;\n                }\n                else {\n                    // if the connection could not be found in the local memory then fetch from the api.\n                    let header = GetRequestHeader();\n                    const response = yield fetch(BaseUrl.GetConnectionBulkUrl(), {\n                        method: 'POST',\n                        headers: header,\n                        body: JSON.stringify(bulkConnectionFetch)\n                    });\n                    if (response.ok) {\n                        const result = yield response.json();\n                        if (result.length > 0) {\n                            for (let i = 0; i < result.length; i++) {\n                                let connection = result[i];\n                                connectionList.push(connection);\n                                ConnectionData.AddConnection(connection);\n                            }\n                        }\n                    }\n                    else {\n                        HandleHttpError(response);\n                        console.log(\"Get Connection Bulk error\", response.status);\n                    }\n                }\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get Connection Bulk error message: ', error);\n            }\n            else {\n                console.log('Get Connection Bulk unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConnectionBulkUrl());\n        }\n        yield FindConceptsFromConnections(connectionList);\n        return connectionList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { sendMessage, serviceWorker } from \"../app\";\nexport function GetConnectionOfTheConcept(typeId_1, ofTheConceptId_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (typeId, ofTheConceptId, userId, inpage = 10, page = 1) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetConnectionOfTheConcept', { typeId, ofTheConceptId, userId, inpage, page });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let connectionList = [];\n        try {\n            let urlencoded = new URLSearchParams();\n            urlencoded.append(\"typeId\", `${typeId}`);\n            urlencoded.append(\"ofTheConceptId\", `${ofTheConceptId}`);\n            urlencoded.append(\"userId\", `${userId}`);\n            urlencoded.append(\"inpage\", `${inpage}`);\n            urlencoded.append(\"page\", `${page}`);\n            let header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetAllConnectionsOfConceptUrl(), {\n                method: 'POST',\n                headers: header,\n                body: urlencoded\n            });\n            if (response.ok) {\n                connectionList = (yield response.json());\n            }\n            else {\n                HandleHttpError(response);\n                console.log(\"Get connection of concept error\", response.status);\n            }\n            return connectionList;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Get connection of concept  error message: ', error.message);\n            }\n            else {\n                console.log('Get connection of concept unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetAllConnectionsOfConceptUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ReservedConnectionIds } from \"../DataStructures/ReservedIds\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetReservedConnectionIds() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetReservedConnectionIdUrl(), {\n                method: 'GET',\n                headers: header,\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Error! status: ${response.status}`);\n            }\n            const result = yield response.json();\n            for (let i = 0; i < result.length; i++) {\n                ReservedConnectionIds.AddId(result[i]);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('get reserved connection ids error message: ', error.message);\n            }\n            else {\n                console.log('get reserved connection ids  unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetReservedConnectionIdUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ReservedIds } from \"../DataStructures/ReservedIds\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function GetReservedIds() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetReservedIdUrl(), {\n                method: 'GET',\n                headers: header,\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n                throw new Error(`Error! status: ${response.status}`);\n            }\n            const result = yield response.json();\n            for (let i = 0; i < result.length; i++) {\n                ReservedIds.AddId(result[i]);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('get reserved ids error message: ', error.message);\n            }\n            else {\n                console.log('get reserved ids  unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetReservedIdUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LocalConceptsData } from \"./../../DataStructures/Local/LocalConceptData\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { CreateDefaultLConcept } from \"../../app\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nexport function GetLocalConceptByCharacterValue(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = CreateDefaultLConcept();\n        try {\n            var header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetConceptByCharacterValueUrl(), {\n                method: 'POST',\n                headers: header,\n                body: `character_value=${characterValue}`\n            });\n            if (response.ok) {\n                result = (yield response.json());\n                if (result.id > 0) {\n                    LocalConceptsData.AddConcept(result);\n                }\n            }\n            else {\n                console.log(\"Error in Getting Local concept by character value Error\", response.status);\n                HandleHttpError(response);\n            }\n            return result;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Error in Getting Local concept by character value error message: ', error);\n            }\n            else {\n                console.log('Error in Getting Local concept by character value unexpected error: ', error);\n            }\n            throw result;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { TokenStorage } from '../DataStructures/Security/TokenStorage';\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nexport function LoginToBackend(email, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let object = {\n                'email': email,\n                'password': password\n            };\n            let myHeaders = new Headers();\n            myHeaders.append(\"Content-Type\", \"application/json\");\n            let requestObject = JSON.stringify(object);\n            const response = yield fetch(BaseUrl.LoginUrl(), {\n                method: 'POST',\n                headers: myHeaders,\n                body: requestObject\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                TokenStorage.BearerAccessToken = result.data.token;\n                return result;\n            }\n            else {\n                console.log('Login tsccs error message: ', response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Login tsccs error message: ', error.message);\n            }\n            else {\n                console.log(' Login tsccs  unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.LoginUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nexport function MakeTheNameInBackend(newConceptId, referent, typeId, typeUserId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let object = {\n                'newConceptId': newConceptId,\n                'referent': referent,\n                'typeId': typeId,\n                'typeUserId': typeUserId\n            };\n            let myHeaders = GetRequestHeader();\n            let requestObject = JSON.stringify(object);\n            const response = yield fetch(BaseUrl.MakeTheNameInBackendUrl(), {\n                method: 'POST',\n                headers: myHeaders,\n                body: requestObject\n            });\n            if (!response.ok) {\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('make the name in backend error message: ', error.message);\n            }\n            else {\n                console.log('make the name in backend unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.MakeTheNameInBackendUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { CreateDefaultConcept } from \"../Services/CreateDefaultConcept\";\nimport { GetConceptByCharacterAndCategory } from \"../Services/ConceptFinding/GetConceptByCharacterAndCategory\";\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\n/**\n *  This function is used to check the type concpet of a passed string\n *  if the text is \"the_person\" then the function finds the related concept\n * @param type This is the type of the concept that needs to be created.\n * @param userId This is the userId of the creator.\n * @returns the concept created.\n */\nexport function MakeTheTypeConceptApi(type, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // create  a default concept with all defaulting to zero\n        let concept = CreateDefaultConcept();\n        try {\n            // get the concept by character and category from the api\n            concept = yield GetConceptByCharacterAndCategory(type);\n            if (concept.id == 0 || concept.typeId == 4) {\n                let header = GetRequestHeader('application/x-www-form-urlencoded');\n                const response = yield fetch(BaseUrl.MakeTheTypeConceptUrl(), {\n                    method: 'POST',\n                    headers: header,\n                    body: `type=${type}`\n                });\n                if (!response.ok) {\n                    HandleHttpError(response);\n                    throw new Error(`Error! status: ${response.status}`);\n                }\n                let result = yield response.json();\n                concept = result;\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Make The Type Concept Api error : ', error.message);\n            }\n            else {\n                console.log('Make The Type Concept Api error : ', error);\n            }\n            HandleInternalError(error, BaseUrl.MakeTheTypeConceptUrl());\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\nimport { SearchQuery } from \"../DataStructures/SearchQuery\";\nimport { GetCompositionFromConnectionsWithDataId, GetCompositionFromConnectionsWithDataIdFromConnections } from \"../Services/GetCompositionBulk\";\nimport { GetRequestHeader } from \"../Services/Security/GetRequestHeader\";\nimport { HandleHttpError, HandleInternalError, } from \"../Services/Common/ErrorPosting\";\nimport { sendMessage, serviceWorker } from \"../app\";\nexport function RecursiveSearchApi() {\n    return __awaiter(this, arguments, void 0, function* (composition = 0, listLinkers = [], textSearch = \"\") {\n        if (serviceWorker) {\n            const res = yield sendMessage(\"RecursiveSearchApi\", {\n                composition,\n                listLinkers,\n                textSearch,\n            });\n            // console.log(\"data received from sw\", res);\n            return res.data;\n        }\n        let concepts = [];\n        try {\n            let searchQuery = new SearchQuery();\n            searchQuery.composition = composition;\n            searchQuery.listLinkers = listLinkers;\n            searchQuery.textSearch = textSearch;\n            let raw = JSON.stringify(searchQuery);\n            let Connections = [];\n            let myHeaders = GetRequestHeader();\n            const response = yield fetch(BaseUrl.RecursiveSearchUrl(), {\n                method: \"POST\",\n                headers: myHeaders,\n                body: raw,\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                let conceptIds = result.compositionIds;\n                let connections = result.internalConnections;\n                let externalConnections = result.externalConnections;\n                concepts = yield GetCompositionFromConnectionsWithDataId(conceptIds, connections);\n            }\n            else {\n                console.log(\"recursive search error \", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log(\"recursive search error message: \", error.message);\n            }\n            else {\n                console.log(\"recursive search unexpected error: \", error);\n            }\n            HandleInternalError(error, BaseUrl.RecursiveSearchUrl());\n        }\n        return concepts;\n    });\n}\nexport function RecursiveSearchApiWithInternalConnections() {\n    return __awaiter(this, arguments, void 0, function* (composition = 0, listLinkers = [], textSearch = \"\") {\n        if (serviceWorker) {\n            const res = yield sendMessage(\"RecursiveSearchApiWithInternalConnections\", {\n                composition,\n                listLinkers,\n                textSearch,\n            });\n            // console.log(\"data received from sw\", res);\n            return res.data;\n        }\n        let concepts = [];\n        try {\n            let searchQuery = new SearchQuery();\n            searchQuery.composition = composition;\n            searchQuery.listLinkers = listLinkers;\n            searchQuery.textSearch = textSearch;\n            let raw = JSON.stringify(searchQuery);\n            let Connections = [];\n            let myHeaders = GetRequestHeader();\n            const response = yield fetch(BaseUrl.RecursiveSearchUrl(), {\n                method: \"POST\",\n                headers: myHeaders,\n                body: raw,\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                let conceptIds = result.compositionIds;\n                let connections = result.internalConnections;\n                let externalConnections = result.externalConnections;\n                concepts = yield GetCompositionFromConnectionsWithDataIdFromConnections(conceptIds, connections);\n            }\n            else {\n                console.log(\"recursive search error \", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log(\"recursive search error message: \", error.message);\n            }\n            else {\n                console.log(\"recursive search unexpected error: \", error);\n            }\n            HandleInternalError(error, BaseUrl.RecursiveSearchUrl());\n        }\n        return concepts;\n    });\n}\nexport function RecursiveSearchApiRaw() {\n    return __awaiter(this, arguments, void 0, function* (composition = 0, listLinkers = [], textSearch = \"\") {\n        if (serviceWorker) {\n            const res = yield sendMessage(\"RecursiveSearchApiRaw\", {\n                composition,\n                listLinkers,\n                textSearch,\n            });\n            // console.log(\"data received from sw\", res);\n            return res.data;\n        }\n        let concepts = [];\n        try {\n            let searchQuery = new SearchQuery();\n            searchQuery.composition = composition;\n            searchQuery.listLinkers = listLinkers;\n            searchQuery.textSearch = textSearch;\n            let raw = JSON.stringify(searchQuery);\n            let Connections = [];\n            let myHeaders = GetRequestHeader();\n            const response = yield fetch(BaseUrl.RecursiveSearchUrl(), {\n                method: \"POST\",\n                headers: myHeaders,\n                body: raw,\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                let conceptIds = result.compositionIds;\n                let connections = result.internalConnections;\n                let externalConnections = result.externalConnections;\n                return result;\n            }\n            else {\n                console.log(\"recursive search error \", response.status);\n                HandleHttpError(response);\n            }\n            return [];\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log(\"recursive search error message: \", error.message);\n            }\n            else {\n                console.log(\"recursive search unexpected error: \", error);\n            }\n            HandleInternalError(error, BaseUrl.RecursiveSearchUrl());\n        }\n    });\n}\nexport function RecursiveSearchApiRawFullLinker() {\n    return __awaiter(this, arguments, void 0, function* (composition = 0, fullLinkers = [], textSearch = \"\") {\n        if (serviceWorker) {\n            const res = yield sendMessage(\"RecursiveSearchApiRawFullLinker\", {\n                composition,\n                fullLinkers,\n                textSearch,\n            });\n            // console.log(\"data received from sw\", res);\n            return res.data;\n        }\n        let concepts = [];\n        try {\n            let searchQuery = new SearchQuery();\n            searchQuery.composition = composition;\n            searchQuery.fullLinkers = fullLinkers;\n            searchQuery.textSearch = textSearch;\n            let raw = JSON.stringify(searchQuery);\n            let Connections = [];\n            let myHeaders = GetRequestHeader();\n            const response = yield fetch(BaseUrl.RecursiveSearchUrl(), {\n                method: \"POST\",\n                headers: myHeaders,\n                body: raw,\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                let conceptIds = result.compositionIds;\n                let connections = result.internalConnections;\n                let externalConnections = result.externalConnections;\n                return result;\n            }\n            else {\n                console.log(\"recursive search error \", response.status);\n                HandleHttpError(response);\n            }\n            return [];\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log(\"recursive search error message: \", error.message);\n            }\n            else {\n                console.log(\"recursive search unexpected error: \", error);\n            }\n            HandleInternalError(error, BaseUrl.RecursiveSearchUrl());\n        }\n    });\n}\nexport function RecursiveSearchApiNewRawFullLinker() {\n    return __awaiter(this, arguments, void 0, function* (composition = 0, fullLinkers = [], textSearch = \"\") {\n        if (serviceWorker) {\n            const res = yield sendMessage(\"RecursiveSearchApiNewRawFullLinker\", {\n                composition,\n                fullLinkers,\n                textSearch,\n            });\n            // console.log(\"data received from sw\", res);\n            return res.data;\n        }\n        let concepts = [];\n        try {\n            let searchQuery = new SearchQuery();\n            searchQuery.composition = composition;\n            searchQuery.fullLinkers = fullLinkers;\n            searchQuery.textSearch = textSearch;\n            let raw = JSON.stringify(searchQuery);\n            let Connections = [];\n            let myHeaders = GetRequestHeader();\n            const response = yield fetch(BaseUrl.RecursiveSearchUrl(), {\n                method: \"POST\",\n                headers: myHeaders,\n                body: raw,\n            });\n            if (response.ok) {\n                const result = yield response.json();\n                let conceptIds = result.compositionIds;\n                let connections = result.internalConnections;\n                let externalConnections = result.externalConnections;\n                return result;\n            }\n            else {\n                console.log(\"recursive search error \", response.status);\n                HandleHttpError(response);\n            }\n            return [];\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log(\"recursive search error message: \", error.message);\n            }\n            else {\n                console.log(\"recursive search unexpected error: \", error);\n            }\n            HandleInternalError(error, BaseUrl.RecursiveSearchUrl());\n        }\n    });\n}\nexport function RecursiveSearchLocal(composition_1) {\n    return __awaiter(this, arguments, void 0, function* (composition, listLinkers = [], textSearch = \"\") { });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from \"./../../DataStructures/ConceptData\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { CreateDefaultConcept } from \"../../app\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nexport function GetConceptByCharacterAndCategoryDirectApi(characterValue, category_id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = CreateDefaultConcept();\n        try {\n            var header = GetRequestHeader('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetConceptByCharacterAndCategoryDirectUrl(), {\n                method: 'POST',\n                headers: header,\n                body: `character_value=${characterValue}&category_id=${category_id}`,\n            });\n            if (response.ok) {\n                let conceptString = yield response.json();\n                concept = conceptString;\n                ConceptsData.AddConcept(concept);\n            }\n            else {\n                //  throw new Error(`Error! status: ${response.status}`);\n                console.log(\"This is the concept by category and character error\", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log(' This is the concept by category and character error message: ', error.message);\n            }\n            else {\n                console.log(' This is the concept by category and character unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetConceptByCharacterAndCategoryDirectUrl());\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nexport function FreeschemaQueryApi(query_1) {\n    return __awaiter(this, arguments, void 0, function* (query, token = \"\") {\n        var header = GetRequestHeaderWithAuthorization(\"application/json\", token);\n        const queryUrl = BaseUrl.FreeschemaQueryUrl();\n        const body = JSON.stringify(query);\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'POST',\n                headers: header,\n                body: body\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                HandleHttpError(response);\n                console.log(\"This is the freeschema query error\", response.status);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the freeschema query error others\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nexport function SearchAllConcepts(type_1, search_1, composition_1, token_1) {\n    return __awaiter(this, arguments, void 0, function* (type, search, composition, token, inpage = 10, page = 1) {\n        var header = GetRequestHeaderWithAuthorization('application/x-www-form-urlencoded', token);\n        var urlencoded = new URLSearchParams();\n        urlencoded.append(\"type\", type);\n        urlencoded.append(\"search\", search);\n        urlencoded.append(\"composition\", composition);\n        urlencoded.append(\"inpage\", inpage.toString());\n        urlencoded.append(\"page\", page.toString());\n        const queryUrl = BaseUrl.SearchCompositionsUrl() + \"?\" + urlencoded.toString();\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'GET',\n                headers: header\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                HandleHttpError(response);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching error\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../app\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nexport function SearchInternalApi(search_1) {\n    return __awaiter(this, arguments, void 0, function* (search, token = \"\") {\n        var header = GetRequestHeaderWithAuthorization(\"application/json\", token);\n        let queryUrl = BaseUrl.SearchInternalWithAuthenticatedCcsUrl();\n        queryUrl = queryUrl + '?composition=' + search.composition + '&search=' + search.search + '&internalComposition=' + search.internalComposition + '&type=' + search.type + '&inpage=' + search.inpage + '&page=' + search.page;\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'GET',\n                headers: header\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                console.log(\"This is the searching internal error\", response.status);\n                HandleHttpError(response);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching internal error\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\nexport function SearchInternalAllApi(search) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var header = GetRequestHeaderWithAuthorization(\"application/json\", \"\");\n        let queryUrl = BaseUrl.SearchInternalWithCcsUrl();\n        queryUrl = queryUrl + '?composition=' + search.composition + '&search=' + search.search + '&internalComposition=' + search.internalComposition + '&type=' + search.type + '&inpage=' + search.inpage + '&page=' + search.page;\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'GET',\n                headers: header\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                console.log(\"This is the searching internal error\", response.status);\n                HandleHttpError(response);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching internal error\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from \"../../app\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nexport function SearchLinkMultipleApi(searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchQuery, token = \"\") {\n        let startTime = performance.now();\n        var header = GetRequestHeaderWithAuthorization(\"application/json\", token);\n        const queryUrl = BaseUrl.SearchLinkMultipleAllApiUrl();\n        const body = JSON.stringify(searchQuery);\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'POST',\n                headers: header,\n                body: body\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                // Add Log\n                Logger.logInfo(startTime, \"unknown\", \"search\", \"unknown\", undefined, 200, result, \"SearchLinkMultipleApi\", ['searchQuery', 'token'], \"unknown\", undefined);\n                return result;\n            }\n            else {\n                HandleHttpError(response);\n                console.log(\"This is the searching multiple error\", response.status);\n                Logger.logWarning(startTime, \"unknown\", \"search\", \"unknown\", undefined, response.status, response, \"SearchLinkMultipleApi\", ['searchQuery', 'token'], \"unknown\", undefined);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching multiple error\", ex);\n            Logger.logWarning(startTime, \"unknown\", \"search\", \"unknown\", undefined, 500, ex, \"SearchLinkMultipleApi\", ['searchQuery', 'token'], \"unknown\", undefined);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nexport function SearchWithLinker(searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchQuery, token = \"\") {\n        var header = GetRequestHeaderWithAuthorization(\"application/json\", token);\n        const queryUrl = BaseUrl.SearchLinkMultipleAll();\n        const body = JSON.stringify(searchQuery);\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'POST',\n                headers: header,\n                body: body\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                console.log(\"This is the searching error\", response.status);\n                HandleHttpError(response);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching error\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../app\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nexport function SearchWithTypeAndLinkerApi(searchStructure_1, searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchStructure, searchQuery, token = \"\") {\n        let queryUrl = BaseUrl.SearchAllTypeWithLinker(searchStructure.auth);\n        var header = GetRequestHeaderWithAuthorization(\"application/json\", token);\n        queryUrl = queryUrl + '?search=' + searchStructure.search + '&type=' + searchStructure.type + '&inpage=' + searchStructure.inpage + '&page=' + searchStructure.page;\n        const body = JSON.stringify(searchQuery);\n        try {\n            const response = yield fetch(queryUrl, {\n                method: 'POST',\n                headers: header,\n                body: body\n            });\n            if (response.ok) {\n                let result = yield response.json();\n                return result;\n            }\n            else {\n                HandleHttpError(response);\n                console.log(\"This is the searching multiple error\", response.status);\n                return [];\n            }\n        }\n        catch (ex) {\n            console.log(\"This is the searching SearchWithTypeAndLinker error\", ex);\n            HandleInternalError(ex, queryUrl);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nexport function CreateSession(sessionData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            var header = GetRequestHeader();\n            const body = JSON.stringify(sessionData);\n            const response = yield fetch(BaseUrl.CreateSessionId(), {\n                method: 'POST',\n                headers: header,\n                body: body\n            });\n            if (response.ok) {\n                return response.json();\n            }\n            else {\n                console.log(\"Creating session failed\", yield response.json());\n                HandleHttpError(response);\n                return null;\n            }\n        }\n        catch (ex) {\n            console.log(\"Creating session failed\", ex);\n            HandleInternalError(ex, BaseUrl.CreateSessionId());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nexport function CreateSessionVisit(sessionId, url) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            var header = GetRequestHeader(\"application/x-www-form-urlencoded\");\n            const urlencoded = new URLSearchParams();\n            urlencoded.append(\"sessionId\", sessionId.toString());\n            urlencoded.append(\"url\", url);\n            const response = yield fetch(BaseUrl.CreateSessionVisitUrl(), {\n                method: 'POST',\n                headers: header,\n                body: urlencoded\n            });\n            if (response.ok) {\n                return response.json();\n            }\n            else {\n                console.log(\"Creating session url failed\", yield response.json());\n                HandleHttpError(response);\n                return null;\n            }\n        }\n        catch (ex) {\n            console.log(\"Creating session url failed\", ex);\n            HandleInternalError(ex, BaseUrl.CreateSessionVisitUrl());\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { BaseUrl } from \"../app\";\nexport default function Signin(signinInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const raw = JSON.stringify({\n            email: signinInfo.email,\n            password: signinInfo.password,\n        });\n        let freeschemaRes = {\n            message: 'success',\n            status: false,\n            statusCode: 200,\n            data: '',\n        };\n        const myHeaders = new Headers();\n        myHeaders.append('Content-Type', 'application/json');\n        const url = BaseUrl.LoginUrl();\n        try {\n            const response = yield fetch(url, {\n                method: 'POST',\n                headers: myHeaders,\n                body: raw,\n                redirect: 'follow',\n            });\n            const output = yield response.json();\n            if (response.ok) {\n                const dataObject = output === null || output === void 0 ? void 0 : output.data;\n                freeschemaRes = {\n                    message: 'success',\n                    status: true,\n                    statusCode: 200,\n                    data: dataObject,\n                };\n            }\n            else {\n                HandleHttpError(response);\n            }\n            return freeschemaRes;\n        }\n        catch (error) {\n            console.log('Sign in api error', error);\n            HandleInternalError(error, url);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { HandleHttpError, HandleInternalError } from \"../Services/Common/ErrorPosting\";\nimport { BaseUrl } from \"../app\";\nexport default function Signup(signupModel) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const signupResponse = yield postData(BaseUrl.SignupUrl(), signupModel);\n        return signupResponse;\n    });\n}\nfunction postData() {\n    return __awaiter(this, arguments, void 0, function* (url = '', data = {}) {\n        let freeschemaRes = {\n            message: 'success',\n            status: false,\n            statusCode: 200,\n            data: '',\n        };\n        // Default options are marked with *\n        try {\n            const response = yield fetch(url, {\n                method: 'POST', // *GET, POST, PUT, DELETE, etc.\n                mode: 'cors', // no-cors, *cors, same-origin\n                cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached\n                credentials: 'same-origin', // include, *same-origin, omit\n                headers: {\n                    'Content-Type': 'application/json',\n                    // 'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                redirect: 'follow', // manual, *follow, error\n                referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url\n                body: JSON.stringify(data), // body data type must match \"Content-Type\" header\n            });\n            const output = yield response.json();\n            if (response.ok) {\n                freeschemaRes = {\n                    message: 'success',\n                    status: true,\n                    statusCode: 200,\n                    data: output,\n                };\n            }\n            else {\n                HandleHttpError(response);\n            }\n            return freeschemaRes;\n        }\n        catch (error) {\n            console.log('Signup Error: ', error);\n            HandleInternalError(error, url);\n        }\n    });\n}\n// export async function submitSignupForm(e: any) {\n//   e.preventDefault();\n//   // alert(\"Are you sure to want to signup?\");\n//   const inputType = <HTMLInputElement>document.getElementById(\"type\");\n//   const typeValue = inputType?.value;\n//   const inputUsername = <HTMLInputElement>document.getElementById(\"username\");\n//   const usernameValue = inputUsername?.value;\n//   const inputEmail = <HTMLInputElement>document.getElementById(\"email\");\n//   const emailValue = inputEmail?.value;\n//   const inputGender = <HTMLInputElement>document.getElementById(\"gender\");\n//   const genderValue = inputGender?.value;\n//   const inputFirstName = <HTMLInputElement>document.getElementById(\"firstName\");\n//   const firstNameValue = inputFirstName?.value;\n//   const inputLastName = <HTMLInputElement>document.getElementById(\"lastName\");\n//   const lastNameValue = inputLastName?.value;\n//   const inputPassword = <HTMLInputElement>document.getElementById(\"password\");\n//   const passwordValue = inputPassword?.value;\n//   const inputConfirmPassword = <HTMLInputElement>(\n//     document.getElementById(\"confirmPassword\")\n//   );\n//   const confirmPasswordValue = inputConfirmPassword?.value;\n//   // console.log(confirmPasswordValue,\"confirmPasswordValue\");\n//   const inputprivacyPolicy = <HTMLInputElement>(\n//     document.getElementById(\"privacyPolicy\")\n//   );\n//   const privacyPolicy = inputprivacyPolicy?.checked;\n//   const inputPrivacyPolicyError = <HTMLInputElement>(\n//     document.getElementById(\"privacyPolicyError\")\n//   );\n//   if (!privacyPolicy) {\n//     inputPrivacyPolicyError.style.display = \"block\";\n//   }\n//   const signupData: any = {\n//     type: typeValue,\n//     username: usernameValue,\n//     title: genderValue,\n//     email: emailValue,\n//     password: passwordValue,\n//     timestamp: new Date().toISOString(),\n//     fname: firstNameValue,\n//     lname: lastNameValue,\n//   };\n//   if (privacyPolicy) {\n//     const signupResponse = await signupEntity(signupData);\n//     if (!signupResponse?.error && signupResponse?.data) {\n//       updateContent(\"/login\");\n//     }\n//   }\n// }\n/**\n *\n * @param signupData\n *   const signupData: any = {\n *   type: typeValue,\n *   username: usernameValue,\n *   title: genderValue,\n *   email: emailValue,\n *   password: passwordValue,\n *   timestamp: new Date().toISOString(),\n *   fname: firstNameValue,\n *   lname: lastNameValue,\n * };\n * @returns\n */\nexport function SignupEntity(signupData) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const baseURL = BaseUrl.NODE_URL;\n        const response = yield fetch(`${baseURL}/api/v1/entity/signup`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(signupData),\n        });\n        if (response.ok) {\n            return response.json();\n        }\n        else {\n            if (response.status === 404)\n                throw new Error(\"404, Not found\");\n            if (response.status === 500)\n                throw new Error(\"500, internal server error\");\n            throw new Error(response.status);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError, HandleInternalError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeaderWithAuthorization } from \"../../Services/Security/GetRequestHeader\";\nimport { ConceptsData, CreateDefaultConcept } from \"../../app\";\nexport function TranslateLocalToReal(conceptId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let result = CreateDefaultConcept();\n        try {\n            var header = GetRequestHeaderWithAuthorization('application/x-www-form-urlencoded');\n            const response = yield fetch(BaseUrl.GetRealConceptById(), {\n                method: 'POST',\n                headers: header,\n                body: `id=${conceptId}`\n            });\n            if (response.ok) {\n                result = (yield response.json());\n                if (result.id > 0) {\n                    ConceptsData.AddConcept(result);\n                }\n                return result;\n            }\n            else {\n                console.log(\"Error in Getting Translating concept Error\", response.status);\n                HandleHttpError(response);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log('Error in Getting Translating concept error message: ', error);\n            }\n            else {\n                console.log('Error in Getting Translating concept unexpected error: ', error);\n            }\n            HandleInternalError(error, BaseUrl.GetRealConceptById());\n        }\n        return result;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../../DataStructures/BaseUrl\";\nimport { HandleHttpError } from \"../../Services/Common/ErrorPosting\";\nimport { GetRequestHeader } from \"../../Services/Security/GetRequestHeader\";\nimport { GetConceptBulk } from \"../../app\";\nexport function ViewInternalDataApi(ids) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connectionList = [];\n        try {\n            var header = GetRequestHeader();\n            const response = yield fetch(BaseUrl.ViewInternalDataUrl(), {\n                method: 'POST',\n                headers: header,\n                body: JSON.stringify(ids)\n            });\n            if (response.ok) {\n                let conceptString = yield response.json();\n                let connectionDictionary = {};\n                for (let i = 0; i < conceptString.length; i++) {\n                    let conceptList = conceptString[i].concepts;\n                    connectionList = conceptString[i].connections;\n                    let id = conceptString[i].id;\n                    GetConceptBulk(conceptList);\n                    connectionDictionary[id] = connectionList;\n                }\n                return connectionDictionary;\n            }\n            else {\n                //  throw new Error(`Error! status: ${response.status}`);\n                console.log(\"View Internal Data error\", response.status);\n                HandleHttpError(response);\n            }\n            return connectionList;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.log(' This is the view internal data error message: ', error.message);\n            }\n            else {\n                console.log(' This is the view internal data unexpected error: ', error);\n            }\n            throw error;\n        }\n    });\n}\n","export const ADMIN = 3;\nexport const PRIVATE = 4;\nexport const PUBLIC = 5;\n","export const NORMAL = 1;\nexport const DATAID = 2;\nexport const JUSTDATA = 3;\nexport const DATAIDDATE = 4;\nexport const RAW = 5;\nexport const ALLID = 6;\nexport const LISTNORMAL = 7;\n","const channelName = 'Freeschema_mftsccs_browser_channel';\nexport const broadcastChannel = new BroadcastChannel(channelName);\n","export class BaseUrl {\n    static setRandomizer(id) {\n        console.log('set randomizer', id);\n        this.BASE_RANDOMIZER = id;\n    }\n    static getRandomizer() {\n        return this.BASE_RANDOMIZER;\n    }\n    // static GetConceptUrl:string = this.BASE_URL + '/api/getConcept';\n    static GetConceptUrl() {\n        return this.BASE_URL + '/api/getConcept';\n    }\n    static GetConnectionUrl() {\n        return this.BASE_URL + '/api/get-connection-by-id';\n    }\n    static GetConceptBulkUrl() {\n        return this.BASE_URL + '/api/get_concept_bulk';\n    }\n    static GetConnectionBulkUrl() {\n        return this.BASE_URL + '/api/get_connection_bulk';\n    }\n    static GetAllConceptsOfUserUrl() {\n        return this.BASE_URL + '/api/get_all_concepts_of_user';\n    }\n    static GetAllConnectionsOfUserUrl() {\n        return this.BASE_URL + '/api/get_all_connections_of_user';\n    }\n    static GetAllConnectionsOfCompositionUrl() {\n        return this.BASE_URL + '/api/get_all_connections_of_composition';\n    }\n    static GetAllConnectionsOfCompositionBulkUrl() {\n        return this.BASE_URL + '/api/get_all_connections_of_composition_bulk';\n    }\n    static GetConceptByCharacterValueUrl() {\n        return this.BASE_URL + '/api/get_concept_by_character_value';\n    }\n    static GetConceptByCharacterAndTypeUrl() {\n        return this.BASE_URL + '/api/get_concept_by_character_and_type';\n    }\n    static GetConceptByCharacterAndCategoryUrl() {\n        return this.BASE_URL + '/api/get_concept_by_character_and_category';\n    }\n    static GetConceptByCharacterAndCategoryDirectUrl() {\n        return this.BASE_URL + '/api/get_concept_by_character_and_category_direct';\n    }\n    static GetCharacterByCharacterUrl() {\n        return this.BASE_URL + '/api/get_character_by_character';\n    }\n    static GetAllConceptsByTypeUrl() {\n        return this.BASE_URL + '/api/get_all_concepts_by_type';\n    }\n    static GetAllConnectionsOfConceptUrl() {\n        return this.BASE_URL + '/api/get-link-connections';\n    }\n    static GetAllAiData() {\n        return this.BASE_URL + '/api/get-preloaded-concepts';\n        // return this.AI_URL + '/api/get_ranked_type_id?inpage=300' || process.env.AI_URL ||  'https://ai.freeschema.com/api/get_ranked_type_id?inpage=300';\n    }\n    static PostPrefetchConceptConnections() {\n        return this.NODE_URL + '/api/v1/access-tracker/sync-access-tracker';\n    }\n    static GetSuggestedConcepts() {\n        return this.NODE_URL + '/api/v1/access-tracker/list-concepts-file';\n    }\n    static GetSuggestedConnections() {\n        return this.NODE_URL + '/api/v1/access-tracker/list-connections-file';\n    }\n    static GetAllPrefetchConnectionsUrl() {\n        return this.BASE_URL + '/api/get_all_connections_of_user?inpage=500';\n    }\n    static GetAllLinkerConnectionOfConceptUrl() {\n        return this.BASE_URL + '/api/get-all-linkers-from-concept';\n    }\n    static GetAllLinkerConnectionToConceptUrl() {\n        return this.BASE_URL + '/api/get-all-linkers-to-concept';\n    }\n    static DeleteConceptUrl() {\n        return this.BASE_URL + '/api/delete_concept';\n    }\n    static DeleteUserUrl() {\n        return this.BASE_URL + '/api/deleteuser';\n    }\n    static RecursiveSearchUrl() {\n        return this.BASE_URL + '/api/recursivesearch-concept-connection';\n    }\n    static SearchLinkMultipleAllApiUrl() {\n        return this.BASE_URL + '/api/Connection/search-link-multiple-all-ccs';\n    }\n    static MakeTheNameInBackendUrl() {\n        return this.BASE_URL + '/api/make-name-from-frontend';\n    }\n    static SearchAllTypeWithLinker(auth = true) {\n        if (auth) {\n            return this.BASE_URL + '/api/search-all-with-linker-ccs';\n        }\n        else {\n            return this.BASE_URL + '/api-search-compositions-internal-clean-ccs';\n        }\n    }\n    static LoginUrl() {\n        return this.BASE_URL + '/api/auth/login';\n    }\n    static SignupUrl() {\n        return this.BASE_URL + '/api/auth/signup';\n    }\n    static GetCompositionConnectionBetweenTwoConceptsUrl() {\n        return this.BASE_URL + '/api/get-composition-connection-between-two-concepts';\n    }\n    static SearchCompositionsUrl() {\n        return this.BASE_URL + '/api/search-compositions';\n    }\n    static SearchLinkMultipleAll() {\n        return this.BASE_URL + '/api/Connection/search-link-multiple-all';\n    }\n    static CreateSessionId() {\n        return this.BASE_URL + '/api/create-session-id-remote';\n    }\n    static CreateSessionVisitUrl() {\n        return this.BASE_URL + '/api/create-remote-session-visit';\n    }\n    //////////////////////////////////////////////////////////////////////////////\n    /////////////////////Api for viewing internal data //////////////////////////\n    static ViewInternalDataUrl() {\n        return this.BASE_URL + '/api/view-api-internal-data-ccs-id-bulk';\n    }\n    static SearchInternalWithAuthenticatedCcsUrl() {\n        return this.BASE_URL + '/api/search-composition-internal-authenticated-ccs';\n    }\n    static SearchInternalWithCcsUrl() {\n        return this.BASE_URL + '/api-search-compositions-internal-clean-ccs';\n    }\n    static CreateGhostConceptApiUrl() {\n        return BaseUrl.NODE_URL + '/api/v1/local-concepts';\n    }\n    static CreateGhostConnectionApiUrl() {\n        return BaseUrl.NODE_URL + '/api/v1/local-connections';\n    }\n    static GetRealConceptById() {\n        return BaseUrl.NODE_URL + '/api/v1/local-concepts-translate';\n    }\n    //////////////////////////////////////////////////////////////////////////////\n    //////////////// API For Reserved Ids ///////////////////////////////////////\n    static GetReservedIdUrl() {\n        return this.BASE_URL + '/api/get_reserved_ids';\n    }\n    static GetReservedConnectionIdUrl() {\n        return this.BASE_URL + '/api/get_reserved_connection_ids';\n    }\n    /////////////////////////////////////////////////////////////////////////////\n    ////////////////API For Creating Data //////////////////////////////////////\n    static CreateTheTextDataUrl() {\n        return this.BASE_URL + '/api/create_text_data';\n    }\n    static CreateTheCharacterDataUrl() {\n        return this.BASE_URL + '/api/create_character_data';\n    }\n    static CreateTheConceptUrl() {\n        return this.BASE_URL + '/api/create_the_concept';\n    }\n    static CreateTheConnectionUrl() {\n        return this.BASE_URL + '/api/create_the_connection';\n    }\n    static CreateTheConnectionNewUrl() {\n        return this.BASE_URL + '/api/create_the_connection_new';\n    }\n    static MakeTheTypeConceptUrl() {\n        return this.BASE_URL + '/api/make_the_type_concept';\n    }\n    ////////////////////////////////////////////////////////////////////////\n    /////////////////////API FOR Deleting Connection //////////////////////\n    static DeleteTheConnectionUrl() {\n        return this.BASE_URL + '/api/delete_connection';\n    }\n    //////////////////////////////////////////////////////////////////////\n    //////////////////////API FOR FREESCHEMA QUERY //////////////////////\n    static FreeschemaQueryUrl() {\n        return this.BASE_URL + '/api/freeschema-query';\n    }\n}\nBaseUrl.BASE_URL = \"https://localhost:7053/\";\nBaseUrl.AI_URL = \"https://ai.freeschema.com\";\nBaseUrl.MQTT_URL = '192.168.1.249';\nBaseUrl.NODE_URL = \"http://localhost:5001\";\nBaseUrl.BASE_APPLICATION = \"\";\nBaseUrl.BASE_RANDOMIZER = 999;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"./IdentifierFlags\";\nimport { Node } from \"./Node\";\nexport class BinaryCharacterTree {\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isCharacterLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(BinaryCharacterTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static addNodeToTree(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.characterRoot == null) {\n                this.characterRoot = node;\n                return this.characterRoot;\n            }\n            else {\n                this.characterRoot = this.characterRoot.addCharacterNode(node, this.characterRoot, this.characterRoot.height);\n            }\n            return this.characterRoot;\n        });\n    }\n    static removeNodeByCharacter(character, id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.characterRoot) {\n                this.characterRoot.removeNodeWithVariants(this.characterRoot, character, id);\n            }\n        });\n    }\n    static countNumberOfNodes() {\n        if (this.characterRoot) {\n            return this.characterRoot.countNodeBelow(this.characterRoot);\n        }\n        return 0;\n    }\n    static addConceptToTree(concept) {\n        if (concept.characterValue != \"\") {\n            var node = new Node(concept.characterValue, concept, null, null);\n            this.addNodeToTree(node);\n        }\n    }\n    static getNodeFromTree(value) {\n        if (this.characterRoot) {\n            var Node = this.characterRoot.getCharacterFromNode(value, this.characterRoot);\n            return Node;\n        }\n        return this.characterRoot;\n    }\n    static getNodeFromTreeUpdated(value) {\n        if (this.characterRoot) {\n            var Node = this.characterRoot.getCharacterFromNode(value, this.characterRoot);\n            return Node;\n        }\n        return this.characterRoot;\n    }\n    static getCharacterAndTypeFromTree(value, typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // try{\n            //     var data = await this.waitForDataToLoad();\n            // }\n            // catch(exception){\n            //     return null;\n            // }\n            if (this.characterRoot) {\n                var Node = this.characterRoot.getFromNodeWithCharacterAndType(value, typeId, this.characterRoot);\n                return Node;\n            }\n            return this.characterRoot;\n        });\n    }\n    static getCharacterAndCategoryFromTree(value, categoryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // try{\n            //     var data = await this.waitForDataToLoad();\n            // }\n            // catch(exception){\n            //     return null;\n            // }\n            if (this.characterRoot) {\n                var Node = this.characterRoot.getFromNodeWithCharacterAndCategory(value, categoryId, this.characterRoot);\n                return Node;\n            }\n            return this.characterRoot;\n        });\n    }\n    static removeConceptCharacter(id) {\n        if (this.characterRoot) {\n            this.characterRoot = this.characterRoot.removeNode(this.characterRoot, id);\n        }\n    }\n}\nBinaryCharacterTree.characterRoot = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BinaryCharacterTree } from \"./BinaryCharacterTree\";\nimport { Node } from \"./Node\";\nimport { IdentifierFlags } from \"./IdentifierFlags\";\nimport { dispatchIdEvent } from \"../app\";\nexport class BinaryTree {\n    static addNodeToTree(node) {\n        if (this.root == null) {\n            this.root = node;\n            return this.root;\n        }\n        else {\n            this.root = this.root.addNode(node, this.root, this.root.height);\n        }\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isDataLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(BinaryTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static addConceptToTree(concept) {\n        let node = new Node(concept.id, concept, null, null);\n        let characterNode = new Node(concept.characterValue, concept, null, null);\n        BinaryCharacterTree.addNodeToTree(characterNode);\n        this.addNodeToTree(node);\n    }\n    static getNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                let Node = this.root.getFromNode(id, this.root);\n                return Node;\n            }\n            return null;\n        });\n    }\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                let event = new Event(`${id}`);\n                console.log(\"this is the fired event after delete\", event);\n                //  dispatchEvent(event);\n                dispatchIdEvent(id);\n                this.root = this.root.removeNode(this.root, id);\n            }\n        });\n    }\n    static getConceptListFromIds(ids, connectionArray, remainingIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                this.root.checkIfIdsInNode(this.root, ids, connectionArray, remainingIds);\n            }\n        });\n    }\n    static countNumberOfNodes() {\n        if (this.root) {\n            return this.root.countNodeBelow(this.root);\n        }\n        return 0;\n    }\n}\nBinaryTree.root = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { dispatchIdEvent, GetTheConcept } from \"../app\";\nimport { CreateDefaultConcept } from \"../Services/CreateDefaultConcept\";\nimport { IdentifierFlags } from \"./IdentifierFlags\";\nimport { TypeNode } from \"./TypeNode\";\nexport class BinaryTypeTree {\n    // old method having concept as the value.\n    // static async addNodeToTree(node:Node){\n    //     if(this.typeRoot == null){\n    //         this.typeRoot = node;\n    //         return this.typeRoot;\n    //     }\n    //     else{\n    //          let event = new CustomEvent(`${node.value.typeId}`, {detail: node.value.id});\n    //         // console.log(\"this is the fired event\", event);\n    //          dispatchEvent(event);\n    //         this.typeRoot = this.typeRoot.addTypeNode(node,this.typeRoot,this.typeRoot.height);\n    //     }\n    //     return this.typeRoot;\n    // }\n    // new method with just ids \n    static addType(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root == null) {\n                this.root = node;\n                return this.root;\n            }\n            else {\n                let event = new CustomEvent(`${node.key}`, { detail: node.value[0] });\n                // console.log(\"this is the fired event\", event);\n                //  dispatchEvent(event);\n                dispatchIdEvent(node.key, { detail: node.value[0] });\n                // console.log(\"this is the fired event\", event);\n                this.root = this.root.addType(this.root, node.key, node.value[0]);\n            }\n            return this.root;\n        });\n    }\n    static addConceptToTree(concept) {\n        if (concept.typeId != 0) {\n            /// old type \n            // var node: Node = new Node(concept.typeId, concept, null, null);\n            // this.addNodeToTree(node);\n            // new functionality\n            let typeNode = new TypeNode(concept.typeId, concept.id);\n            this.addType(typeNode);\n        }\n    }\n    static removeTypeConcept(typeId, id) {\n        // old mehtod\n        // if(this.typeRoot){\n        //     this.typeRoot = this.typeRoot.removeNodeWithVariants(this.typeRoot,typeId,id);\n        // }\n        // new method\n        if (this.root) {\n            this.root = this.root.removeNodeWithVariants(this.root, typeId, id);\n        }\n    }\n    // static getNodeFromTree(id:number){\n    //     // old method\n    //     if(this.typeRoot){\n    //         var Node = this.typeRoot.getFromNode(id, this.typeRoot);\n    //         return Node;\n    //     }\n    //     return this.typeRoot;\n    // }\n    static getNodeFromTreeNew(id) {\n        // new method\n        if (this.root) {\n            let node = this.root.getFromNode(id, this.root);\n            return node;\n        }\n        return this.root;\n    }\n    /// old method\n    // static getTypeVariantsFromTree(typeId:number){\n    //         let Node = this.getNodeFromTree(typeId);\n    //         var concepts : Concept[] = [];\n    //         if(Node){\n    //             concepts.push(Node?.value);\n    //             for(let i=0; i< Node.variants.length; i++){\n    //                 concepts.push(Node.variants[i].value);\n    //             }\n    //         return concepts;\n    //     }\n    // }\n    //new method\n    static getTypeVariantsFromTreeNew(typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let node = this.getNodeFromTreeNew(typeId);\n            let conceptIds = [];\n            let concepts = [];\n            if (node) {\n                conceptIds = node.value;\n                for (let i = 0; i < conceptIds.length; i++) {\n                    let alreadyExist = false;\n                    for (let j = 0; j < concepts.length; j++) {\n                        if (concepts[j].id == conceptIds[i]) {\n                            alreadyExist = true;\n                        }\n                    }\n                    if (!alreadyExist) {\n                        concepts.push(yield GetTheConcept(conceptIds[i]));\n                    }\n                }\n            }\n            return concepts;\n        });\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isTypeLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(BinaryTypeTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    // static async getTypeVariantsFromTreeWithUserId(typeId:number, userId:number){\n    //     var concepts : Concept[] = [];\n    //         var Node = this.getNodeFromTree(typeId);\n    //         if(Node){\n    //             console.log(\"this is the tree to find\", Node.value);\n    //             if(Node.value.userId == userId ){\n    //                 concepts.push(Node?.value);\n    //             }\n    //             for(let i=0; i< Node.variants.length; i++){\n    //                 if(Node.variants[i].value.userId == userId ){\n    //                     var isPresent = false;\n    //                     for(let j=0; j<concepts.length;j++){\n    //                         if(concepts[j].id == Node.variants[i].value.id){\n    //                             isPresent = true;\n    //                         }\n    //                     }\n    //                     if(!isPresent){\n    //                         concepts.push(Node.variants[i].value);\n    //                     }\n    //                 }\n    //             }\n    //         }\n    //     return concepts;\n    // }\n    // new method\n    static getTypeVariantsFromTreeWithUserIdNew(typeId, userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let concepts = [];\n            let allConcepts = yield this.getTypeVariantsFromTreeNew(typeId);\n            console.log(\"these are all the concepts\", allConcepts);\n            for (let i = 0; i < allConcepts.length; i++) {\n                if (allConcepts[i].userId == userId) {\n                    concepts.push(allConcepts[i]);\n                }\n            }\n            return concepts;\n        });\n    }\n    // static async getTypeVariantsWithCharacterValue( characterValue:string,typeId:number,){\n    //     let concept = CreateDefaultConcept();\n    //         var Node = this.getNodeFromTree(typeId);\n    //         if(Node){\n    //             if(Node.value.characterValue == characterValue ){\n    //                 concept = Node.value;\n    //             }\n    //             for(let i=0; i< Node.variants.length; i++){\n    //                 if(Node.variants[i].value.characterValue == characterValue ){\n    //                     concept = Node.variants[i].value;\n    //                 }\n    //             }\n    //         }\n    //     return concept;\n    // }\n    //new method\n    static getTypeVariantsWithCharacterValueNew(characterValue, typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let allConcepts = yield this.getTypeVariantsFromTreeNew(typeId);\n            console.log(\"this is all the concepts for character\", allConcepts);\n            let concept = CreateDefaultConcept();\n            for (let i = 0; i < allConcepts.length; i++) {\n                if (allConcepts[i].characterValue == characterValue) {\n                    concept = allConcepts[i];\n                }\n            }\n            return concept;\n        });\n    }\n    static countNumberOfNodes() {\n        if (this.typeRoot) {\n            return this.typeRoot.countNodeBelow(this.typeRoot);\n        }\n        return 0;\n    }\n}\nBinaryTypeTree.typeRoot = null;\nBinaryTypeTree.root = null;\n","import { TheCharacter } from \"./TheCharacter\";\nexport class CharacterRepository {\n    constructor() {\n        this.name = \"character Repository\";\n    }\n    static AddCharacter(character) {\n        this.characterData[character.id] = character;\n    }\n    static GetCharacter(value) {\n        var theCharacter = new TheCharacter(0, \"0\", 0, 0, 0, 0, 0, 0, \"0\", false);\n        for (var i = 0; i < this.characterData.length; i++) {\n            if (this.characterData[i].data == value) {\n                theCharacter = this.characterData[i];\n            }\n        }\n        return theCharacter;\n    }\n}\nCharacterRepository.characterData = [];\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { recursiveFetchNew } from '../../Services/Composition/BuildComposition';\nimport { CreateDefaultConcept } from '../../Services/CreateDefaultConcept';\nimport { publishMessage } from '../../Services/Mqtt/publishMessage';\nexport class Composition {\n    constructor() {\n        // we can build a composition using this class\n        this.id = 0;\n        this.mainConcept = CreateDefaultConcept();\n        this.connections = [];\n        this.concepts = [];\n        this.subcompositions = [];\n        this.cached = {};\n    }\n    updateCache() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.mainConcept.id == 0)\n                for (let i = 0; i < this.concepts.length; i++) {\n                    if (this.concepts[i].id == this.id) {\n                        this.mainConcept = this.concepts[i];\n                    }\n                }\n            let visitedConcepts = [];\n            this.cached = yield recursiveFetchNew(this.id, this.connections, this.concepts, this.subcompositions, visitedConcepts);\n        });\n    }\n    UpdateAcrossDistributedSystem() {\n        var _a;\n        try {\n            if (this.id != 0) {\n                publishMessage('compositionUpdate', (_a = this.id) === null || _a === void 0 ? void 0 : _a.toString());\n            }\n        }\n        catch (ex) {\n            console.log('Error while publishing message', ex);\n        }\n    }\n    isUpdating() {\n        this.UpdateAcrossDistributedSystem();\n    }\n    GetDataCache() {\n        var _a, _b, _c;\n        const returnOutput = {};\n        const mainString = (_c = (_b = (_a = this.mainConcept) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.characterValue) !== null && _c !== void 0 ? _c : '';\n        returnOutput[mainString] = this.cached;\n        const FinalReturn = {};\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = this.id;\n        return FinalReturn;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CompositionNode } from './CompositionNode';\nexport class CompositionBinaryTree {\n    static addNodeToTree(node) {\n        if (this.root == null) {\n            this.root = node;\n            return this.root;\n        }\n        else {\n            this.root = this.root.addNode(node, this.root, this.root.height);\n        }\n    }\n    static addCompositionToTree(composition) {\n        const node = new CompositionNode(composition.id, composition, null, null);\n        this.addNodeToTree(node);\n    }\n    static getNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                const Node = this.root.getFromNode(id, this.root);\n                return Node;\n            }\n            return null;\n        });\n    }\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                this.root = this.root.removeNode(this.root, id);\n            }\n        });\n    }\n    static countNumberOfNodes() {\n        if (this.root) {\n            return this.root.countNodeBelow(this.root);\n        }\n        return 0;\n    }\n}\n// this is a binary tree to hold compositions in it\nCompositionBinaryTree.root = null;\n","import { CompositionBinaryTree } from './CompositionBinaryTree';\nexport class CompositionNode {\n    constructor(key, value, leftNode, rightNode) {\n        this.expiryTime = new Date(Date.now() + 10 * 60 * 1000);\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n    }\n    isValid() {\n        const currentTime = new Date(Date.now());\n        if (this.expiryTime < currentTime) {\n            CompositionBinaryTree.removeNodeFromTree(this.key);\n            return false;\n        }\n        return true;\n    }\n    saveToCache(data) {\n        this.value.cached = data;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        const LeftNode = node.leftNode;\n        const RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        // else if (node.key == passedNode.key && node.key != \"\"){\n        //     node.currentNode = passedNode;\n        // }\n        else {\n            this.isValid();\n            node = passedNode;\n            return node;\n        }\n        node.height =\n            1 +\n                Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        const balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (passedNode.key < node.leftNode.key) {\n                    return this.rightRotate(node);\n                }\n                else if (passedNode.key > node.leftNode.key) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    return this.rightRotate(node);\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (passedNode.key > node.rightNode.key) {\n                    return this.leftRotate(node);\n                }\n                else if (passedNode.key < node.rightNode.key) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    return this.leftRotate(node);\n                }\n            }\n        }\n        this.isValid();\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            const x = y.leftNode;\n            if (x) {\n                const T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height =\n                    Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height =\n                    Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            const y = x.rightNode;\n            if (y) {\n                const T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode)) + 1;\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key && node.isValid()) {\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        if (passedNode.leftNode == null) {\n            const temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            const temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            const immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    countNodeBelow(root) {\n        if (root == null) {\n            return 0;\n        }\n        //recursive call to left child and right child and\n        // add the result of these with 1 ( 1 for counting the root)\n        return (1 +\n            this.countNodeBelow(root.leftNode) +\n            this.countNodeBelow(root.rightNode));\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","import { BaseUrl } from \"../app\";\nexport class Concept {\n    constructor(id, userId, typeId, categoryId, referentId, characterValue, accessId, isNew = false, entryTimeStamp, updatedTimeStamp, typeCharacter) {\n        this.count = 0;\n        this.typeCharacter = \"\";\n        this.isComposition = false;\n        this.isTemp = false;\n        this.isSynced = false;\n        // applicationId: number = BaseUrl.BASE_RANDOMIZER;\n        this.applicationId = BaseUrl.getRandomizer();\n        this.x = 0;\n        this.y = 0;\n        this.id = id;\n        this.userId = userId;\n        this.typeId = typeId;\n        this.ghostId = id;\n        this.categoryId = categoryId;\n        this.referentId = referentId;\n        this.characterValue = `${characterValue}`;\n        this.accessId = accessId;\n        this.typeCharacter = typeCharacter;\n        this.type = null;\n        this.isNew = isNew;\n        this.entryTimeStamp = entryTimeStamp;\n        this.updatedTimeStamp = updatedTimeStamp;\n        // ConceptsData.AddConcept(this);\n    }\n    getType() {\n        console.log(this.typeId);\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { removeFromDatabase, UpdateToDatabase } from \"../Database/indexeddb\";\nimport { BinaryTree } from \"./BinaryTree\";\nimport { BinaryCharacterTree } from \"./BinaryCharacterTree\";\nimport { BinaryTypeTree } from \"./BinaryTypeTree\";\nimport { CreateDefaultConcept } from \"../Services/CreateDefaultConcept\";\nimport { sendMessage, serviceWorker } from \"../app\";\nexport class ConceptsData {\n    constructor() {\n        this.name = \"conceptsArray\";\n    }\n    static CheckContains(concept) {\n        var contains = false;\n        for (var i = 0; i < this.conceptsArray.length; i++) {\n            if (this.conceptsArray[i].id == concept.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static AddNpc(id) {\n        if (!this.NPC.includes(id)) {\n            if (this.NPC.length > 10) {\n                this.NPC = [];\n            }\n            this.NPC.push(id);\n        }\n    }\n    static GetNpc(id) {\n        if (this.NPC.includes(id)) {\n            return true;\n        }\n        return false;\n    }\n    static AddConceptToStorage(concept) {\n        if (concept.id > 0) {\n            UpdateToDatabase(\"concept\", concept);\n        }\n    }\n    static GetConceptBulkData(ids, connectionArray, remainingIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield BinaryTree.getConceptListFromIds(ids, connectionArray, remainingIds);\n        });\n    }\n    static AddConcept(concept) {\n        if (serviceWorker) {\n            const res = sendMessage('ConceptsData__AddConcept', { concept }); // is async function\n            // console.log('data received from sw', res)\n            // return res.data // remove comment when this function is async\n        }\n        if (concept.id > 0) {\n            // console.log(\"added the concept to the tree\", concept);\n            //var contains = this.CheckContains(concept);\n            // this.conceptDictionary[concept.id] = concept;\n            //    if(contains){\n            //   this.RemoveConcept(concept);\n            //  }\n            //UpdateToDatabase(\"concept\",concept);\n            //IndexDbUpdate.UpdateConceptIndexDb(concept);\n            BinaryTree.addConceptToTree(concept);\n            BinaryTypeTree.addConceptToTree(concept);\n            //BinaryCharacterTree.addConceptToTree(concept);\n        }\n    }\n    static AddConceptToMemory(concept) {\n        if (concept.id > 0) {\n            //var contains = this.CheckContains(concept);\n            // this.conceptDictionary[concept.id] = concept;\n            //    if(contains){\n            //   this.RemoveConcept(concept);\n            //  }\n            BinaryTree.addConceptToTree(concept);\n            BinaryTypeTree.addConceptToTree(concept);\n            // BinaryCharacterTree.addConceptToTree(concept);\n        }\n    }\n    static AddConceptTemporary(concept) {\n        var contains = this.CheckContains(concept);\n        this.conceptDictionary[concept.id] = concept;\n        if (contains) {\n            this.RemoveConcept(concept);\n        }\n        this.conceptsArray.push(concept);\n    }\n    static RemoveConcept(concept) {\n        for (var i = 0; i < this.conceptsArray.length; i++) {\n            if (this.conceptsArray[i].id == concept.id) {\n                this.conceptsArray.splice(i, 1);\n            }\n        }\n        removeFromDatabase(\"concept\", concept.id);\n    }\n    static GetConcept(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (serviceWorker) {\n                const res = yield sendMessage('ConceptsData__GetConcept', { id });\n                // console.log('data received from sw', res)\n                return res.data;\n            }\n            var myConcept = CreateDefaultConcept();\n            var node = yield BinaryTree.getNodeFromTree(id);\n            if (node === null || node === void 0 ? void 0 : node.value) {\n                var returnedConcept = node.value;\n                if (returnedConcept) {\n                    myConcept = returnedConcept;\n                    // if(myConcept.count > IndexDbUpdate.MIN_USE_FOR_INDEX_DB){\n                    //     IndexDbUpdate.UpdateConceptIndexDb(myConcept);\n                    // }\n                }\n            }\n            return myConcept;\n        });\n    }\n    static GetConceptByCharacter(characterValue) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultConcept();\n            var Node = BinaryCharacterTree.getNodeFromTree(characterValue);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptByCharacterUpdated(characterValue) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultConcept();\n            var Node = BinaryCharacterTree.getNodeFromTree(characterValue);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptByCharacterAndTypeLocal(character_value, typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultConcept();\n            //var Node = await BinaryCharacterTree.getCharacterAndTypeFromTree(character_value,typeId);\n            concept = yield BinaryTypeTree.getTypeVariantsWithCharacterValueNew(character_value, typeId);\n            // if(Node){\n            //     concept =  Node.value;\n            //     console.log(\"found the output\");\n            //     console.log(concept);\n            // }\n            return concept;\n        });\n    }\n    static GetConceptByCharacterAndCategoryLocal(character_value, categoryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultConcept();\n            var Node = yield BinaryCharacterTree.getCharacterAndCategoryFromTree(character_value, categoryId);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptsByTypeId(typeId) {\n        var myConcept;\n        let ConceptList = [];\n        myConcept = null;\n        for (var i = 0; i < this.conceptsArray.length; i++) {\n            if (this.conceptsArray[i].typeId == typeId) {\n                ConceptList.push(this.conceptsArray[i]);\n            }\n        }\n        return ConceptList;\n    }\n    static GetConceptsByTypeIdAndUser(typeId, userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (serviceWorker) {\n                const res = yield sendMessage('GetConceptsByTypeIdAndUser', { typeId, userId });\n                // console.log('data received from sw', res)\n                return res.data;\n            }\n            let ConceptList = [];\n            ConceptList = yield BinaryTypeTree.getTypeVariantsFromTreeWithUserIdNew(typeId, userId);\n            return ConceptList;\n        });\n    }\n    static GetBinaryCharacterTree() {\n        return BinaryCharacterTree.characterRoot;\n    }\n    getName() {\n        return this.name;\n    }\n}\nConceptsData.conceptsArray = [];\nConceptsData.NPC = [];\nConceptsData.conceptDictionary = [];\n","import { CreateDefaultConcept } from \"../Services/CreateDefaultConcept\";\nimport { BaseUrl } from \"./BaseUrl\";\nexport class Connection {\n    constructor(id = 0, ofTheConceptId, toTheConceptId, userId, typeId, orderId, accessId) {\n        this.count = 0;\n        this.isTemp = false;\n        this.toUpdate = false;\n        // applicationId: number = BaseUrl.BASE_RANDOMIZER;\n        this.applicationId = BaseUrl.getRandomizer();\n        this.type = CreateDefaultConcept();\n        this.ofConcept = CreateDefaultConcept();\n        this.toConcept = CreateDefaultConcept();\n        this.id = id;\n        this.ofTheConceptId = ofTheConceptId;\n        this.toTheConceptId = toTheConceptId;\n        this.userId = userId;\n        this.typeId = typeId;\n        this.ghostId = id;\n        this.orderId = orderId;\n        this.accessId = accessId;\n        this.entryTimeStamp = new Date();\n        this.terminationDateTime = new Date();\n        this.localSyncTime = new Date();\n        this.typeCharacter = \"\";\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"../IdentifierFlags\";\nimport { ConnectionNode } from \"./ConnectionNode\";\nexport class ConnectionBinaryTree {\n    static addNodeToTree(node) {\n        try {\n            if (this.connectionroot == null) {\n                this.connectionroot = node;\n                return this.connectionroot;\n            }\n            else {\n                this.connectionroot = this.connectionroot.addNode(node, this.connectionroot, this.connectionroot.height);\n            }\n        }\n        catch (error) {\n            console.log(\"This is the error in making the tree\", error);\n            throw error;\n        }\n    }\n    static addConnectionToTree(connection) {\n        let node = new ConnectionNode(connection.id, connection, null, null);\n        this.addNodeToTree(node);\n    }\n    static traverse() {\n        var _a;\n        return (_a = this.connectionroot) === null || _a === void 0 ? void 0 : _a.traverse(this.connectionroot);\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isConnectionLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(ConnectionBinaryTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connectionroot) {\n                this.connectionroot = this.connectionroot.removeNode(this.connectionroot, id);\n            }\n        });\n    }\n    static getNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.connectionroot) {\n                    let Node = this.connectionroot.getFromNode(id, this.connectionroot);\n                    return Node;\n                }\n                return this.connectionroot;\n            }\n            catch (ex) {\n                console.log(\"this is the getNodeFromTree\", id, this.connectionroot);\n            }\n        });\n    }\n    static getConnectionListFromIds(ids, connectionArray, remainingIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connectionroot) {\n                this.connectionroot.checkIfIdsInNode(this.connectionroot, ids, connectionArray, remainingIds);\n            }\n        });\n    }\n}\nConnectionBinaryTree.connectionroot = null;\n","import { dispatchIdEvent } from \"../../app\";\nexport class ConnectionNode {\n    constructor(key, value, leftNode, rightNode) {\n        this.leftNode = null;\n        this.rightNode = null;\n        this.variants = [];\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n        this.currentNode = null;\n    }\n    addCurrentNode(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        if (passedNode.value.typeId != node.value.typeId) {\n            node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        }\n        return node;\n    }\n    addCurrentNodeType(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        let contains = false;\n        if (passedNode.value.id == node.value.id) {\n            contains = true;\n        }\n        for (let i = 0; i < node.variants.length; i++) {\n            if (node.variants[i].value.id == passedNode.value.id) {\n                contains = true;\n            }\n        }\n        if (!contains) {\n            node.variants.push(passedNode);\n        }\n        //node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        return node;\n    }\n    getMax(a, b) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n    addNode(passedNode, node, height) {\n        // try{\n        if (node == null) {\n            //node = passedNode;\n            //ConnectionBinaryTree.connectionAll.push(node.value);\n            return passedNode;\n        }\n        let LeftNode = node.leftNode;\n        let RightNode = node.rightNode;\n        if (passedNode.key < node.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (passedNode.key > node.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        // else if (node.key == passedNode.key && node.key != \"\"){\n        //     node.currentNode = passedNode;\n        // }\n        else {\n            return node;\n        }\n        node.height = 1 + this.getMax(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        let balancingFactor = this.getBalanceFactor(node);\n        // this is left heavy\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (this.getBalanceFactor(node.leftNode) >= 0) {\n                    return this.rightRotate(node);\n                }\n                if (this.getBalanceFactor(node.leftNode) < 0) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    return this.rightRotate(node);\n                }\n            }\n        }\n        // this is right heavy\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (this.getBalanceFactor(node.rightNode) <= 0) {\n                    return this.leftRotate(node);\n                }\n                if (this.getBalanceFactor(node.rightNode) > 0) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    return this.leftRotate(node);\n                }\n            }\n        }\n        return node;\n        // }\n        // catch(error){\n        //     console.log(\"this is the error in binary tree making\", error, passedNode, node, height);\n        //     //throw error;\n        // }\n    }\n    addTypeNode(passedNode, node, height) {\n        let debugFlag = false;\n        if (passedNode.value.typeId != 0) {\n            // if(passedNode.value.characterValue == \"Default\"){\n            //     console.log(\"default here\");\n            //     debugFlag = true;\n            // }\n            if (node == null) {\n                if (debugFlag) {\n                    console.log(\"equal here\", node);\n                }\n                node = passedNode;\n                return node;\n            }\n            let LeftNode = node.leftNode;\n            let RightNode = node.rightNode;\n            if (node.key > passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"left  here\", node);\n                }\n                node.leftNode = this.addTypeNode(passedNode, LeftNode, height);\n            }\n            else if (node.key < passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"right here\", node, RightNode);\n                }\n                node.rightNode = this.addTypeNode(passedNode, RightNode, height);\n            }\n            else {\n                if (debugFlag) {\n                    console.log(\"else here\", node, passedNode);\n                }\n                if (node.key == passedNode.key && node.key != 0) {\n                    node.addCurrentNodeType(passedNode, node);\n                }\n                return node;\n            }\n            node.height = 1 + this.getMax(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n            if (debugFlag) {\n                console.log(\"height here\", node.height);\n            }\n            let balancingFactor = this.getBalanceFactor(node);\n            if (debugFlag) {\n                console.log(\"balancingFactor here\", balancingFactor);\n            }\n            if (balancingFactor > 1) {\n                if (node.leftNode) {\n                    if (passedNode.key < node.leftNode.key) {\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 1 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key > node.leftNode.key) {\n                        node.leftNode = this.leftRotate(node.leftNode);\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 2 \", returner);\n                        }\n                        return returner;\n                    }\n                }\n            }\n            if (balancingFactor < -1) {\n                if (node.rightNode) {\n                    if (passedNode.key > node.rightNode.key) {\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 3 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key < node.rightNode.key) {\n                        node.rightNode = this.rightRotate(node.rightNode);\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here4 \", returner, node);\n                        }\n                        return returner;\n                    }\n                }\n            }\n        }\n        else {\n            if (debugFlag) {\n                console.log(\"what here\", node);\n            }\n        }\n        if (debugFlag) {\n            console.log(\"returning here 6\", node);\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = this.getMax(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = this.getMax(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            console.log(\"this is the error in right rotation\", y, x);\n            throw new Error(\"Cannot perform right rotation: left node is null.\");\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = this.getMax(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                y.height = this.getMax(this.getHeight(y.leftNode), this.getHeight(x.rightNode)) + 1;\n                return y;\n            }\n            console.log(\"this is the error in left rotation\", x, y);\n            throw new Error(\"Cannot perform left rotation: right node is null.\");\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        try {\n            if (node) {\n                // console.log(\"this is the node test\", id, node, node.leftNode, node.rightNode);\n                if (id == node.key) {\n                    if (node.value.count) {\n                        node.value.count++;\n                    }\n                    else {\n                        node.value.count = 1;\n                    }\n                    return node;\n                }\n                else if (id < node.key) {\n                    return this.getFromNode(id, node.leftNode);\n                }\n                else if (id > node.key) {\n                    return this.getFromNode(id, node.rightNode);\n                }\n                return node;\n            }\n        }\n        catch (exception) {\n            console.log(\"this is the exception\", id, node, node === null || node === void 0 ? void 0 : node.leftNode, node === null || node === void 0 ? void 0 : node.rightNode);\n        }\n        return node;\n    }\n    getCharacterFromNode(value, node) {\n        if (node) {\n            if (value == node.key) {\n                return node;\n            }\n            else if (value < node.key) {\n                return this.getCharacterFromNode(value, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getCharacterFromNode(value, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    checkIfIdsInNode(node, ids, connectionArray, remainingIds) {\n        if (node) {\n            if (ids.includes(node.key)) {\n                connectionArray.push(node.value);\n                //remainingIds[node.key] = true;\n                let index = ids.indexOf(node.key);\n                ids.splice(index, 1);\n            }\n            if (node.leftNode) {\n                this.checkIfIdsInNode(node.leftNode, ids, connectionArray, remainingIds);\n            }\n            if (node.rightNode) {\n                this.checkIfIdsInNode(node.rightNode, ids, connectionArray, remainingIds);\n            }\n        }\n    }\n    traverse(node) {\n        let count = 0;\n        if (node) {\n            count = count + 1;\n            if (node === null || node === void 0 ? void 0 : node.leftNode) {\n                count += this.traverse(node.leftNode);\n            }\n            if (node.rightNode) {\n                count += this.traverse(node.rightNode);\n            }\n        }\n        return count;\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        // if(passedNode.variants.length > 0){\n        //     if(passedNode.value.id == id ){\n        //     }\n        //     let newNode = passedNode.variants[0];\n        //     if(newNode){\n        //         passedNode.value = newNode.value;\n        //         passedNode.key = newNode.key;\n        //         passedNode.currentNode = newNode.currentNode;\n        //         return passedNode;\n        //     }\n        // }\n        /**\n         * This is dispatched incase the connection is deleted and others are listening\n         */\n        let event = new Event(`${passedNode.value.ofTheConceptId}`);\n        // dispatchEvent(event);\n        dispatchIdEvent(passedNode.value.ofTheConceptId);\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    removeNodeWithVariants(passedNode, typeIdentifier, conceptId) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > typeIdentifier) {\n            passedNode.leftNode = this.removeNodeWithVariants(passedNode.leftNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        else if (passedNode.key < typeIdentifier) {\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        if (passedNode.variants.length > 0) {\n            //condition if the main node is equal to the value\n            if (passedNode.value.id == conceptId) {\n                let newNode = passedNode.variants[0];\n                if (newNode) {\n                    passedNode.value = newNode.value;\n                    passedNode.key = newNode.key;\n                    passedNode.currentNode = newNode.currentNode;\n                    passedNode.variants.splice(0, 1);\n                    return passedNode;\n                }\n            }\n            else {\n                // in the condition that the main node is not equal to the checking value \n                for (let i = 0; i < passedNode.variants.length; i++) {\n                    if (conceptId == passedNode.variants[i].value.id) {\n                        passedNode.variants.splice(i, 1);\n                        return passedNode;\n                    }\n                }\n            }\n        }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, immediateSuccessor.key, conceptId);\n            return passedNode;\n        }\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","import { NodePrimitive } from \"./NodePrimitive\";\nexport class ConnectionOfNode extends NodePrimitive {\n    constructor(key, value, leftNode, rightNode) {\n        super(key, value, leftNode, rightNode);\n        this.key = \"\";\n        this.value = [];\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            //node= passedNode;\n            // let event = new Event(`${passedNode.key}`);\n            // dispatchEvent(event);\n            return passedNode;\n        }\n        let LeftNode = node.leftNode;\n        let RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        else {\n            return node;\n        }\n        node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        let balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (this.getBalanceFactor(node.leftNode) >= 0) {\n                    let returner = this.rightRotate(node);\n                    return returner;\n                }\n                if (this.getBalanceFactor(node.leftNode) < 0) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    let returner = this.rightRotate(node);\n                    return returner;\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (this.getBalanceFactor(node.rightNode) <= 0) {\n                    let returner = this.leftRotate(node);\n                    return returner;\n                }\n                if (this.getBalanceFactor(node.rightNode) > 0) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    let returner = this.leftRotate(node);\n                    return returner;\n                }\n            }\n        }\n        return node;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { dispatchIdEvent } from \"../../app\";\nimport { ConnectionOfNode } from \"./ConnectionOfNode\";\n/**\n * This is a binary tree that is used to store the reference to the main connection of the concept.\n */\nexport class ConnectionOfTheTree {\n    static CreateCompositionKey(ofTheConceptId, typeId) {\n        return ofTheConceptId;\n    }\n    static GetConnectionByOfTheConceptAndTypeId(ofTheConceptId, typeId) {\n        let key = this.CreateCompositionKey(ofTheConceptId, typeId);\n        if (this.node) {\n            let existingNode = this.node.getFromNode(key, this.node);\n            if (existingNode) {\n                return existingNode.value;\n            }\n        }\n        return null;\n    }\n    /**\n     * This function lets you add a connection by composite key with of the concept id and type id.\n     * This function checks if the connection already exists and then updates in the case that it does not\n     * If the connection of the concept id and type id combination is encountered first time then a node is created.\n     * @param connection connection that needs to be added.\n     */\n    static addConnection(connection) {\n        if (connection.id > 0) {\n            let key = this.CreateCompositionKey(connection.ofTheConceptId, connection.typeId);\n            if (this.node) {\n                let existingNode = this.node.getFromNode(key, this.node);\n                if (existingNode) {\n                    let connectionList = existingNode === null || existingNode === void 0 ? void 0 : existingNode.value;\n                    if (connectionList.length == 0) {\n                        existingNode.value = [];\n                    }\n                    if (!connectionList.includes(connection.id)) {\n                        connectionList.push(connection.id);\n                    }\n                }\n                else {\n                    let list = [];\n                    list.push(connection.id);\n                    let connectionNode = new ConnectionOfNode(key, list, null, null);\n                    this.addNodeToTree(connectionNode);\n                }\n            }\n            else {\n                let list = [];\n                list.push(connection.id);\n                let connectionNode = new ConnectionOfNode(key, list, null, null);\n                this.addNodeToTree(connectionNode);\n            }\n            let event = new Event(`${key}`);\n            // console.log(\"dispatched the of the concecpt event\", event);\n            // dispatchEvent(event);\n            dispatchIdEvent(key);\n        }\n        else {\n            console.log(\"cannot insert key id with  n 0 to the connection tree\", connection);\n        }\n    }\n    /**\n     * This is a function to add the connectionNode to the existing tree\n     * @param connectionOfNode This is the node that needs to be added to the tree.\n     * @returns ConnectionOfNode\n     */\n    static addNodeToTree(connectionOfNode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.node == null) {\n                this.node = connectionOfNode;\n                // let event = new Event(`${this.node.key}`);\n                // console.log(\"dispatched the of the concecpt event\", event);\n                // dispatchEvent(event);\n                return this.node;\n            }\n            else {\n                this.node = this.node.addNode(connectionOfNode, this.node, this.node.height);\n            }\n            return this.node;\n        });\n    }\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.node) {\n                this.node = this.node.removeNode(this.node, id);\n            }\n        });\n    }\n}\nConnectionOfTheTree.node = null;\n","import { NodePrimitive } from \"./NodePrimitive\";\nexport class ConnectionTypeNode extends NodePrimitive {\n    constructor(key, value, leftNode, rightNode) {\n        super(key, value, leftNode, rightNode);\n        this.key = \"\";\n        this.value = [];\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        let LeftNode = node.leftNode;\n        let RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        else {\n            return node;\n        }\n        node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        let balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (passedNode.key < node.leftNode.key) {\n                    let returner = this.rightRotate(node);\n                    return returner;\n                }\n                else if (passedNode.key > node.leftNode.key) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    let returner = this.rightRotate(node);\n                    return returner;\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (passedNode.key > node.rightNode.key) {\n                    let returner = this.leftRotate(node);\n                    return returner;\n                }\n                else if (passedNode.key < node.rightNode.key) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    let returner = this.leftRotate(node);\n                    return returner;\n                }\n            }\n        }\n        return node;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionTypeNode } from \"./ConnectionTypeNode\";\nexport class ConnectionTypeTree {\n    static CreateCompositionKey(typeId) {\n        return typeId;\n    }\n    /**\n     * This is a function to add the connectionNode to the existing tree\n     * @param connectionOfNode This is the node that needs to be added to the tree.\n     * @returns ConnectionOfNode\n     */\n    static addNodeToTree(connectionOfNode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connectionTypeRoot == null) {\n                this.connectionTypeRoot = connectionOfNode;\n                return this.connectionTypeRoot;\n            }\n            else {\n                this.connectionTypeRoot = this.connectionTypeRoot.addNode(connectionOfNode, this.connectionTypeRoot, this.connectionTypeRoot.height);\n            }\n            return this.connectionTypeRoot;\n        });\n    }\n    /**\n     * This function lets you add a connection by composite key with of the concept id and type id.\n     * This function checks if the connection already exists and then updates in the case that it does not\n     * If the connection of the concept id and type id combination is encountered first time then a node is created.\n     * @param connection connection that needs to be added.\n     */\n    static addConnectionToTree(connection) {\n        if (connection.id > 0) {\n            let key = this.CreateCompositionKey(connection.typeId);\n            if (this.connectionTypeRoot) {\n                // let event = new Event(`${key}`);\n                // // console.log(\"dispatched the of the concecpt event\", event);\n                // dispatchEvent(event);\n                let existingNode = this.connectionTypeRoot.getFromNode(key, this.connectionTypeRoot);\n                if (existingNode) {\n                    let connectionList = existingNode === null || existingNode === void 0 ? void 0 : existingNode.value;\n                    if (connectionList.length == 0) {\n                        existingNode.value = [];\n                    }\n                    if (!connectionList.includes(connection.id)) {\n                        connectionList.push(connection.id);\n                    }\n                }\n                else {\n                    let list = [];\n                    list.push(connection.id);\n                    let connectionNode = new ConnectionTypeNode(key, list, null, null);\n                    this.addNodeToTree(connectionNode);\n                }\n            }\n            else {\n                let list = [];\n                list.push(connection.id);\n                let connectionNode = new ConnectionTypeNode(key, list, null, null);\n                this.addNodeToTree(connectionNode);\n            }\n        }\n        else {\n            console.log(\"cannot insert key id with  n 0 to the connection tree\", connection);\n        }\n    }\n    // static async removeNodeFromTree(id:number){\n    //     if(this.connectionTypeRoot){\n    //         this.connectionTypeRoot = this.connectionTypeRoot.removeNode(this.connectionTypeRoot,id);\n    //     }\n    //   }\n    // commented\n    // static getNodeFromTree(id:number){\n    //     if(this.connectionTypeRoot){\n    //         let Node = this.connectionTypeRoot.getFromNode(id, this.connectionTypeRoot);\n    //         return Node;\n    //     }\n    //     return this.connectionTypeRoot;\n    // }\n    static GetConnectionByOfTheConceptAndTypeId(ofTheConceptId, typeId) {\n        let key = this.CreateCompositionKey(typeId);\n        if (this.connectionTypeRoot) {\n            let existingNode = this.connectionTypeRoot.getFromNode(key, this.connectionTypeRoot);\n            if (existingNode) {\n                return existingNode.value;\n            }\n        }\n        return null;\n    }\n}\nConnectionTypeTree.connectionTypeRoot = null;\n","export class NodePrimitive {\n    constructor(key, value, leftNode, rightNode) {\n        this.key = \"\";\n        this.value = [];\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key) {\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode)) + 1;\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        // if(passedNode.variants.length > 0){\n        //     if(passedNode.value.id == id ){\n        //     }\n        //     var newNode = passedNode.variants[0];\n        //     if(newNode){\n        //         passedNode.value = newNode.value;\n        //         passedNode.key = newNode.key;\n        //         passedNode.currentNode = newNode.currentNode;\n        //         return passedNode;\n        //     }\n        // }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { AccessTracker } from \"../AccessTracker/accessTracker\";\nimport { sendMessage, serviceWorker } from \"../app\";\nimport { removeFromDatabase, UpdateToDatabase } from \"../Database/indexeddb\";\nimport { Connection } from \"./Connection\";\nimport { ConnectionBinaryTree } from \"./ConnectionBinaryTree/ConnectionBinaryTree\";\nimport { ConnectionOfTheTree } from \"./ConnectionBinaryTree/ConnectionOfTheTree\";\nimport { ConnectionTypeTree } from \"./ConnectionBinaryTree/ConnectionTypeTree\";\nexport class ConnectionData {\n    constructor() {\n        this.name = \"Connection Array\";\n    }\n    static CheckContains(connection) {\n        let contains = false;\n        for (let i = 0; i < this.connectionArray.length; i++) {\n            if (this.connectionArray[i].id == connection.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static AddConnectionToStorage(connection) {\n        UpdateToDatabase(\"connection\", connection);\n    }\n    static AddConnection(connection) {\n        //    var contains = this.CheckContains(connection);\n        //     if(contains){\n        //         this.RemoveConnection(connection);\n        //     }\n        //     if(connection.id != 0 || connection.isTemp){\n        //         storeToDatabase(\"connection\",connection);\n        //     }\n        //     this.connectionArray.push(connection);\n        // if(!connection.isTemp){\n        //UpdateToDatabase(\"connection\", connection);\n        try {\n            ConnectionBinaryTree.addConnectionToTree(connection);\n            ConnectionTypeTree.addConnectionToTree(connection);\n            ConnectionOfTheTree.addConnection(connection);\n        }\n        catch (error) {\n            console.log(\"this is the error in making the connection\");\n            throw error;\n        }\n    }\n    static AddConnectionToMemory(connection) {\n        if (!connection.isTemp) {\n            ConnectionBinaryTree.addConnectionToTree(connection);\n            ConnectionTypeTree.addConnectionToTree(connection);\n            ConnectionOfTheTree.addConnection(connection);\n        }\n    }\n    static AddToDictionary(connection) {\n        this.connectionDictionary[connection.id] = connection;\n    }\n    static RemoveConnection(connection) {\n        //    for(var i=0; i<this.connectionArray.length; i++){\n        //     if(this.connectionArray[i].id == connection.id){\n        //         this.connectionArray.splice(i, 1);\n        //     }\n        //    }\n        if (connection.id != 0) {\n            removeFromDatabase(\"connection\", connection.id);\n            ConnectionBinaryTree.removeNodeFromTree(connection.id);\n            // ConnectionTypeTree.removeTypeConcept(connection.typeId, connection.id);\n            ConnectionOfTheTree.removeNodeFromTree(connection.id);\n        }\n    }\n    static GetConnectionTypeOfTree() {\n        ConnectionOfTheTree.node;\n    }\n    static GetConnectionByOfTheConceptAndType(ofTheConceptId, typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (serviceWorker) {\n                const res = yield sendMessage(\"ConnectionData__GetConnectionByOfTheConceptAndType\", { ofTheConceptId, typeId });\n                // console.log(\"data received from sw\", res);\n                return res.data;\n            }\n            let connections = ConnectionOfTheTree.GetConnectionByOfTheConceptAndTypeId(ofTheConceptId, typeId);\n            if (connections) {\n                return connections;\n            }\n            return [];\n        });\n    }\n    static GetConnectionByOfType(ofTheConceptId, typeId) {\n        let connections = ConnectionTypeTree.GetConnectionByOfTheConceptAndTypeId(ofTheConceptId, typeId);\n        if (connections) {\n            return connections;\n        }\n        return [];\n    }\n    static GetConnectionTree() {\n        return ConnectionBinaryTree.connectionroot;\n    }\n    static GetConnectionTypeTree() {\n        return ConnectionTypeTree.connectionTypeRoot;\n    }\n    static GetConnectionBulkData(ids, connectionArray, remainingIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield ConnectionBinaryTree.getConnectionListFromIds(ids, connectionArray, remainingIds);\n        });\n    }\n    static GetConnection(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Increment Connection\n            AccessTracker.incrementConnection(id);\n            if (serviceWorker) {\n                const res = yield sendMessage('ConnectionData__GetConnection', { id });\n                // console.log('data received from sw', res)\n                return res.data;\n            }\n            //    var  myConcept: Connection|null;\n            //    myConcept = null;\n            //     for(var i=0; i<this.connectionArray.length; i++){\n            //         if(this.connectionArray[i].id == id){\n            //             myConcept = this.connectionArray[i];\n            //         }\n            //     }\n            //     return myConcept;\n            let myConnection = new Connection(0, 0, 0, 0, 0, 0, 0);\n            let node = yield ConnectionBinaryTree.getNodeFromTree(id);\n            if (node === null || node === void 0 ? void 0 : node.value) {\n                let returnedConcept = node.value;\n                if (returnedConcept) {\n                    myConnection = returnedConcept;\n                    //if(myConnection.count > IndexDbUpdate.MIN_USE_FOR_INDEX_DB){\n                    // IndexDbUpdate.UpdateConnectionIndexDb(myConnection);\n                    //}\n                }\n            }\n            // if(myConcept.id == 0 || myConcept == null){\n            //     for(var i=0; i<this.conceptsArray.length; i++){\n            //         if(this.conceptsArray[i].id == id){\n            //             myConcept = this.conceptsArray[i];\n            //         }\n            //     }\n            // }\n            return myConnection;\n        });\n    }\n    // commented\n    static GetConnectionsOfCompositionLocal(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (serviceWorker) {\n                const res = yield sendMessage(\"ConnectionData__GetConnectionsOfCompositionLocal\", { id });\n                // console.log(\"data received from sw\", res);\n                return res.data;\n            }\n            let connections = [];\n            try {\n                let connectionIds = [];\n                connectionIds = ConnectionData.GetConnectionByOfType(id, id);\n                for (let i = 0; i < connectionIds.length; i++) {\n                    let conn = yield ConnectionBinaryTree.getNodeFromTree(connectionIds[i]);\n                    if (conn) {\n                        connections.push(conn.value);\n                    }\n                }\n            }\n            catch (error) {\n                console.log(\"this is the error GetConnectionsOfCompositionLocal\", id, connections);\n            }\n            return connections;\n            //let node = await ConnectionTypeTree.getNodeFromTree(id);\n            // if(node?.value){\n            //     let returnedConnection = node.value;\n            //     if(returnedConnection){\n            //         let myConnection = returnedConnection as Connection;\n            //         connections.push(myConnection);\n            //         for(let i=0; i<node.variants.length;i++){\n            //             connections.push(node.variants[i].value);\n            //         }\n            //     }\n            // }\n            //return connections;\n        });\n    }\n    static GetConnectionsOfConcept(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (serviceWorker) {\n                const res = yield sendMessage(\"ConnectionData__GetConnectionsOfConcept\", { id });\n                // console.log(\"data received from sw\", res);\n                return res.data;\n            }\n            let connectionIds = [];\n            let connections = [];\n            connectionIds = yield ConnectionData.GetConnectionByOfTheConceptAndType(id, id);\n            for (let i = 0; i < connectionIds.length; i++) {\n                let conn = yield ConnectionBinaryTree.getNodeFromTree(connectionIds[i]);\n                if (conn) {\n                    connections.push(conn.value);\n                }\n            }\n            return connections;\n        });\n    }\n    getName() {\n        return this.name;\n    }\n}\nConnectionData.connectionArray = [];\nConnectionData.connectionDictionary = [];\n","export class FilterSearch {\n    constructor() {\n        this.type = \"\";\n        this.search = \"\";\n        this.logicoperator = \"=\";\n        this.index = 0;\n        this.composition = true;\n        this.name = \"\";\n        this.operateon = \"\";\n    }\n}\n","export class IdentifierFlags {\n}\nIdentifierFlags.isTypeLoaded = false;\nIdentifierFlags.isCharacterLoaded = false;\nIdentifierFlags.isDataLoaded = false;\nIdentifierFlags.isLocalDataLoaded = false;\nIdentifierFlags.isLocalCharacterLoaded = false;\nIdentifierFlags.isLocalTypeLoaded = false;\nIdentifierFlags.isConnectionLoaded = false;\nIdentifierFlags.isConnectionTypeLoaded = false;\nIdentifierFlags.isLocalConnectionLoaded = false;\n","import { BaseUrl } from \"../BaseUrl\";\nexport class LConcept {\n    constructor(id, userId, typeId, categoryId, accessId, characterValue, typeCharacter, isNew = false, entryTimeStamp, updatedTimeStamp, referentId) {\n        this.structureType = \"lconcept\";\n        this.isComposition = false;\n        this.isTemp = false;\n        this.isSynced = false;\n        // applicationId: number = BaseUrl.BASE_RANDOMIZER;\n        this.applicationId = BaseUrl.getRandomizer();\n        this.id = id;\n        this.userId = userId;\n        this.typeId = typeId;\n        this.ghostId = id;\n        this.categoryId = categoryId;\n        this.characterValue = characterValue;\n        this.accessId = accessId;\n        this.type = null;\n        this.isNew = isNew;\n        this.typeCharacter = typeCharacter;\n        this.entryTimeStamp = entryTimeStamp;\n        this.updatedTimeStamp = updatedTimeStamp;\n        this.isSynced = false;\n        this.referentId = referentId;\n        // ConceptsData.AddConcept(this);\n    }\n    getType() {\n        console.log(this.typeId);\n    }\n}\n","import { CreateDefaultConcept } from \"../../app\";\nimport { BaseUrl } from \"../BaseUrl\";\nexport class LConnection {\n    constructor(id, ofTheConceptId, toTheConceptId, typeId, orderId, accessId) {\n        this.isTemp = false;\n        // applicationId: number = BaseUrl.BASE_RANDOMIZER;\n        this.applicationId = BaseUrl.getRandomizer();\n        this.type = CreateDefaultConcept();\n        this.id = id;\n        this.ofTheConceptId = ofTheConceptId;\n        this.toTheConceptId = toTheConceptId;\n        this.typeId = typeId;\n        this.ghostId = id;\n        this.orderId = orderId;\n        this.typeCharacter = \"\";\n        this.accessId = accessId;\n        this.typeCharacter = \"\";\n        this.entryTimeStamp = new Date();\n        this.terminationDateTime = new Date();\n        this.localSyncTime = new Date();\n    }\n}\n","export class LNode {\n    constructor(key, value, leftNode, rightNode) {\n        this.variants = [];\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n        this.currentNode = null;\n    }\n    addCurrentNode(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        if (passedNode.value.typeId != node.value.typeId) {\n            node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        }\n        return node;\n    }\n    addCurrentNodeType(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        var contains = false;\n        for (let i = 0; i < node.variants.length; i++) {\n            if (node.variants[i].value.id == passedNode.value.id) {\n                contains = true;\n            }\n        }\n        if (!contains) {\n            node.variants.push(passedNode);\n        }\n        //node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        return node;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        var LeftNode = node.leftNode;\n        var RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        // else if (node.key == passedNode.key && node.key != \"\"){\n        //     node.currentNode = passedNode;\n        // }\n        else {\n            return node;\n        }\n        node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        let balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (passedNode.key < node.leftNode.key) {\n                    return this.rightRotate(node);\n                }\n                else if (passedNode.key > node.leftNode.key) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    return this.rightRotate(node);\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (passedNode.key > node.rightNode.key) {\n                    return this.leftRotate(node);\n                }\n                else if (passedNode.key < node.rightNode.key) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    return this.leftRotate(node);\n                }\n            }\n        }\n        return node;\n    }\n    addCharacterNode(passedNode, node, height) {\n        var debugFlag = false;\n        if (passedNode.value.characterValue != \"\") {\n            // if(passedNode.value.characterValue == \"Default\"){\n            //     console.log(\"default here\");\n            //     debugFlag = true;\n            // }\n            if (node == null) {\n                if (debugFlag) {\n                    console.log(\"equal here\", node);\n                }\n                node = passedNode;\n                return node;\n            }\n            // if (node.key == passedNode.key && node.key != \"\" ){\n            //     if(passedNode.value.characterValue == \"Default\"){\n            //         console.log(\"equal\");\n            //     }\n            //     node.currentNode = passedNode;\n            //     return node;\n            // }\n            var LeftNode = node.leftNode;\n            var RightNode = node.rightNode;\n            if (node.key > passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"left  here\", node);\n                }\n                node.leftNode = this.addCharacterNode(passedNode, LeftNode, height);\n            }\n            else if (node.key < passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"right here\", node, RightNode);\n                }\n                node.rightNode = this.addCharacterNode(passedNode, RightNode, height);\n            }\n            // else if (node.key == passedNode.key && node.key != \"\"){\n            //     node.currentNode = passedNode;\n            // }\n            else {\n                if (debugFlag) {\n                    console.log(\"else here\", node, passedNode);\n                }\n                if (node.key == passedNode.key && node.key != \"\" && node.value.id != passedNode.value.id) {\n                    // node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n                    node.addCurrentNodeType(passedNode, node);\n                }\n                return node;\n            }\n            node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n            if (debugFlag) {\n                console.log(\"height here\", node.height);\n            }\n            let balancingFactor = this.getBalanceFactor(node);\n            if (debugFlag) {\n                console.log(\"balancingFactor here\", balancingFactor);\n            }\n            if (balancingFactor > 1) {\n                if (node.leftNode) {\n                    if (passedNode.key < node.leftNode.key) {\n                        var returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 1 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key > node.leftNode.key) {\n                        node.leftNode = this.leftRotate(node.leftNode);\n                        var returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 2 \", returner);\n                        }\n                        return returner;\n                    }\n                }\n            }\n            if (balancingFactor < -1) {\n                if (node.rightNode) {\n                    if (passedNode.key > node.rightNode.key) {\n                        var returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 3 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key < node.rightNode.key) {\n                        node.rightNode = this.rightRotate(node.rightNode);\n                        var returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here4 \", returner, node);\n                        }\n                        return returner;\n                    }\n                }\n            }\n        }\n        else {\n            if (debugFlag) {\n                console.log(\"what here\", node);\n            }\n        }\n        if (debugFlag) {\n            console.log(\"returning here 6\", node);\n        }\n        return node;\n    }\n    addTypeNode(passedNode, node, height) {\n        var debugFlag = false;\n        if (passedNode.value.typeId != 0) {\n            // if(passedNode.value.characterValue == \"Default\"){\n            //     console.log(\"default here\");\n            //     debugFlag = true;\n            // }\n            if (node == null) {\n                if (debugFlag) {\n                    console.log(\"equal here\", node);\n                }\n                node = passedNode;\n                return node;\n            }\n            var LeftNode = node.leftNode;\n            var RightNode = node.rightNode;\n            if (node.key > passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"left  here\", node);\n                }\n                node.leftNode = this.addTypeNode(passedNode, LeftNode, height);\n            }\n            else if (node.key < passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"right here\", node, RightNode);\n                }\n                node.rightNode = this.addTypeNode(passedNode, RightNode, height);\n            }\n            else {\n                if (debugFlag) {\n                    console.log(\"else here\", node, passedNode);\n                }\n                if (node.key == passedNode.key && node.key != 0 && node.value.id != passedNode.value.id) {\n                    node.addCurrentNodeType(passedNode, node);\n                }\n                return node;\n            }\n            node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n            if (debugFlag) {\n                console.log(\"height here\", node.height);\n            }\n            let balancingFactor = this.getBalanceFactor(node);\n            if (debugFlag) {\n                console.log(\"balancingFactor here\", balancingFactor);\n            }\n            if (balancingFactor > 1) {\n                if (node.leftNode) {\n                    if (passedNode.key < node.leftNode.key) {\n                        var returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 1 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key > node.leftNode.key) {\n                        node.leftNode = this.leftRotate(node.leftNode);\n                        var returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 2 \", returner);\n                        }\n                        return returner;\n                    }\n                }\n            }\n            if (balancingFactor < -1) {\n                if (node.rightNode) {\n                    if (passedNode.key > node.rightNode.key) {\n                        var returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 3 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key < node.rightNode.key) {\n                        node.rightNode = this.rightRotate(node.rightNode);\n                        var returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here4 \", returner, node);\n                        }\n                        return returner;\n                    }\n                }\n            }\n        }\n        else {\n            if (debugFlag) {\n                console.log(\"what here\", node);\n            }\n        }\n        if (debugFlag) {\n            console.log(\"returning here 6\", node);\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode)) + 1;\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key) {\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    updateNodeSyncStatus(id, value, node) {\n        if (node) {\n            if (id == node.key) {\n                let lconcept = node.value;\n                lconcept.isSynced = value;\n                node.value = lconcept;\n                return node;\n            }\n            else if (id < node.key) {\n                return this.updateNodeSyncStatus(id, value, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.updateNodeSyncStatus(id, value, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    getCharacterFromNode(value, node) {\n        if (node) {\n            if (value == node.key) {\n                return node;\n            }\n            else if (value < node.key) {\n                return this.getCharacterFromNode(value, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getCharacterFromNode(value, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    getFromNodeWithCharacterAndType(value, typeId, node) {\n        value = `${value}`;\n        if (node) {\n            if (value == node.key) {\n                if (value == node.value.characterValue && typeId == node.value.typeId) {\n                    return node;\n                }\n                else {\n                    for (let i = 0; i < node.variants.length; i++) {\n                        if (node.variants[i].value.typeId == typeId) {\n                            return node.variants[i];\n                        }\n                    }\n                    // return this.getFromNodeWithCharacterAndType(value, typeId, node.currentNode);\n                }\n            }\n            else if (value < node.key) {\n                return this.getFromNodeWithCharacterAndType(value, typeId, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getFromNodeWithCharacterAndType(value, typeId, node.rightNode);\n            }\n            return null;\n        }\n        return node;\n    }\n    getFromNodeWithCharacterAndCategory(value, categoryId, node) {\n        value = `${value}`;\n        if (node) {\n            if (value == node.key) {\n                if (value == node.value.characterValue && categoryId == node.value.categoryId) {\n                    return node;\n                }\n                else {\n                    for (let i = 0; i < node.variants.length; i++) {\n                        if (node.variants[i].value.categoryId == categoryId) {\n                            return node.variants[i];\n                        }\n                    }\n                    // return this.getFromNodeWithCharacterAndType(value, typeId, node.currentNode);\n                }\n            }\n            else if (value < node.key) {\n                return this.getFromNodeWithCharacterAndCategory(value, categoryId, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getFromNodeWithCharacterAndCategory(value, categoryId, node.rightNode);\n            }\n            return null;\n        }\n        return node;\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        // if(passedNode.variants.length > 0){\n        //     if(passedNode.value.id == id ){\n        //     }\n        //     var newNode = passedNode.variants[0];\n        //     if(newNode){\n        //         passedNode.value = newNode.value;\n        //         passedNode.key = newNode.key;\n        //         passedNode.currentNode = newNode.currentNode;\n        //         return passedNode;\n        //     }\n        // }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            var immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    removeNodeWithVariants(passedNode, typeIdentifier, conceptId) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > typeIdentifier) {\n            passedNode.leftNode = this.removeNodeWithVariants(passedNode.leftNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        else if (passedNode.key < typeIdentifier) {\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        if (passedNode.variants.length > 0) {\n            //condition if the main node is equal to the value\n            if (passedNode.value.id == conceptId) {\n                var newNode = passedNode.variants[0];\n                if (newNode) {\n                    passedNode.value = newNode.value;\n                    passedNode.key = newNode.key;\n                    passedNode.currentNode = newNode.currentNode;\n                    passedNode.variants.splice(0, 1);\n                    return passedNode;\n                }\n            }\n            else {\n                // in the condition that the main node is not equal to the checking value \n                for (let i = 0; i < passedNode.variants.length; i++) {\n                    if (conceptId == passedNode.variants[i].value.id) {\n                        passedNode.variants.splice(i, 1);\n                        return passedNode;\n                    }\n                }\n            }\n        }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            var immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, immediateSuccessor.key, conceptId);\n            return passedNode;\n        }\n    }\n    countNodeBelow(root) {\n        if (root == null) {\n            return 0;\n        }\n        //recursive call to left child and right child and\n        // add the result of these with 1 ( 1 for counting the root)\n        return 1 + this.countNodeBelow(root.leftNode) + this.countNodeBelow(root.rightNode);\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"./../IdentifierFlags\";\nimport { LNode } from \"./../Local/LNode\";\nexport class LocalBinaryCharacterTree {\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isLocalCharacterLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(LocalBinaryCharacterTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static addNodeToTree(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.LocalCharacterRoot == null) {\n                this.LocalCharacterRoot = node;\n                return this.LocalCharacterRoot;\n            }\n            else {\n                this.LocalCharacterRoot = this.LocalCharacterRoot.addCharacterNode(node, this.LocalCharacterRoot, this.LocalCharacterRoot.height);\n            }\n            return this.LocalCharacterRoot;\n        });\n    }\n    static addConceptToTree(concept) {\n        if (concept.characterValue != \"\") {\n            var node = new LNode(concept.characterValue, concept, null, null);\n            this.addNodeToTree(node);\n        }\n    }\n    static getNodeFromTree(value) {\n        if (this.LocalCharacterRoot) {\n            var Node = this.LocalCharacterRoot.getCharacterFromNode(value, this.LocalCharacterRoot);\n            return Node;\n        }\n        return this.LocalCharacterRoot;\n    }\n    static getCharacterAndTypeFromTree(value, typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return null;\n            }\n            if (this.LocalCharacterRoot) {\n                var Node = this.LocalCharacterRoot.getFromNodeWithCharacterAndType(value, typeId, this.LocalCharacterRoot);\n                return Node;\n            }\n            return this.LocalCharacterRoot;\n        });\n    }\n    static getCharacterAndCategoryFromTree(value, categoryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return null;\n            }\n            if (this.LocalCharacterRoot) {\n                var Node = this.LocalCharacterRoot.getFromNodeWithCharacterAndCategory(value, categoryId, this.LocalCharacterRoot);\n                return Node;\n            }\n            return this.LocalCharacterRoot;\n        });\n    }\n    static removeConceptType(character, id) {\n        if (this.LocalCharacterRoot) {\n            this.LocalCharacterRoot = this.LocalCharacterRoot.removeNodeWithVariants(this.LocalCharacterRoot, character, id);\n        }\n    }\n}\nLocalBinaryCharacterTree.LocalCharacterRoot = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"../IdentifierFlags\";\nimport { LNode } from \"./../Local/LNode\";\nexport class LocalBinaryTree {\n    static addNodeToTree(node) {\n        if (this.root == null) {\n            this.root = node;\n            return this.root;\n        }\n        else {\n            this.root = this.root.addNode(node, this.root, this.root.height);\n        }\n    }\n    static addConceptToTree(concept) {\n        var node = new LNode(concept.id, concept, null, null);\n        var characterNode = new LNode(concept.characterValue, concept, null, null);\n        this.addNodeToTree(node);\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isLocalDataLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(LocalBinaryTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static getNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return null;\n            }\n            if (this.root) {\n                var Node = this.root.getFromNode(id, this.root);\n                return Node;\n            }\n            return null;\n        });\n    }\n    static getCharacterAndTypeFromTree(value, typeId) {\n        if (this.root) {\n            var Node = this.root.getFromNodeWithCharacterAndType(value, typeId, this.root);\n            return Node;\n        }\n        return this.root;\n    }\n    static updateSyncStatus(id) {\n        if (this.root) {\n            var Node = this.root.updateNodeSyncStatus(id, true, this.root);\n            return Node;\n        }\n        return this.root;\n    }\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                this.root = this.root.removeNode(this.root, id);\n            }\n        });\n    }\n}\nLocalBinaryTree.root = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"./../IdentifierFlags\";\nimport { LNode } from \"./LNode\";\nexport class LocalBinaryTypeTree {\n    static addNodeToTree(node) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.LocalTypeRoot == null) {\n                this.LocalTypeRoot = node;\n                return this.LocalTypeRoot;\n            }\n            else {\n                this.LocalTypeRoot = this.LocalTypeRoot.addTypeNode(node, this.LocalTypeRoot, this.LocalTypeRoot.height);\n            }\n            return this.LocalTypeRoot;\n        });\n    }\n    static addConceptToTree(concept) {\n        if (concept.typeId != 0) {\n            var node = new LNode(concept.typeId, concept, null, null);\n            this.addNodeToTree(node);\n        }\n    }\n    static removeConceptType(typeId, id) {\n        if (this.LocalTypeRoot) {\n            this.LocalTypeRoot = this.LocalTypeRoot.removeNodeWithVariants(this.LocalTypeRoot, typeId, id);\n        }\n    }\n    static getNodeFromTree(id) {\n        if (this.LocalTypeRoot) {\n            var Node = this.LocalTypeRoot.getFromNode(id, this.LocalTypeRoot);\n            return Node;\n        }\n        return this.LocalTypeRoot;\n    }\n    static getTypeVariantsFromTree(typeId) {\n        var Node = this.getNodeFromTree(typeId);\n        var concepts = [];\n        if (Node) {\n            concepts.push(Node === null || Node === void 0 ? void 0 : Node.value);\n            for (let i = 0; i < Node.variants.length; i++) {\n                concepts.push(Node.variants[i].value);\n            }\n            return concepts;\n        }\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isLocalTypeLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(LocalBinaryTypeTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static getTypeVariantsFromTreeWithUserId(typeId, userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concepts = [];\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return concepts;\n            }\n            var Node = this.getNodeFromTree(typeId);\n            if (Node) {\n                console.log(\"this is the node to type\", Node);\n                if (Node.value.userId == userId || Node.value.userId == 999) {\n                    concepts.push(Node === null || Node === void 0 ? void 0 : Node.value);\n                }\n                for (let i = 0; i < Node.variants.length; i++) {\n                    if (Node.variants[i].value.userId == userId || Node.value.userId == 999) {\n                        concepts.push(Node.variants[i].value);\n                    }\n                }\n            }\n            return concepts;\n        });\n    }\n}\nLocalBinaryTypeTree.LocalTypeRoot = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { removeFromDatabase, UpdateToDatabase } from \"../../Database/indexdblocal\";\nimport { LocalBinaryTree } from \"./LocalBinaryTree\";\nimport { LocalBinaryCharacterTree } from \"./LocalBinaryCharacterTree\";\nimport { LocalBinaryTypeTree } from \"./LocalBinaryTypeTree\";\nimport { CreateDefaultLConcept } from \"../../Services/Local/CreateDefaultLConcept\";\nimport { ConceptsData } from \"../ConceptData\";\nimport { LocalGhostIdTree } from \"./LocalGhostIdTree\";\nimport { LocalConnectionData } from \"./LocalConnectionData\";\nimport { LocalSyncData } from \"./LocalSyncData\";\nexport class LocalConceptsData {\n    constructor() {\n        this.name = \"conceptsArray\";\n    }\n    static AddConcept(concept) {\n        if (concept.id != 0) {\n            UpdateToDatabase(\"localconcept\", concept);\n            LocalBinaryTree.addConceptToTree(concept);\n            LocalBinaryCharacterTree.addConceptToTree(concept);\n            LocalBinaryTypeTree.addConceptToTree(concept);\n            this.localconceptsArray.push(concept);\n        }\n    }\n    static AddPermanentConcept(concept) {\n        if (concept.id != 0) {\n            LocalBinaryTree.removeNodeFromTree(concept.ghostId);\n            LocalBinaryCharacterTree.removeConceptType(concept.characterValue, concept.ghostId);\n            LocalBinaryTypeTree.removeConceptType(concept.typeId, concept.ghostId);\n            LocalGhostIdTree.addConceptToTree(concept);\n            let removeData = removeFromDatabase(\"localconcept\", concept.ghostId);\n            ConceptsData.AddConcept(concept);\n        }\n    }\n    static RemoveConcept(concept) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (concept.id != 0) {\n                    LocalBinaryTree.removeNodeFromTree(concept.ghostId);\n                    LocalBinaryCharacterTree.removeConceptType(concept.characterValue, concept.ghostId);\n                    LocalBinaryTypeTree.removeConceptType(concept.typeId, concept.ghostId);\n                    yield removeFromDatabase(\"localconcept\", concept.ghostId);\n                }\n            }\n            catch (error) {\n                throw error;\n            }\n        });\n    }\n    static RemoveConceptById(conceptId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let concept = yield LocalConceptsData.GetConcept(conceptId);\n                if (concept.id != 0) {\n                    LocalBinaryTree.removeNodeFromTree(conceptId);\n                    LocalBinaryCharacterTree.removeConceptType(concept.characterValue, concept.ghostId);\n                    LocalBinaryTypeTree.removeConceptType(concept.typeId, concept.ghostId);\n                    LocalSyncData.RemoveConcept(concept);\n                    // await removeFromDatabase(\"localconcept\", concept.ghostId);\n                }\n            }\n            catch (error) {\n                throw error;\n            }\n        });\n    }\n    static AddConceptToMemory(concept) {\n        if (concept.id != 0) {\n            LocalBinaryTree.addConceptToTree(concept);\n            LocalBinaryCharacterTree.addConceptToTree(concept);\n            LocalBinaryTypeTree.addConceptToTree(concept);\n        }\n    }\n    static GetConcept(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var myConcept = CreateDefaultLConcept();\n            var node = yield LocalBinaryTree.getNodeFromTree(id);\n            if (node === null || node === void 0 ? void 0 : node.value) {\n                var returnedConcept = node.value;\n                if (returnedConcept) {\n                    myConcept = returnedConcept;\n                }\n            }\n            return myConcept;\n        });\n    }\n    static UpdateConceptSyncStatus(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            LocalBinaryTree.updateSyncStatus(id);\n        });\n    }\n    static GetConceptByGhostId(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var myConcept = CreateDefaultLConcept();\n            var node = yield LocalGhostIdTree.getNodeFromTree(id);\n            if (node === null || node === void 0 ? void 0 : node.value) {\n                var returnedConcept = node.value;\n                if (returnedConcept) {\n                    myConcept = returnedConcept;\n                }\n            }\n            return myConcept;\n        });\n    }\n    static GetConceptByCharacter(characterValue) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultLConcept();\n            //  for(var i=0; i<this.conceptsArray.length; i++){\n            //      if(this.conceptsArray[i].characterValue == characterValue){\n            //         concept = this.conceptsArray[i];\n            //      }\n            //  }\n            var Node = LocalBinaryCharacterTree.getNodeFromTree(characterValue);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptByCharacterAndTypeLocal(character_value, typeId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultLConcept();\n            // let conceptList:Concept[] = await this.GetConceptsByTypeId(typeId);\n            // for(var i=0;i<conceptList.length; i++){\n            //     if(character_value == conceptList[i].characterValue){\n            //         concept = conceptList[i];\n            //     }\n            // }\n            var Node = yield LocalBinaryCharacterTree.getCharacterAndTypeFromTree(character_value, typeId);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptByCharacterAndCategoryLocal(character_value, categoryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var concept = CreateDefaultLConcept();\n            var Node = yield LocalBinaryCharacterTree.getCharacterAndCategoryFromTree(character_value, categoryId);\n            if (Node) {\n                concept = Node.value;\n            }\n            return concept;\n        });\n    }\n    static GetConceptsByTypeId(typeId) {\n        var myConcept;\n        let ConceptList = [];\n        myConcept = null;\n        for (var i = 0; i < this.localconceptsArray.length; i++) {\n            if (this.localconceptsArray[i].typeId == typeId) {\n                ConceptList.push(this.localconceptsArray[i]);\n            }\n        }\n        return ConceptList;\n    }\n    static GetConceptsByTypeIdAndUser(typeId, userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var myConcept;\n            let ConceptList = [];\n            // myConcept = null;\n            //  for(var i=0; i<this.conceptsArray.length; i++){\n            //      if(this.conceptsArray[i].typeId == typeId && this.conceptsArray[i].userId == userId){\n            //          ConceptList.push(this.conceptsArray[i]);\n            //      }\n            //  }\n            ConceptList = yield LocalBinaryTypeTree.getTypeVariantsFromTreeWithUserId(typeId, userId);\n            return ConceptList;\n        });\n    }\n    static ClearData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.localconceptsArray = [];\n            LocalConnectionData.connectionArray = [];\n        });\n    }\n    getName() {\n        return this.name;\n    }\n}\nLocalConceptsData.localconceptsArray = [];\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { UpdateToDatabase } from \"../../Database/indexdblocal\";\nimport { removeFromDatabase } from \"../../Database/indexdblocal\";\nimport { ConvertFromLConnectionToConnection } from \"../../Services/Local/ConvertFromLConnectionToConnection\";\nimport { ConnectionData } from \"../ConnectionData\";\nimport { IdentifierFlags } from \"../IdentifierFlags\";\nimport { LocalSyncData } from \"./LocalSyncData\";\nexport class LocalConnectionData {\n    constructor() {\n        this.name = \"Connection Array\";\n    }\n    static CheckContains(connection) {\n        var contains = false;\n        for (var i = 0; i < this.connectionArray.length; i++) {\n            if (this.connectionArray[i].id == connection.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static AddConnection(connection) {\n        var contains = this.CheckContains(connection);\n        if (contains) {\n            this.RemoveConnection(connection);\n        }\n        if (connection.id != 0) {\n            UpdateToDatabase(\"localconnection\", connection);\n        }\n        this.connectionArray.push(connection);\n    }\n    static AddConnectionToMemory(connection) {\n        var contains = this.CheckContains(connection);\n        if (contains) {\n            this.RemoveConnection(connection);\n        }\n        this.connectionArray.push(connection);\n    }\n    static AddToDictionary(connection) {\n        this.connectionDictionary[connection.id] = connection;\n    }\n    static RemoveConnection(connection) {\n        for (var i = 0; i < this.connectionArray.length; i++) {\n            if (this.connectionArray[i].id == connection.id) {\n                this.connectionArray.splice(i, 1);\n            }\n        }\n        if (connection.id != 0) {\n            //  removeFromDatabase(\"connection\",connection.id);\n        }\n    }\n    static RemoveConnectionById(connectionId) {\n        for (var i = 0; i < this.connectionArray.length; i++) {\n            if (this.connectionArray[i].id == connectionId) {\n                this.connectionArray.splice(i, 1);\n            }\n        }\n        LocalSyncData.RemoveConnectionById(connectionId);\n    }\n    static AddPermanentConnection(connection) {\n        if (connection.id > 0) {\n            removeFromDatabase(\"localconnection\", connection.ghostId);\n            ConnectionData.AddConnection(ConvertFromLConnectionToConnection(connection));\n        }\n    }\n    static GetConnection(id) {\n        var myConcept;\n        myConcept = null;\n        for (var i = 0; i < this.connectionArray.length; i++) {\n            if (this.connectionArray[i].id == id) {\n                myConcept = this.connectionArray[i];\n            }\n        }\n        return myConcept;\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isLocalConnectionLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(LocalConnectionData.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static GetConnectionsOfCompositionLocal(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var connectionList = [];\n            try {\n                var data = yield this.waitForDataToLoad();\n                for (var i = 0; i < this.connectionArray.length; i++) {\n                    if (this.connectionArray[i].typeId == id) {\n                        connectionList.push(this.connectionArray[i]);\n                    }\n                }\n                return connectionList;\n            }\n            catch (exception) {\n                return connectionList;\n            }\n        });\n    }\n    static GetConnectionOfCompositionAndTypeLocal(typeId, ofTheConceptId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var connectionList = [];\n            try {\n                var data = yield this.waitForDataToLoad();\n                console.log(\"this is the connections\", this.connectionArray, typeId, ofTheConceptId);\n                for (var i = 0; i < this.connectionArray.length; i++) {\n                    if (this.connectionArray[i].typeId == typeId && this.connectionArray[i].ofTheConceptId == ofTheConceptId) {\n                        connectionList.push(this.connectionArray[i]);\n                    }\n                }\n                return connectionList;\n            }\n            catch (exception) {\n                return connectionList;\n            }\n        });\n    }\n    getName() {\n        return this.name;\n    }\n}\nLocalConnectionData.connectionArray = [];\nLocalConnectionData.connectionDictionary = [];\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"../IdentifierFlags\";\nimport { LNode } from \"./../Local/LNode\";\nexport class LocalGhostIdTree {\n    static addNodeToTree(node) {\n        if (this.root == null) {\n            this.root = node;\n            return this.root;\n        }\n        else {\n            this.root = this.root.addNode(node, this.root, this.root.height);\n        }\n    }\n    static addConceptToTree(concept) {\n        var node = new LNode(concept.ghostId, concept, null, null);\n        this.addNodeToTree(node);\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isLocalDataLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(LocalGhostIdTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static getNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return null;\n            }\n            if (this.root) {\n                var Node = this.root.getFromNode(id, this.root);\n                return Node;\n            }\n            return null;\n        });\n    }\n    static removeNodeFromTree(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.root) {\n                this.root = this.root.removeNode(this.root, id);\n            }\n        });\n    }\n}\nLocalGhostIdTree.root = null;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { UpdateToDatabase } from \"../../Database/indexdblocal\";\nimport { PopulateTheLocalConceptsToMemory, PopulateTheLocalConnectionToMemory } from \"../../Services/Local/CreateLocalBinaryTreeFromData\";\nexport class LocalId {\n    static AddConceptId(id) {\n        this.localId = id.value;\n        UpdateToDatabase(\"localid\", id);\n    }\n    /**\n     *\n     * This function will get the local concept id from the indexdb\n     * @returns the local concept id\n     */\n    static getConceptId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.localId) {\n                    if (this.ReservedLocalId.length < 5) {\n                        yield PopulateTheLocalConceptsToMemory().then(() => {\n                            let finalLocalId = this.localId;\n                            for (let j = 1; j < 10; j++) {\n                                let localId = this.localId - j;\n                                this.ReservedLocalId.push(localId);\n                                finalLocalId = localId;\n                            }\n                            this.AddConceptId({ \"id\": 0, \"value\": finalLocalId });\n                        }).catch((event) => {\n                            console.log(\" getid: cannot get the id from indexdb\");\n                            return -Math.floor(Math.random() * 100000000);\n                        });\n                        let id = this.ReservedLocalId[0];\n                        this.ReservedLocalId.shift();\n                        return id;\n                    }\n                    else {\n                        let id = this.ReservedLocalId[0];\n                        this.ReservedLocalId.shift();\n                        return id;\n                    }\n                }\n                else {\n                    yield PopulateTheLocalConceptsToMemory().then(() => {\n                        let finalLocalId = this.localId;\n                        for (let j = 1; j < 10; j++) {\n                            let localId = this.localId - j;\n                            this.ReservedLocalId.push(localId);\n                            finalLocalId = localId;\n                        }\n                        this.AddConceptId({ \"id\": 0, \"value\": finalLocalId });\n                    });\n                    return this.getConceptId();\n                }\n            }\n            catch (error) {\n                console.log(\" getid: this is the eror in concept\", error);\n                return -Math.floor(Math.random() * 100000000);\n            }\n        });\n    }\n    /**\n     *\n     * @param object This is the object that needs to be updated\n     */\n    static AddConnectionId(object) {\n        this.localConnectionId = object.value;\n        //UpdateToDatabase(\"localid\", id);\n    }\n    static getConnectionId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.localConnectionId) {\n                    if (this.ReservedConnectionId.length < 5) {\n                        yield PopulateTheLocalConnectionToMemory().then(() => {\n                            let finalLocalId = this.localConnectionId;\n                            for (let j = 1; j < 10; j++) {\n                                let localConId = this.localConnectionId - j;\n                                this.ReservedConnectionId.push(localConId);\n                                finalLocalId = localConId;\n                            }\n                        }).catch((event) => {\n                            console.log(\"this is the new event\", event);\n                            return -Math.floor(Math.random() * 100000000);\n                        });\n                        let id = this.ReservedConnectionId[0];\n                        this.ReservedConnectionId.shift();\n                        return id;\n                    }\n                    else {\n                        let id = this.ReservedConnectionId[0];\n                        this.ReservedConnectionId.shift();\n                        return id;\n                    }\n                }\n                else {\n                    yield PopulateTheLocalConnectionToMemory().then(() => {\n                        let finalLocalId = this.localConnectionId;\n                        for (let j = 1; j < 10; j++) {\n                            let localConId = this.localConnectionId - j;\n                            this.ReservedConnectionId.push(localConId);\n                            finalLocalId = localConId;\n                        }\n                        this.AddConnectionId({ \"id\": 1, \"value\": finalLocalId });\n                    });\n                    return this.getConnectionId();\n                }\n            }\n            catch (error) {\n                return -Math.floor(Math.random() * 100000000);\n            }\n        });\n    }\n}\nLocalId.ReservedLocalId = [];\nLocalId.ReservedConnectionId = [];\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateTheGhostConceptApi } from \"../../Api/Create/CreateTheGhostConceptApi\";\nimport { UpdateToDatabase } from \"../../Database/indexdblocal\";\nimport { LocalConceptsData } from \"./LocalConceptData\";\nimport { CreateDefaultLConcept, Logger, sendMessage, serviceWorker } from \"../../app\";\nimport { LocalConnectionData } from \"./LocalConnectionData\";\nexport class LocalSyncData {\n    static CheckContains(concept) {\n        var contains = false;\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (this.conceptsSyncArray[i].id == concept.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static SyncDataDelete(id) {\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (id == this.conceptsSyncArray[i].id) {\n                this.conceptsSyncArray.splice(i, 1);\n            }\n        }\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].ofTheConceptId == id || this.connectionSyncArray[i].toTheConceptId == id || this.connectionSyncArray[i].typeId == id) {\n                this.connectionSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static CheckContainsConnection(connection) {\n        var contains = false;\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].id == connection.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static AddConcept(concept) {\n        try {\n            let contains = false;\n            let existingConcept = LocalSyncData.CheckIfTheConceptIdExists(concept.id, this.conceptsSyncArray);\n            if (existingConcept.id != 0) {\n                contains = true;\n            }\n            if (!contains) {\n                this.conceptsSyncArray.push(concept);\n            }\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    static RemoveConcept(concept) {\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (this.conceptsSyncArray[i].id == concept.id) {\n                this.conceptsSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static SyncDataOnline(transactionId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let startTime = performance.now();\n            try {\n                console.log('sw triggered');\n                if (serviceWorker) {\n                    const res = yield sendMessage('LocalSyncData__SyncDataOnline', { transactionId });\n                    return res.data;\n                }\n                let conceptsArray = [];\n                let connectionsArray = [];\n                if (transactionId && this.transactionCollections.some(tran => tran.id == transactionId)) {\n                    const transaction = this.transactionCollections.find(tran => tran.id == transactionId);\n                    // remove current transaction from list\n                    this.transactionCollections = this.transactionCollections.filter(tran => tran.id != transactionId);\n                    // remove old query actions older than 15 days\n                    this.transactionCollections = this.transactionCollections.filter(tran => new Date(tran.createdDate).getTime() > (new Date().getTime() - 604800000));\n                    if (!transaction)\n                        return;\n                    conceptsArray = transaction.data.concepts.slice();\n                    connectionsArray = transaction.data.connections.slice();\n                }\n                else if (Array.isArray(actions === null || actions === void 0 ? void 0 : actions.concepts) && Array.isArray(actions === null || actions === void 0 ? void 0 : actions.connections)) {\n                    // filter concepts from conceptsSyncArray and connectionSyncArray and sync only belonging to this tab\n                    conceptsArray = actions.concepts.filter(concept => this.conceptsSyncArray.some(con => concept.id == con.id || concept.ghostId == con.ghostId)).slice();\n                    connectionsArray = actions.connections.filter(connection => this.connectionSyncArray.some(conn => connection.id == conn.id || connection.ghostId == conn.ghostId)).slice();\n                    // remove the concepts and connections from the array that belongs to the actions/tab\n                    this.conceptsSyncArray = this.conceptsSyncArray.filter(concept => !actions.concepts.some(con => concept.id == con.id || concept.ghostId == con.ghostId));\n                    this.connectionSyncArray = this.connectionSyncArray.filter(connection => !actions.connections.some(conn => connection.id == conn.id || connection.ghostId == conn.ghostId));\n                }\n                else {\n                    console.warn('Syncing this way has been Depreceted in service worker.');\n                    console.info('Only if serive worker is not running');\n                    conceptsArray = this.conceptsSyncArray.slice() || [];\n                    connectionsArray = this.connectionSyncArray.slice() || [];\n                    // return []\n                }\n                this.connectionSyncArray = [];\n                this.conceptsSyncArray = [];\n                let toSyncConcepts = [];\n                for (let i = 0; i < conceptsArray.length; i++) {\n                    //if(!conceptsArray[i].isSynced){\n                    toSyncConcepts.push(conceptsArray[i]);\n                    //}\n                    // this is used to denote that the local concept has already been synced with the online db\n                    yield LocalConceptsData.UpdateConceptSyncStatus(conceptsArray[i].id);\n                }\n                //if(connectionsArray.length > 0){\n                yield this.UpdateConceptListToIncludeRelatedConcepts(connectionsArray, toSyncConcepts);\n                let result = yield CreateTheGhostConceptApi(toSyncConcepts, connectionsArray);\n                let concepts = result.concepts;\n                let connections = result.connections;\n                for (let i = 0; i < concepts.length; i++) {\n                    LocalConceptsData.AddPermanentConcept(concepts[i]);\n                }\n                for (let i = 0; i < connections.length; i++) {\n                    LocalConnectionData.AddPermanentConnection(connections[i]);\n                }\n                //}\n                // Add Log\n                Logger.logInfo(startTime, \"unknown\", undefined, \"unknown\", undefined, 200, conceptsArray, \"SyncDataOnline\", [], \"unknown\", undefined);\n                return conceptsArray;\n            }\n            catch (error) {\n                // Add Log\n                Logger.logError(startTime, \"unknown\", undefined, \"unknown\", undefined, 500, error, \"SyncDataOnline\", [], \"unknown\", undefined);\n                throw error;\n            }\n        });\n    }\n    static ConvertGhostIdsInConnections(connectionArray) {\n        var _a, _b, _c;\n        for (let i = 0; i < connectionArray.length; i++) {\n            let ofTheConceptId = connectionArray[i].ofTheConceptId;\n            let toTheConceptId = connectionArray[i].toTheConceptId;\n            let typeId = connectionArray[i].typeId;\n            let newOfTheConceptId = (_a = LocalSyncData.ghostIdMap.get(ofTheConceptId)) !== null && _a !== void 0 ? _a : ofTheConceptId;\n            let newToTheConceptId = (_b = LocalSyncData.ghostIdMap.get(toTheConceptId)) !== null && _b !== void 0 ? _b : toTheConceptId;\n            let newTypeId = (_c = LocalSyncData.ghostIdMap.get(typeId)) !== null && _c !== void 0 ? _c : typeId;\n            connectionArray[i].ofTheConceptId = newOfTheConceptId;\n            connectionArray[i].toTheConceptId = newToTheConceptId;\n            connectionArray[i].typeId = newTypeId;\n        }\n    }\n    static UpdateConceptListToIncludeRelatedConcepts(connectionArray, conceptsArray) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let i = 0; i < connectionArray.length; i++) {\n                let ofTheConceptId = connectionArray[i].ofTheConceptId;\n                let toTheConceptId = connectionArray[i].toTheConceptId;\n                let typeId = connectionArray[i].typeId;\n                if (ofTheConceptId < 0) {\n                    let ofTheConcept = this.CheckIfTheConceptIdExists(ofTheConceptId, conceptsArray);\n                    if (ofTheConcept.id == 0) {\n                        ofTheConcept = yield LocalConceptsData.GetConceptByGhostId(ofTheConceptId);\n                        if (ofTheConcept.id != 0) {\n                            if (ofTheConcept.id != ofTheConcept.ghostId) {\n                                connectionArray[i].ofTheConceptId = ofTheConcept.id;\n                            }\n                        }\n                        else {\n                            ofTheConcept = yield LocalConceptsData.GetConcept(ofTheConceptId);\n                            // if this has already been synced before and is a composition type then do not send it again\n                            // if(!ofTheConcept.isSynced && !ofTheConcept.isComposition){\n                            this.AddConceptIfDoesNotExist(ofTheConcept, conceptsArray);\n                            //   }\n                        }\n                    }\n                }\n                if (toTheConceptId < 0) {\n                    let toTheConcept = this.CheckIfTheConceptIdExists(toTheConceptId, conceptsArray);\n                    if (toTheConcept.id == 0) {\n                        toTheConcept = yield LocalConceptsData.GetConceptByGhostId(toTheConceptId);\n                        if (toTheConcept.id != 0) {\n                            if (toTheConcept.id != toTheConcept.ghostId) {\n                                connectionArray[i].toTheConceptId = toTheConcept.id;\n                            }\n                        }\n                        else {\n                            toTheConcept = yield LocalConceptsData.GetConcept(toTheConceptId);\n                            // if this has already been synced before and is a composition type then do not send it again\n                            //   if(!toTheConcept.isSynced && !toTheConcept.isComposition){\n                            this.AddConceptIfDoesNotExist(toTheConcept, conceptsArray);\n                            //   }\n                        }\n                    }\n                }\n                if (typeId < 0) {\n                    let type = this.CheckIfTheConceptIdExists(typeId, conceptsArray);\n                    if (type.id == 0) {\n                        type = yield LocalConceptsData.GetConceptByGhostId(typeId);\n                        if (type.id != 0) {\n                            if (type.id != type.ghostId) {\n                                connectionArray[i].typeId = type.id;\n                            }\n                        }\n                        else {\n                            type = yield LocalConceptsData.GetConcept(typeId);\n                            // if this has already been synced before and is a composition type then do not send it again\n                            //    if(!type.isSynced && !type.isComposition){\n                            this.AddConceptIfDoesNotExist(type, conceptsArray);\n                            //    }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    static AddConceptIfDoesNotExist(concept, conceptList = []) {\n        let exists = false;\n        for (let i = 0; i < conceptList.length; i++) {\n            if (concept.ghostId == conceptList[i].ghostId) {\n                exists = true;\n            }\n        }\n        if (!exists) {\n            conceptList.push(concept);\n        }\n    }\n    static CheckIfTheConceptIdExists(id, conceptList = []) {\n        let returnConcept = CreateDefaultLConcept();\n        for (let i = 0; i < conceptList.length; i++) {\n            if (id == conceptList[i].ghostId || id == conceptList[i].id) {\n                returnConcept = conceptList[i];\n            }\n        }\n        return returnConcept;\n    }\n    static AddConnection(connection) {\n        this.connectionSyncArray.push(connection);\n    }\n    static RemoveConnection(connection) {\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].id == connection.id) {\n                this.connectionSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static RemoveConnectionById(connectionId) {\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].id == connectionId) {\n                this.connectionSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static syncDataLocalDb() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.conceptsSyncArray.length > 0) {\n                for (let i = 0; i < this.conceptsSyncArray.length; i++) {\n                    UpdateToDatabase(\"localconcept\", this.conceptsSyncArray[i]);\n                }\n                this.conceptsSyncArray = [];\n            }\n            if (this.connectionSyncArray.length > 0) {\n                for (let i = 0; i < this.connectionSyncArray.length; i++) {\n                    UpdateToDatabase(\"localconnection\", this.connectionSyncArray[i]);\n                }\n                this.connectionSyncArray = [];\n            }\n            return \"done\";\n        });\n    }\n    static initializeTransaction(transactionId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('sw triggered');\n            if (serviceWorker) {\n                const res = yield sendMessage('LocalSyncData__initializeTransaction', { transactionId });\n                return res.data;\n            }\n            if (this.transactionCollections.some(item => item.id == transactionId))\n                return;\n            this.transactionCollections.push({\n                id: transactionId,\n                data: { concepts: [], connections: [] },\n                createdDate: new Date().toISOString()\n            });\n        });\n    }\n    static markTransactionActions(transactionId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // remove marked \n            console.log('sw triggered');\n            if (serviceWorker) {\n                const res = yield sendMessage('LocalSyncData__markTransactionActions', { transactionId, actions });\n                return res.data;\n            }\n            this.transactionCollections = this.transactionCollections.map(tran => {\n                if (tran.id == transactionId) {\n                    return Object.assign(Object.assign({}, tran), { data: JSON.parse(JSON.stringify(actions)) });\n                }\n                else\n                    return tran;\n            });\n            this.conceptsSyncArray = this.conceptsSyncArray.filter(concept => !actions.concepts.some(con => con.id == concept.id || con.ghostId == concept.id));\n            this.connectionSyncArray = this.connectionSyncArray.filter(connection => !actions.connections.some(con => con.id == connection.id || con.ghostId == connection.id));\n        });\n    }\n    static rollbackTransaction(transactionId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('sw triggered');\n            if (serviceWorker) {\n                const res = yield sendMessage('LocalSyncData__rollbackTransaction', { transactionId, actions });\n                return res.data;\n            }\n            if (this.transactionCollections.some(item => item.id == transactionId))\n                return;\n            this.transactionCollections = this.transactionCollections.filter(tran => tran.id != transactionId);\n        });\n    }\n}\nLocalSyncData.conceptsSyncArray = [];\nLocalSyncData.connectionSyncArray = [];\nLocalSyncData.ghostIdMap = new Map();\nLocalSyncData.transactionCollections = [];\n","export class Node {\n    constructor(key, value, leftNode, rightNode) {\n        this.variants = [];\n        this.height = 1;\n        this.key = key;\n        this.value = value;\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n        this.currentNode = null;\n    }\n    addCurrentNode(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        if (passedNode.value.typeId != node.value.typeId) {\n            node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        }\n        return node;\n    }\n    addCurrentNodeType(passedNode, node) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        let contains = false;\n        for (let i = 0; i < node.variants.length; i++) {\n            if (node.variants[i].value.id == passedNode.value.id) {\n                contains = true;\n            }\n        }\n        if (!contains) {\n            node.variants.push(passedNode);\n        }\n        //node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n        return node;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        let LeftNode = node.leftNode;\n        let RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        // else if (node.key == passedNode.key && node.key != \"\"){\n        //     node.currentNode = passedNode;\n        // }\n        else {\n            return node;\n        }\n        node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        let balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (passedNode.key < node.leftNode.key) {\n                    return this.rightRotate(node);\n                }\n                else if (passedNode.key > node.leftNode.key) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    return this.rightRotate(node);\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (passedNode.key > node.rightNode.key) {\n                    return this.leftRotate(node);\n                }\n                else if (passedNode.key < node.rightNode.key) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    return this.leftRotate(node);\n                }\n            }\n        }\n        return node;\n    }\n    checkIfIdsInNode(node, ids, connectionArray, remainingIds) {\n        if (node) {\n            if (ids.includes(node.key)) {\n                connectionArray.push(node.value);\n                // remainingIds[node.key] = true;\n                let index = ids.indexOf(node.key);\n                ids.splice(index, 1);\n            }\n            if (node.leftNode) {\n                this.checkIfIdsInNode(node.leftNode, ids, connectionArray, remainingIds);\n            }\n            if (node.rightNode) {\n                this.checkIfIdsInNode(node.rightNode, ids, connectionArray, remainingIds);\n            }\n        }\n    }\n    addCharacterNode(passedNode, node, height) {\n        let debugFlag = false;\n        if (passedNode.value.characterValue != \"\") {\n            // if(passedNode.value.characterValue == \"Default\"){\n            //     console.log(\"default here\");\n            //     debugFlag = true;\n            // }\n            if (node == null) {\n                if (debugFlag) {\n                    console.log(\"equal here\", node);\n                }\n                node = passedNode;\n                return node;\n            }\n            // if (node.key == passedNode.key && node.key != \"\" ){\n            //     if(passedNode.value.characterValue == \"Default\"){\n            //         console.log(\"equal\");\n            //     }\n            //     node.currentNode = passedNode;\n            //     return node;\n            // }\n            let LeftNode = node.leftNode;\n            let RightNode = node.rightNode;\n            if (node.key > passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"left  here\", node);\n                }\n                node.leftNode = this.addCharacterNode(passedNode, LeftNode, height);\n            }\n            else if (node.key < passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"right here\", node, RightNode);\n                }\n                node.rightNode = this.addCharacterNode(passedNode, RightNode, height);\n            }\n            // else if (node.key == passedNode.key && node.key != \"\"){\n            //     node.currentNode = passedNode;\n            // }\n            else {\n                if (debugFlag) {\n                    console.log(\"else here\", node, passedNode);\n                }\n                if (node.key == passedNode.key && node.key != \"\" && node.value.id != passedNode.value.id) {\n                    // node.currentNode = this.addCurrentNode(passedNode, node.currentNode);\n                    node.addCurrentNodeType(passedNode, node);\n                }\n                return node;\n            }\n            node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n            if (debugFlag) {\n                console.log(\"height here\", node.height);\n            }\n            let balancingFactor = this.getBalanceFactor(node);\n            if (debugFlag) {\n                console.log(\"balancingFactor here\", balancingFactor);\n            }\n            if (balancingFactor > 1) {\n                if (node.leftNode) {\n                    if (passedNode.key < node.leftNode.key) {\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 1 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key > node.leftNode.key) {\n                        node.leftNode = this.leftRotate(node.leftNode);\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 2 \", returner);\n                        }\n                        return returner;\n                    }\n                }\n            }\n            if (balancingFactor < -1) {\n                if (node.rightNode) {\n                    if (passedNode.key > node.rightNode.key) {\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 3 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key < node.rightNode.key) {\n                        node.rightNode = this.rightRotate(node.rightNode);\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here4 \", returner, node);\n                        }\n                        return returner;\n                    }\n                }\n            }\n        }\n        else {\n            if (debugFlag) {\n                console.log(\"what here\", node);\n            }\n        }\n        if (debugFlag) {\n            console.log(\"returning here 6\", node);\n        }\n        return node;\n    }\n    addTypeNode(passedNode, node, height) {\n        let debugFlag = false;\n        if (passedNode.value.typeId != 0) {\n            // if(passedNode.value.characterValue == \"Default\"){\n            //     console.log(\"default here\");\n            //     debugFlag = true;\n            // }\n            if (node == null) {\n                if (debugFlag) {\n                    console.log(\"equal here\", node);\n                }\n                console.log(\"adding the type node to the tree\", passedNode);\n                node = passedNode;\n                return node;\n            }\n            let LeftNode = node.leftNode;\n            let RightNode = node.rightNode;\n            if (node.key > passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"left  here\", node);\n                }\n                node.leftNode = this.addTypeNode(passedNode, LeftNode, height);\n            }\n            else if (node.key < passedNode.key) {\n                if (debugFlag) {\n                    console.log(\"right here\", node, RightNode);\n                }\n                node.rightNode = this.addTypeNode(passedNode, RightNode, height);\n            }\n            else {\n                if (debugFlag) {\n                    console.log(\"else here\", node, passedNode);\n                }\n                console.log(\"adding the type node to the tree down\", passedNode);\n                if (node.key == passedNode.key && node.key != 0 && node.value.id != passedNode.value.id) {\n                    node.addCurrentNodeType(passedNode, node);\n                }\n                console.log(\"adding the type node to the tree last\", node);\n                return node;\n            }\n            node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n            if (debugFlag) {\n                console.log(\"height here\", node.height);\n            }\n            let balancingFactor = this.getBalanceFactor(node);\n            if (debugFlag) {\n                console.log(\"balancingFactor here\", balancingFactor);\n            }\n            if (balancingFactor > 1) {\n                if (node.leftNode) {\n                    if (passedNode.key < node.leftNode.key) {\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 1 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key > node.leftNode.key) {\n                        node.leftNode = this.leftRotate(node.leftNode);\n                        let returner = this.rightRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 2 \", returner);\n                        }\n                        return returner;\n                    }\n                }\n            }\n            if (balancingFactor < -1) {\n                if (node.rightNode) {\n                    if (passedNode.key > node.rightNode.key) {\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here 3 \", returner);\n                        }\n                        return returner;\n                    }\n                    else if (passedNode.key < node.rightNode.key) {\n                        node.rightNode = this.rightRotate(node.rightNode);\n                        let returner = this.leftRotate(node);\n                        if (debugFlag) {\n                            console.log(\"returning here4 \", returner, node);\n                        }\n                        return returner;\n                    }\n                }\n            }\n        }\n        else {\n            if (debugFlag) {\n                console.log(\"what here\", node);\n            }\n        }\n        if (debugFlag) {\n            console.log(\"returning here 6\", node);\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode)) + 1;\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key) {\n                // if(node.value.count){\n                //     node.value.count++ ;\n                // }\n                // else{\n                //     node.value.count = 1;\n                // }\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    getCharacterFromNode(value, node) {\n        if (node) {\n            if (value == node.key) {\n                return node;\n            }\n            else if (value < node.key) {\n                return this.getCharacterFromNode(value, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getCharacterFromNode(value, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    getCharacterFromNodeUpdated(value, node) {\n        var _a;\n        if (node) {\n            if (value == node.key || ((_a = node.value) === null || _a === void 0 ? void 0 : _a.typeId) == 51) {\n                return node;\n            }\n            else if (value < node.key) {\n                return this.getCharacterFromNode(value, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getCharacterFromNode(value, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    getFromNodeWithCharacterAndType(value, typeId, node) {\n        value = `${value}`;\n        if (node) {\n            if (value == node.key) {\n                if (value == node.value.characterValue && typeId == node.value.typeId) {\n                    return node;\n                }\n                else {\n                    for (let i = 0; i < node.variants.length; i++) {\n                        if (node.variants[i].value.typeId == typeId) {\n                            return node.variants[i];\n                        }\n                    }\n                    // return this.getFromNodeWithCharacterAndType(value, typeId, node.currentNode);\n                }\n            }\n            else if (value < node.key) {\n                return this.getFromNodeWithCharacterAndType(value, typeId, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getFromNodeWithCharacterAndType(value, typeId, node.rightNode);\n            }\n            return null;\n        }\n        return node;\n    }\n    getFromNodeWithCharacterAndCategory(value, categoryId, node) {\n        value = `${value}`;\n        if (node) {\n            if (value == node.key) {\n                if (value == node.value.characterValue && categoryId == node.value.categoryId) {\n                    return node;\n                }\n                else {\n                    for (let i = 0; i < node.variants.length; i++) {\n                        if (node.variants[i].value.categoryId == categoryId) {\n                            return node.variants[i];\n                        }\n                    }\n                    // return this.getFromNodeWithCharacterAndType(value, typeId, node.currentNode);\n                }\n            }\n            else if (value < node.key) {\n                return this.getFromNodeWithCharacterAndCategory(value, categoryId, node.leftNode);\n            }\n            else if (value > node.key) {\n                return this.getFromNodeWithCharacterAndCategory(value, categoryId, node.rightNode);\n            }\n            return null;\n        }\n        return node;\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        // if(passedNode.variants.length > 0){\n        //     if(passedNode.value.id == id ){\n        //     }\n        //     var newNode = passedNode.variants[0];\n        //     if(newNode){\n        //         passedNode.value = newNode.value;\n        //         passedNode.key = newNode.key;\n        //         passedNode.currentNode = newNode.currentNode;\n        //         return passedNode;\n        //     }\n        // }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    removeNodeWithVariants(passedNode, typeIdentifier, conceptId) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > typeIdentifier) {\n            passedNode.leftNode = this.removeNodeWithVariants(passedNode.leftNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        else if (passedNode.key < typeIdentifier) {\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, typeIdentifier, conceptId);\n            return passedNode;\n        }\n        if (passedNode.variants.length > 0) {\n            //condition if the main node is equal to the value\n            if (passedNode.value.id == conceptId) {\n                let newNode = passedNode.variants[0];\n                if (newNode) {\n                    passedNode.value = newNode.value;\n                    passedNode.key = newNode.key;\n                    passedNode.currentNode = newNode.currentNode;\n                    passedNode.variants.splice(0, 1);\n                    return passedNode;\n                }\n            }\n            else {\n                // in the condition that the main node is not equal to the checking value \n                for (let i = 0; i < passedNode.variants.length; i++) {\n                    if (conceptId == passedNode.variants[i].value.id) {\n                        passedNode.variants.splice(i, 1);\n                        return passedNode;\n                    }\n                }\n            }\n        }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.variants = immediateSuccessor.variants;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, immediateSuccessor.key, conceptId);\n            return passedNode;\n        }\n    }\n    countNodeBelow(root) {\n        if (root == null) {\n            return 0;\n        }\n        //recursive call to left child and right child and\n        // add the result of these with 1 ( 1 for counting the root)\n        return 1 + this.countNodeBelow(root.leftNode) + this.countNodeBelow(root.rightNode);\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","export class PatcherStructure {\n    constructor() {\n        this.compositionId = 0;\n        this.userId = 999;\n        this.sessionId = 999;\n        this.accessId = 4;\n        this.ofTheCompositionId = 0;\n        this.patchObject = {};\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetReservedConnectionIds } from \"../Api/GetReservedConnectionIds\";\nimport { GetReservedIds } from \"../Api/GetReservedIds\";\nexport class ReservedIds {\n    static getId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.ids.length < 5) {\n                var ids = yield GetReservedIds();\n            }\n            var id = this.ids[0];\n            this.ids.shift();\n            return id;\n        });\n    }\n    static AddId(id) {\n        if (!this.ids.includes(id)) {\n            this.ids.push(id);\n        }\n    }\n}\nReservedIds.ids = [];\nexport class ReservedConnectionIds {\n    static getId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connectionIds.length < 5) {\n                var connectionIds = yield GetReservedConnectionIds();\n            }\n            var id = this.connectionIds[0];\n            this.connectionIds.shift();\n            return id;\n        });\n    }\n    static AddId(id) {\n        if (!this.connectionIds.includes(id)) {\n            this.connectionIds.push(id);\n        }\n    }\n}\nReservedConnectionIds.connectionIds = [];\n","import { BaseUrl } from \"../BaseUrl\";\n/**\n * This is a class that is used to standardize the Response that is sent by FreeSchema.\n * This is done so that we do not have to send a HttpResponse codes.\n */\nexport class FreeSchemaResponse {\n    /**\n     *\n     * @param message this is the message for the response\n     * @param ok  this is the status can be true or false boolean in case that request succeds or fails\n     * @param status this is the standard http codes 200 for ok, 500 for internal error etc.\n     * @param data  this is the standard data that can be anything.\n     */\n    constructor(message, ok, status, data) {\n        this.url = BaseUrl.BASE_URL;\n        this.message = message;\n        this.ok = ok;\n        this.status = status;\n        this.data = data;\n    }\n    /**\n     * This function gets the message of the error\n     * @returns\n     */\n    getMessage() {\n        return this.message;\n    }\n    /**\n     *\n     * @param message This allows you to set a message variable in the FreeSchemaResponse\n     * @returns\n     */\n    setMessage(message) {\n        this.message = message;\n        return this;\n    }\n    /**\n     *\n     * @returns status code of the FreeSchemaResponse\n     */\n    getStatus() {\n        return this.status;\n    }\n    /**\n     *\n     * @param status standard http error codes (200 ok , 401 unauthorized, 500 internal server error etc.)\n     * @returns\n     */\n    setStatus(status) {\n        this.status = status;\n        return this;\n    }\n    /**\n     *\n     * @returns returns the data for the request\n     */\n    getData() {\n        return this.data;\n    }\n    /**\n     *\n     * @param data any type of data can be given here\n     * @returns FreeSchemaReponse\n     */\n    setData(data) {\n        this.data = data;\n        return this;\n    }\n    /**\n     *\n     * @returns the status of the FreeSchemaReponse (either true or false)\n     */\n    getOk() {\n        return this.ok;\n    }\n    /**\n     *\n     * @param status if the status is true then the response was successful else the success was not achieved.\n     * @returns returns the FreeSchemaResponse\n     */\n    setOk(ok) {\n        this.ok = ok;\n        return this;\n    }\n    /**\n     *\n     * @returns the url that caused the error\n     */\n    getUrl() {\n        return this.url;\n    }\n    /**\n     *\n     * @param url the url from which the error or response originates\n     * @returns FreeSchemaResponse\n     */\n    setUrl(url) {\n        this.url = url;\n        return this;\n    }\n}\n","export class Returner {\n    constructor(id, userId, referentId, isNew) {\n        this.id = id;\n        this.userId = userId;\n        this.referentId = referentId;\n        this.isNew = isNew;\n    }\n}\n","export class SearchQuery {\n    constructor() {\n        this.composition = 0;\n        this.type = \"\";\n        this.linker = \"\";\n        this.inpage = 10;\n        this.page = 1;\n        this.listLinkers = [];\n        this.fullLinkers = [];\n        this.textSearch = \"\";\n        this.logic = \"or\";\n        this.reverse = false;\n        this.doFilter = false;\n        this.filterSearches = [];\n        this.selectors = [];\n        this.ofCompositions = [];\n    }\n}\n","import { NORMAL } from \"../../Constants/FormatConstants\";\nexport class FreeschemaQuery {\n    constructor() {\n        this.type = \"\";\n        this.inpage = 10;\n        this.page = 1;\n        this.concepts = [];\n        this.conceptIds = [];\n        this.selectors = [];\n        this.freeschemaQueries = [];\n        this.filters = [];\n        this.filterLogic = \"\";\n        this.typeConnection = \"\";\n        this.outputFormat = NORMAL;\n        this.name = \"\";\n        this.reverse = false;\n        this.includeInFilter = false;\n        this.isOldConnectionType = false;\n    }\n}\n","export class SearchStructure {\n    constructor() {\n        this.type = \"\";\n        this.search = \"\";\n        this.composition = \"\";\n        this.internalComposition = \"\";\n        this.userId = 999;\n        this.inpage = 10;\n        this.page = 1;\n        this.auth = true;\n    }\n}\n","export class TokenStorage {\n}\nTokenStorage.BearerAccessToken = \"\";\n","export class SessionData {\n    constructor() {\n        this.id = \"0\";\n        this.remote_address = \"\";\n        this.server_port = \"\";\n        this.server_address = \"\";\n        this.server_name = \"\";\n        this.server_software = \"\";\n        this.http_user_agent = \"\";\n        this.self = \"\";\n        this.port = \"\";\n        this.userId = \"\";\n        this.email = \"\";\n    }\n}\n","export class SettingData {\n    constructor(isOnlineSync) {\n        this.id = 1;\n        this.isOnlineSync = false;\n        this.isOnlineSync = isOnlineSync;\n    }\n}\n","export class Settings {\n}\nSettings.isUpdated = false;\nSettings.isOnlineSync = false;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { storeToDatabase } from \"./../Database/indexeddb\";\nimport { CreateTheConceptApi } from \"../Api/Create/CreateTheConceptApi\";\nimport { CreateTheConnectionApi } from \"../Api/Create/CreateTheConnectionApi\";\nimport { ConceptsData } from \"./ConceptData\";\nimport { ConnectionData } from \"./ConnectionData\";\nimport { sendMessage, serviceWorker } from \"../app\";\nexport class SyncData {\n    static CheckContains(concept) {\n        var contains = false;\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (this.conceptsSyncArray[i].id == concept.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static SyncDataDelete(id) {\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (id == this.conceptsSyncArray[i].id) {\n                this.conceptsSyncArray.splice(i, 1);\n            }\n        }\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].ofTheConceptId == id || this.connectionSyncArray[i].toTheConceptId == id || this.connectionSyncArray[i].typeId == id) {\n                this.connectionSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static CheckContainsConnection(connection) {\n        var contains = false;\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].id == connection.id) {\n                contains = true;\n            }\n        }\n        return contains;\n    }\n    static AddConcept(concept) {\n        var contains = false;\n        // ConceptsData.AddConceptTemporary(concept);\n        if (!contains) {\n            this.conceptsSyncArray.push(concept);\n        }\n    }\n    static RemoveConcept(concept) {\n        for (var i = 0; i < this.conceptsSyncArray.length; i++) {\n            if (this.conceptsSyncArray[i].id == concept.id) {\n                this.conceptsSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static AddConnection(connection) {\n        this.connectionSyncArray.push(connection);\n    }\n    static RemoveConnection(connection) {\n        for (var i = 0; i < this.connectionSyncArray.length; i++) {\n            if (this.connectionSyncArray[i].id == connection.id) {\n                this.connectionSyncArray.splice(i, 1);\n            }\n        }\n    }\n    static SyncDataOnline() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('sw triggered');\n            if (serviceWorker) {\n                const res = yield sendMessage('SyncData__SyncDataOnline', {});\n                return res.data;\n            }\n            for (let i = 0; i < this.conceptsSyncArray.length; i++) {\n                ConceptsData.AddConcept(this.conceptsSyncArray[i]);\n            }\n            for (let i = 0; i < this.connectionSyncArray.length; i++) {\n                ConnectionData.AddConnection(this.connectionSyncArray[i]);\n            }\n            if (this.conceptsSyncArray.length > 0) {\n                let conceptsArray = this.conceptsSyncArray.slice();\n                this.conceptsSyncArray = [];\n                CreateTheConceptApi(conceptsArray);\n            }\n            if (this.connectionSyncArray.length > 0) {\n                // for(let i =0 ; i<this.connectionSyncArray.length ; i++){\n                //     console.log(\"create the connection in backend\", this.connectionSyncArray[i].ofTheConceptId + \"====\" + this.connectionSyncArray[i].toTheConceptId);\n                // }\n                let connectionsArray = this.connectionSyncArray.slice();\n                this.connectionSyncArray = [];\n                yield CreateTheConnectionApi(connectionsArray);\n            }\n            return \"done\";\n        });\n    }\n    static syncDataLocalDb() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.conceptsSyncArray.length > 0) {\n                for (let i = 0; i < this.conceptsSyncArray.length; i++) {\n                    storeToDatabase(\"localconcept\", this.conceptsSyncArray[i]);\n                }\n                this.conceptsSyncArray = [];\n            }\n            if (this.connectionSyncArray.length > 0) {\n                for (let i = 0; i < this.connectionSyncArray.length; i++) {\n                    storeToDatabase(\"localconnection\", this.connectionSyncArray[i]);\n                }\n                this.connectionSyncArray = [];\n            }\n            return \"done\";\n        });\n    }\n}\nSyncData.conceptsSyncArray = [];\nSyncData.connectionSyncArray = [];\n","export class TheCharacter {\n    constructor(userId, data, securityId, securityUserId, accessId, accessUserId, sessionId, sessionUserId, entryTimestamp, isNew) {\n        this.id = 0;\n        this.isNew = false;\n        this.userId = userId;\n        this.data = `${data}`;\n        this.securityId = securityId;\n        this.securityUserId = securityUserId;\n        this.accessId = accessId;\n        this.accessUserId = accessUserId;\n        this.sessionId = sessionId;\n        this.sessionUserId = sessionUserId;\n        this.isNew = isNew;\n    }\n}\n","export class TheTexts {\n    constructor(userId, data, securityId, securityUserId, accessId, accessUserId, sessionId, sessionUserId, entryTimestamp, isNew) {\n        this.id = 0;\n        this.userId = userId;\n        this.data = data;\n        this.securityId = securityId;\n        this.securityUserId = securityUserId;\n        this.accessId = accessId;\n        this.accessUserId = accessUserId;\n        this.sessionId = sessionId;\n        this.sessionUserId = sessionUserId;\n        this.entryTimestamp = entryTimestamp;\n        this.isNew = isNew;\n    }\n}\n","export class TypeNode {\n    constructor(key, value) {\n        this.value = [];\n        this.height = 1;\n        this.key = key;\n        this.value.push(value);\n        this.leftNode = null;\n        this.rightNode = null;\n        this.currentNode = null;\n    }\n    addType(node, key, value) {\n        var _a, _b, _c, _d;\n        if (node == null) {\n            return new TypeNode(key, value);\n        }\n        if (key < node.key) {\n            node.leftNode = this.addType(node.leftNode, key, value);\n        }\n        else if (key > node.key) {\n            node.rightNode = this.addType(node.rightNode, key, value);\n        }\n        else {\n            // If key already exists, insert unique value into the set\n            node.value.push(value);\n            return node;\n        }\n        // Step 2: Update height of this ancestor node\n        node.height = Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode)) + 1;\n        // Step 3: Get the balance factor to check if this node became unbalanced\n        const balance = this.getBalanceFactor(node);\n        // Step 4: If the node is unbalanced, perform rotations\n        // Left Left Case (Right Rotation)\n        if (balance > 1 && key < ((_a = node.leftNode) === null || _a === void 0 ? void 0 : _a.key)) {\n            return this.rightRotate(node);\n        }\n        // Right Right Case (Left Rotation)\n        if (balance < -1 && key > ((_b = node.rightNode) === null || _b === void 0 ? void 0 : _b.key)) {\n            return this.leftRotate(node);\n        }\n        // Left Right Case (Left rotation, then right rotation)\n        if (balance > 1 && key > ((_c = node.leftNode) === null || _c === void 0 ? void 0 : _c.key)) {\n            node.leftNode = this.leftRotate(node.leftNode);\n            return this.rightRotate(node);\n        }\n        // Right Left Case (Right rotation, then left rotation)\n        if (balance < -1 && key < ((_d = node.rightNode) === null || _d === void 0 ? void 0 : _d.key)) {\n            node.rightNode = this.rightRotate(node.rightNode);\n            return this.leftRotate(node);\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode)) + 1;\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key) {\n                // if(node.value.count){\n                //     node.value.count++ ;\n                // }\n                // else{\n                //     node.value.count = 1;\n                // }\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    removeNodeWithVariants(passedNode, key, conceptId) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > key) {\n            passedNode.leftNode = this.removeNodeWithVariants(passedNode.leftNode, key, conceptId);\n            return passedNode;\n        }\n        else if (passedNode.key < key) {\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, key, conceptId);\n            return passedNode;\n        }\n        if (passedNode.value.length > 0) {\n            // in the condition that the main node is not equal to the checking value \n            for (let i = 0; i < passedNode.value.length; i++) {\n                if (conceptId == passedNode.value[i]) {\n                    passedNode.value.splice(i, 1);\n                    return passedNode;\n                }\n            }\n        }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            let immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.currentNode = immediateSuccessor.currentNode;\n            passedNode.rightNode = this.removeNodeWithVariants(passedNode.rightNode, immediateSuccessor.key, conceptId);\n            return passedNode;\n        }\n    }\n    countNodeBelow(root) {\n        if (root == null) {\n            return 0;\n        }\n        //recursive call to left child and right child and\n        // add the result of these with 1 ( 1 for counting the root)\n        return 1 + this.countNodeBelow(root.leftNode) + this.countNodeBelow(root.rightNode);\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { UserNode } from \"./UserNode\";\nimport { IdentifierFlags } from \"./../IdentifierFlags\";\nexport class UserBinaryTree {\n    static compositeKey(userId, sessionId) {\n        let userHex = ('0000' + userId.toString(16).toUpperCase()).slice(-4);\n        let sessionHex = ('0000' + sessionId.toString(16).toUpperCase()).slice(-4);\n        return userHex + sessionHex;\n    }\n    static addNodeToTree(node) {\n        if (this.root == null) {\n            this.root = node;\n            return this.root;\n        }\n        else {\n            this.root = this.root.addNode(node, this.root, this.root.height);\n        }\n    }\n    static waitForDataToLoad() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.checkFlag(resolve);\n                setTimeout(() => {\n                    reject(\"not\");\n                }, 25000);\n            });\n        });\n    }\n    static checkFlag(resolve) {\n        if (IdentifierFlags.isDataLoaded) {\n            return resolve(\"done\");\n        }\n        else {\n            setTimeout(UserBinaryTree.checkFlag, 1000, resolve);\n        }\n    }\n    ;\n    static addConceptToTree(concept, userId, sessionId = 999) {\n        let key = this.compositeKey(userId, sessionId);\n        var node = new UserNode(key, concept, null, null);\n        this.addNodeToTree(node);\n    }\n    static getNodeFromTree(userId, sessionId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                var data = yield this.waitForDataToLoad();\n            }\n            catch (exception) {\n                return null;\n            }\n            let key = this.compositeKey(userId, sessionId);\n            if (this.root) {\n                var Node = this.root.getFromNode(key, this.root);\n                return Node;\n            }\n            return null;\n        });\n    }\n    static removeNodeFromTree(userId_1) {\n        return __awaiter(this, arguments, void 0, function* (userId, sessionId = 999) {\n            if (this.root) {\n                let key = this.compositeKey(userId, sessionId);\n                this.root = this.root.removeNode(this.root, key);\n            }\n        });\n    }\n    static countNumberOfNodes() {\n        if (this.root) {\n            return this.root.countNodeBelow(this.root);\n        }\n        return 0;\n    }\n}\nUserBinaryTree.root = null;\n","export class UserNode {\n    constructor(key, value, leftNode, rightNode) {\n        this.value = [];\n        this.height = 1;\n        this.key = key;\n        this.value.push(value);\n        this.leftNode = leftNode;\n        this.rightNode = rightNode;\n    }\n    addNode(passedNode, node, height) {\n        if (node == null) {\n            node = passedNode;\n            return node;\n        }\n        var LeftNode = node.leftNode;\n        var RightNode = node.rightNode;\n        if (node.key > passedNode.key) {\n            node.leftNode = this.addNode(passedNode, LeftNode, height);\n        }\n        else if (node.key < passedNode.key) {\n            node.rightNode = this.addNode(passedNode, RightNode, height);\n        }\n        else {\n            node.value.push(...passedNode.value);\n            return node;\n        }\n        node.height = 1 + Math.max(this.getHeight(node.leftNode), this.getHeight(node.rightNode));\n        let balancingFactor = this.getBalanceFactor(node);\n        if (balancingFactor > 1) {\n            if (node.leftNode) {\n                if (passedNode.key < node.leftNode.key) {\n                    return this.rightRotate(node);\n                }\n                else if (passedNode.key > node.leftNode.key) {\n                    node.leftNode = this.leftRotate(node.leftNode);\n                    return this.rightRotate(node);\n                }\n            }\n        }\n        if (balancingFactor < -1) {\n            if (node.rightNode) {\n                if (passedNode.key > node.rightNode.key) {\n                    return this.leftRotate(node);\n                }\n                else if (passedNode.key < node.rightNode.key) {\n                    node.rightNode = this.rightRotate(node.rightNode);\n                    return this.leftRotate(node);\n                }\n            }\n        }\n        return node;\n    }\n    rightRotate(y) {\n        if (y) {\n            let x = y.leftNode;\n            if (x) {\n                let T2 = x.rightNode;\n                y.leftNode = T2;\n                x.rightNode = y;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(y.rightNode)) + 1;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                return x;\n            }\n            // return x;\n        }\n        return y;\n    }\n    leftRotate(x) {\n        if (x) {\n            let y = x.rightNode;\n            if (y) {\n                let T2 = y.leftNode;\n                y.leftNode = x;\n                x.rightNode = T2;\n                x.height = Math.max(this.getHeight(x.leftNode), this.getHeight(x.rightNode)) + 1;\n                y.height = Math.max(this.getHeight(y.leftNode), this.getHeight(x.rightNode)) + 1;\n                return y;\n            }\n            //return y;\n        }\n        return x;\n    }\n    getHeight(node) {\n        if (node) {\n            return node.height;\n        }\n        return 0;\n    }\n    getBalanceFactor(N) {\n        if (N == null) {\n            return 0;\n        }\n        return this.getHeight(N.leftNode) - this.getHeight(N.rightNode);\n    }\n    getFromNode(id, node) {\n        if (node) {\n            if (id == node.key) {\n                return node;\n            }\n            else if (id < node.key) {\n                return this.getFromNode(id, node.leftNode);\n            }\n            else if (id > node.key) {\n                return this.getFromNode(id, node.rightNode);\n            }\n            return node;\n        }\n        return node;\n    }\n    removeNode(passedNode, id) {\n        if (passedNode == null) {\n            return passedNode;\n        }\n        if (passedNode.key > id) {\n            passedNode.leftNode = this.removeNode(passedNode.leftNode, id);\n            return passedNode;\n        }\n        else if (passedNode.key < id) {\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, id);\n            return passedNode;\n        }\n        if (passedNode.leftNode == null) {\n            let temp = passedNode.rightNode;\n            passedNode = null;\n            return temp;\n        }\n        else if (passedNode.rightNode == null) {\n            let temp = passedNode.leftNode;\n            passedNode = null;\n            return temp;\n        }\n        else {\n            // passing the rightNode to the inOrderSuccessor gives the immediate successor of the node\n            var immediateSuccessor = this.inOrderSuccessor(passedNode.rightNode);\n            passedNode.value = immediateSuccessor.value;\n            passedNode.key = immediateSuccessor.key;\n            passedNode.rightNode = this.removeNode(passedNode.rightNode, immediateSuccessor.key);\n            return passedNode;\n        }\n    }\n    countNodeBelow(root) {\n        if (root == null) {\n            return 0;\n        }\n        //recursive call to left child and right child and\n        // add the result of these with 1 ( 1 for counting the root)\n        return 1 + this.countNodeBelow(root.leftNode) + this.countNodeBelow(root.rightNode);\n    }\n    inOrderSuccessor(root) {\n        while (root.leftNode != null) {\n            root = root.leftNode;\n        }\n        return root;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SettingData } from \"../DataStructures/SettingData\";\nimport { IndexDb } from \"./indexeddb\";\nexport function openDatabase(databaseName) {\n    return IndexDb.db;\n}\nexport function storeToDatabase(databaseName, object) {\n}\nexport function GetStatsFromDatabase() {\n    var settingsData = new SettingData(true);\n    return settingsData;\n}\nexport function AiUpdateFlag(object) {\n}\nexport function getFromDatabaseWithType(databaseName, type, id) {\n    return __awaiter(this, void 0, void 0, function* () {\n    });\n}\nexport function getObjectsFromIndexDb(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n    });\n}\nexport function removeFromDatabase(databaseName, id) {\n}\nexport function getAllFromLocalDb(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseUrl } from \"../app\";\n/**\n * version of the database. If you want to change the database then you must update this version also.\n */\nvar version = 9;\n/**\n * This class will help us store the indexdb  reference in memory and not go back to index db.\n */\nexport class LocalIndexDb {\n}\n/**\n *\n * @param databaseName not required actually. This is not used you can pass anything.\n * @returns a promise that either resolves or rejects opening the database.\n */\nexport function openDatabase(databaseName) {\n    return new Promise(function (resolve, reject) {\n        // if the indexdb is already initialized then you do not need to again initialize the db so you can get \n        // from memory.\n        if (LocalIndexDb.db) {\n            resolve(LocalIndexDb.db);\n        }\n        // the name of the database is passed here. We are statically passing the dbName with inputs from user\n        // the BASE_URL is the api that the framework calls\n        // the BASE_APPLICATION is a thing that differentiates an application from another so no two application create\n        // and use the same index db.  \n        let localDbName = BaseUrl.BASE_URL + \"_FreeSchemaLocal\" + BaseUrl.BASE_APPLICATION;\n        const request = indexedDB.open(localDbName, version);\n        // in case that the database is not opened then log the error.\n        // then we delete the database that is already present with the name\n        // then again try to create the database, since this is a temporary database so it might not matter\n        // but this is a point that we might need to be careful about.\n        // we then reject the promise and report this problem.\n        request.onerror = (event) => {\n            console.error(\"Why didn't you allow my web app to use IndexedDB?!\", event);\n            indexedDB.deleteDatabase(localDbName);\n            openDatabase(databaseName);\n            reject(event);\n        };\n        // in case that the database is allowed to be opened then we return the database object.\n        request.onsuccess = function (event) {\n            var target = event.target;\n            LocalIndexDb.db = target.result;\n            resolve(LocalIndexDb.db);\n        };\n        // in case that the version is upgraded then we delete all the old databases and then create a new database.\n        // version upgrade is a way which we can clean up old databases and its structures.\n        request.onupgradeneeded = (event) => {\n            var target = event.target;\n            var db = target.result;\n            var conceptDb = \"localconcept\";\n            var connectionDb = \"localconnection\";\n            var idDb = \"localid\";\n            console.log(\"this is the version upgrade\", version);\n            if (db.objectStoreNames.contains(conceptDb)) {\n                db.deleteObjectStore(conceptDb);\n            }\n            if (db.objectStoreNames.contains(connectionDb)) {\n                db.deleteObjectStore(connectionDb);\n            }\n            if (db.objectStoreNames.contains(idDb)) {\n                db.deleteObjectStore(idDb);\n            }\n            if (!db.objectStoreNames.contains(conceptDb)) { // if there's no database name\n                let objectStore = db.createObjectStore(conceptDb, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                };\n            }\n            if (!db.objectStoreNames.contains(connectionDb)) { // if there's no database name\n                let objectStore = db.createObjectStore(connectionDb, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                };\n            }\n            if (!db.objectStoreNames.contains(idDb)) { // if there's no database name\n                let objectStore = db.createObjectStore(idDb, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                    // this is the event in which we initialize the local database\n                    // we assume the start of the localconcept by -100, localconnection by -200 and a random value \n                    // which will enable us to identify this local database from others.\n                    storeToDatabase(idDb, { \"id\": 0, \"value\": -100 });\n                    storeToDatabase(idDb, { \"id\": 1, \"value\": -200 });\n                    // storeToDatabase(idDb,{\"id\":3, \"value\": BaseUrl.BASE_RANDOMIZER});\n                    storeToDatabase(idDb, { \"id\": 3, \"value\": BaseUrl.getRandomizer() });\n                };\n            }\n            resolve(db);\n        };\n    });\n}\nexport function LockTheDatabase(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        console.log(\"lock : locked db\");\n        yield UpdateToDatabase(databaseName, { \"id\": 4, \"value\": true });\n    });\n}\nexport function UnlockDatabase(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield UpdateToDatabase(databaseName, { \"id\": 4, \"value\": false });\n        console.log(\"lock :locked opened\");\n    });\n}\nexport function GetLockStatus(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let list = yield getObjectsFromLocalIndexDb(databaseName);\n            console.log(\"lock :for lock locked\", list);\n            if (Array.isArray(list)) {\n                console.log(\"lock : This is the list vallue\", list[4].value);\n                return list[4].value;\n            }\n            console.log(\"lock : This is not a list\", Array.isArray(list));\n            return false;\n        }\n        catch (error) {\n            console.log(\"lock : this is the error\", error);\n        }\n    });\n}\n/**\n*  this function will return all the objects that are in the database\n* @param databaseName name of the database\n* @returns all the objects that are in the database\n*/\nexport function getObjectsFromLocalIndexDb(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise(function (resolve, reject) {\n            openDatabase(databaseName).then((db) => {\n                var concept;\n                var ConceptList = [];\n                let transaction = db.transaction(databaseName, \"readwrite\");\n                let objectStore = transaction.objectStore(databaseName);\n                var allobjects = objectStore.getAll();\n                allobjects.onsuccess = () => {\n                    const students = allobjects.result;\n                    for (var i = 0; i < students.length; i++) {\n                        ConceptList.push(students[i]);\n                    }\n                    resolve(ConceptList);\n                };\n            }).catch((event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot get objects from database because you cannot open the Local database\",\n                    \"data\": event\n                };\n                reject(errorObject);\n            });\n        });\n    });\n}\n/**\n *\n * @param databaseName name of the database that you want to store data to.\n * @param object any object that can be stored but keep in mind it must follow the convention that we created\n * while creating the datbase.\n * @returns a promise that if a store is successful then the obejct is returned else rejects with the event.\n */\nexport function storeToDatabase(databaseName, object) {\n    return new Promise(function (resolve, reject) {\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objStore = transaction.objectStore(databaseName);\n            const request = objStore.add(object);\n            request.onsuccess = (event) => {\n                resolve(object);\n            };\n            request.onerror = (event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot store to the Local database \" + databaseName,\n                    \"data\": event,\n                    \"body\": object\n                };\n                reject(errorObject);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot store to database because you cannot open the Local database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n/**\n *\n * @param databaseName name of the database\n * @param object this is the object that you want to update\n * @returns returns the object if it is updated successfully.\n */\nexport function UpdateToDatabase(databaseName, object) {\n    return new Promise(function (resolve, reject) {\n        // console.log(\"this is wriring to the database local\", object);\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objStore = transaction.objectStore(databaseName);\n            const request = objStore.put(object);\n            request.onsuccess = (event) => {\n                resolve(object);\n            };\n            request.onerror = (event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot Update to the Local database\" + databaseName,\n                    \"data\": event,\n                    \"body\": object\n                };\n                reject(errorObject);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot update to database because you cannot open the Local database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n//   /**\n//  *  this function will return all the objects that are in the database \n//  * @param databaseName name of the database\n//  * @returns all the objects that are in the database\n//  */\n// export async function getLConceptsFromLocalDb(databaseName:string){\n//   return new Promise(function(resolve, reject){\n//         var ConceptList:any[] = [];\n//       openDatabase(databaseName).then(db=>{\n//           let transaction = LocalIndexDb.db.transaction(databaseName, \"readwrite\") as IDBTransaction;\n//           let objectStore =transaction.objectStore(databaseName) as IDBObjectStore;\n//           var allobjects = objectStore.getAll();\n//           allobjects.onsuccess = ()=> {\n//             const readObjects = allobjects.result;\n//             for(var i=0; i<readObjects.length; i++){\n//                 ConceptList.push(readObjects[i]);\n//             }\n//             resolve(ConceptList); \n//         }\n//       });\n//   });\n// }\n/**\n *\n * @param databaseName name of the database\n * @param id the id that we need to remove from the database (this is the index)\n * @returns an id if the deletion is successful and error with even in case it cannot.\n */\nexport function removeFromDatabase(databaseName, id) {\n    return new Promise(function (resolve, reject) {\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objectStore = transaction.objectStore(databaseName);\n            let getRequest = objectStore.delete(id);\n            getRequest.onsuccess = function (event) {\n                resolve(id);\n            };\n            getRequest.onerror = function (event) {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot Update to the Local database\" + databaseName,\n                    \"data\": event,\n                    \"body\": id\n                };\n                reject(errorObject);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot remove object from database because you cannot open the Local database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SettingData } from \"../DataStructures/SettingData\";\nimport { BaseUrl } from \"../DataStructures/BaseUrl\";\n/**\n * version of the database. If you want to change the database then you must update this version also.\n */\nvar version = 9;\n/**\n * This class will help us store the indexdb  reference in memory and not go back to index db.\n */\nexport class IndexDb {\n}\n/**\n *\n * @param databaseName not required actually. This is not used you can pass anything.\n * @returns a promise that either resolves or rejects opening the database.\n */\nexport function openDatabase(databaseName) {\n    return new Promise(function (resolve, reject) {\n        // if the indexdb is already initialized then you do not need to again initialize the db so you can get \n        // from memory.\n        if (IndexDb.db) {\n            resolve(IndexDb.db);\n        }\n        // the name of the database is passed here. We are statically passing the dbName with inputs from user\n        // the BASE_URL is the api that the framework calls\n        // the BASE_APPLICATION is a thing that differentiates an application from another so no two application create\n        // and use the same index db.\n        let dbName = BaseUrl.BASE_URL + \"_FreeSchema\" + BaseUrl.BASE_APPLICATION;\n        // open the database.\n        const request = indexedDB.open(dbName, version);\n        // in case that the database is not opened then log the error.\n        // then we delete the database that is already present with the name\n        // then again try to create the database, since this is a temporary database so it might not matter\n        // but this is a point that we might need to be careful about.\n        // we then reject the promise and report this problem.\n        request.onerror = (event) => {\n            console.error(\"Why didn't you allow my web app to use IndexedDB?!\", event);\n            indexedDB.deleteDatabase(dbName);\n            openDatabase(databaseName);\n            reject(event);\n        };\n        // in case that the database is allowed to be opened then we return the database object.\n        request.onsuccess = function (event) {\n            let target = event.target;\n            IndexDb.db = target.result;\n            resolve(IndexDb.db);\n        };\n        // in case that the version is upgraded then we delete all the old databases and then create a new database.\n        // version upgrade is a way which we can clean up old databases and its structures.\n        request.onupgradeneeded = (event) => {\n            let target = event.target;\n            let db = target.result;\n            let conceptDb = \"concept\";\n            let connectionDb = \"connection\";\n            let settings = \"settings\";\n            console.log(\"this is the version update for index\", version);\n            if (db.objectStoreNames.contains(conceptDb)) {\n                db.deleteObjectStore(conceptDb);\n            }\n            if (db.objectStoreNames.contains(connectionDb)) {\n                db.deleteObjectStore(connectionDb);\n            }\n            if (db.objectStoreNames.contains(settings)) {\n                db.deleteObjectStore(settings);\n            }\n            if (!db.objectStoreNames.contains(conceptDb)) { // if there's no database name\n                let objectStore = db.createObjectStore(conceptDb, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                    // you can do something here after the db has been created.\n                };\n            }\n            if (!db.objectStoreNames.contains(connectionDb)) { // if there's no database name\n                let objectStore = db.createObjectStore(connectionDb, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                    // you can do something here after the db has been created.\n                };\n            }\n            if (!db.objectStoreNames.contains(settings)) {\n                let objectStore = db.createObjectStore(settings, { keyPath: 'id' }); // create it\n                objectStore.transaction.oncomplete = (event) => {\n                    // you can do something here after the db has been created.\n                };\n            }\n            resolve(db);\n        };\n    });\n}\n/**\n *\n * @param databaseName name of the database that you want to store data to.\n * @param object any object that can be stored but keep in mind it must follow the convention that we created\n * while creating the datbase.\n * @returns a promise that if a store is successful then the obejct is returned else rejects with the event.\n */\nexport function storeToDatabase(databaseName, object) {\n    return new Promise(function (resolve, reject) {\n        console.log(\"this is storing to the database\", object);\n        openDatabase(databaseName).then((db) => {\n            if (object.id != 0) {\n                let transaction = db.transaction(databaseName, \"readwrite\");\n                let objStore = transaction.objectStore(databaseName);\n                const request = objStore.add(object);\n                request.onsuccess = (event) => {\n                    resolve(object);\n                };\n                request.onerror = (event) => {\n                    let errorObject = {\n                        \"status\": 400,\n                        \"ok\": false,\n                        \"message\": \"Cannot store to the database\" + databaseName,\n                        \"data\": event,\n                        \"body\": object\n                    };\n                    reject(errorObject);\n                };\n            }\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot store to the database because you cannot open the database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n/**\n  *\n  * @param databaseName name of the database\n  * @param object this is the object that you want to update\n  * @returns returns the object if it is updated successfully.\n  */\nexport function UpdateToDatabase(databaseName, object) {\n    return new Promise(function (resolve, reject) {\n        // console.log(\"this is wriring to the database\", object);\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objStore = transaction.objectStore(databaseName);\n            const request = objStore.put(object);\n            request.onsuccess = (event) => {\n                resolve(object);\n            };\n            request.onerror = (event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot Update to the database\" + databaseName,\n                    \"data\": event,\n                    \"body\": object\n                };\n                reject(errorObject);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot update to database because you cannot open the database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n/**\n *\n * @returns This returns the last object from the database.\n */\nexport function GetLastSettingsFromDatabase() {\n    return new Promise(function (resolve, reject) {\n        let databaseName = \"settings\";\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objectStore = transaction.objectStore(databaseName);\n            let allobjects = objectStore.getAll();\n            allobjects.onsuccess = () => {\n                let settingsData = new SettingData(false);\n                let settingsArray = allobjects.result;\n                for (let i = 0; i < settingsArray.length; i++) {\n                    settingsData = settingsArray[i];\n                    settingsData = settingsData;\n                }\n                resolve(settingsData);\n            };\n            allobjects.onerror = (event) => {\n                reject(event);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot get last object from database because you cannot open the database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n/**\n *\n * @param object SettingData\n * @returns this will update the indexdb with the ai flag so that another time we do not have to pull\n *  ai data from the api.\n */\nexport function AiUpdateFlag(object) {\n    return new Promise(function (resolve, reject) {\n        let databaseName = \"settings\";\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objStore = transaction.objectStore(databaseName);\n            const request = objStore.put(object);\n            request.onsuccess = (event) => {\n                resolve(object);\n            };\n            request.onerror = (event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot update AI flag\",\n                    \"data\": event,\n                    \"body\": object\n                };\n                reject(errorObject);\n            };\n        })\n            .catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot update AI flag because you cannot open the database\",\n                \"data\": event\n            };\n            reject(errorObject);\n        });\n    });\n}\n/**\n *  this function will return all the objects that are in the database\n * @param databaseName name of the database\n * @returns all the objects that are in the database\n */\nexport function getObjectsFromIndexDb(databaseName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise(function (resolve, reject) {\n            openDatabase(databaseName).then((db) => {\n                let ConceptList = [];\n                let transaction = db.transaction(databaseName, \"readwrite\");\n                let objectStore = transaction.objectStore(databaseName);\n                let allobjects = objectStore.getAll();\n                allobjects.onsuccess = () => {\n                    const students = allobjects.result;\n                    for (let i = 0; i < students.length; i++) {\n                        ConceptList.push(students[i]);\n                    }\n                    resolve(ConceptList);\n                };\n            }).catch((event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot get objects from the database because you cannot open the database\",\n                    \"data\": event\n                };\n                reject(errorObject);\n            });\n        });\n    });\n}\n/**\n *\n * @param databaseName name of the database\n * @param id the id that we need to remove from the database (this is the index)\n * @returns an id if the deletion is successful and error with even in case it cannot.\n */\nexport function removeFromDatabase(databaseName, id) {\n    return new Promise(function (resolve, reject) {\n        openDatabase(databaseName).then((db) => {\n            let transaction = db.transaction(databaseName, \"readwrite\");\n            let objectStore = transaction.objectStore(databaseName);\n            const request = objectStore.delete(Number(id));\n            request.onsuccess = function (event) {\n                resolve(id);\n            };\n            request.onerror = (event) => {\n                let errorObject = {\n                    \"status\": 400,\n                    \"ok\": false,\n                    \"message\": \"Cannot remove from the database\" + databaseName,\n                    \"data\": event\n                };\n                reject(errorObject);\n            };\n        }).catch((event) => {\n            let errorObject = {\n                \"status\": 400,\n                \"ok\": false,\n                \"message\": \"Cannot remove from the database because you cannot open the database\",\n                \"data\": event,\n                \"body\": id\n            };\n            reject(errorObject);\n        });\n    });\n}\n","import { Connection } from \"../DataStructures/Connection\";\nimport { CreateDefaultConcept } from \"../Services/CreateDefaultConcept\";\nexport function CheckIfConceptsExistsInArray(conceptList = [], concept) {\n    let foundConcept = CreateDefaultConcept();\n    if (Array.isArray(conceptList)) {\n        const check = conceptList.find(c => c.id === concept.id);\n        if (check) {\n            foundConcept = check;\n        }\n    }\n    return foundConcept;\n}\n// export function CheckIfTypeConceptExistsInArray(\n//   conceptList: Concept[] = [],\n//   concept: Concept,\n// ) {\n//   let newConceptType = concept.type?.characterValue;\n//   if(!newConceptType?.startsWith(\"the_\")){\n//     newConceptType = \"the_\" + newConceptType;\n//   }\n//   let startsWith = conceptList[i].type?.characterValue;\n//   if(!startsWith?.startsWith(\"the_\")){\n//     startsWith = \"the_\" + startsWith;\n//   }\n//   let foundConcept = CreateDefaultConcept()\n//   if (Array.isArray(conceptList)) {\n//     const check = conceptList.find(c => c.typeId == concept.typeId)\n//     if (check) {\n//       foundConcept = check\n//     }\n//   }\n//   return foundConcept\n// }\nexport function CheckIfTypeConceptsExistsInArray(conceptList = [], concept) {\n    var _a, _b;\n    let foundConcepts = [];\n    let newConceptType = (_a = concept.type) === null || _a === void 0 ? void 0 : _a.characterValue;\n    if (!(newConceptType === null || newConceptType === void 0 ? void 0 : newConceptType.startsWith(\"the_\"))) {\n        newConceptType = \"the_\" + newConceptType;\n    }\n    if (Array.isArray(conceptList)) {\n        for (let i = 0; i < conceptList.length; i++) {\n            let startsWith = (_b = conceptList[i].type) === null || _b === void 0 ? void 0 : _b.characterValue;\n            if (!(startsWith === null || startsWith === void 0 ? void 0 : startsWith.startsWith(\"the_\"))) {\n                startsWith = \"the_\" + startsWith;\n            }\n            if (concept.typeId == conceptList[i].typeId || newConceptType == startsWith) {\n                foundConcepts.push(conceptList[i]);\n            }\n        }\n    }\n    return foundConcepts;\n}\nexport function CheckIfTypeLConceptsExistsInArray(conceptList = [], concept) {\n    let foundConcepts = [];\n    let newConceptType = concept.typeCharacter;\n    if (!(newConceptType === null || newConceptType === void 0 ? void 0 : newConceptType.startsWith(\"the_\"))) {\n        newConceptType = \"the_\" + newConceptType;\n    }\n    if (Array.isArray(conceptList)) {\n        for (let i = 0; i < conceptList.length; i++) {\n            let startsWith = conceptList[i].typeCharacter;\n            if (!(startsWith === null || startsWith === void 0 ? void 0 : startsWith.startsWith(\"the_\"))) {\n                startsWith = \"the_\" + startsWith;\n            }\n            if (concept.typeId == conceptList[i].typeId || newConceptType == startsWith) {\n                foundConcepts.push(conceptList[i]);\n            }\n        }\n    }\n    return foundConcepts;\n}\nexport function CheckIfConnectionExistsInArray(connectionList = [], connection) {\n    let foundConnection = new Connection(0, 0, 0, 0, 0, 0, 0);\n    if (Array.isArray(connectionList)) {\n        const check = connectionList.find(c => c.id === connection.id);\n        if (check) {\n            foundConnection = check;\n        }\n    }\n    return foundConnection;\n}\nexport function CheckIfToTheConceptExistsInConnectionArray(connectionList = [], conceptId) {\n    let foundConnection = new Connection(0, 0, 0, 0, 0, 0, 0);\n    if (Array.isArray(connectionList)) {\n        const check = connectionList.find(c => c.toTheConceptId === conceptId);\n        if (check) {\n            foundConnection = check;\n        }\n        const toCheck = connectionList.find(c => c.ofTheConceptId === conceptId);\n        if (toCheck) {\n            foundConnection = toCheck;\n        }\n    }\n    return foundConnection;\n}\nexport function CheckAllConnectionsConnectedInConnectionArray(connectionList = [], conceptId) {\n    let foundConnections = [];\n    if (Array.isArray(connectionList)) {\n        const check = connectionList.find(c => c.toTheConceptId == conceptId);\n        if (check) {\n            foundConnections.push(check);\n        }\n        const toCheck = connectionList.find(c => c.ofTheConceptId == conceptId);\n        if (toCheck) {\n            foundConnections.push(toCheck);\n        }\n    }\n    return foundConnections;\n}\nexport function CheckAllConnectionsConnectedInLConnectionArray(connectionList = [], conceptId) {\n    let foundConnections = [];\n    if (Array.isArray(connectionList)) {\n        const check = connectionList.find(c => c.toTheConceptId == conceptId);\n        if (check) {\n            foundConnections.push(check);\n        }\n        const toCheck = connectionList.find(c => c.ofTheConceptId == conceptId);\n        if (toCheck) {\n            foundConnections.push(toCheck);\n        }\n    }\n    return foundConnections;\n}\n","export function RemoveConceptFromList(conceptList = [], concept) {\n    if (Array.isArray(conceptList)) {\n        conceptList.splice(conceptList.findIndex(function (i) {\n            return i.id === concept.id;\n        }), 1);\n    }\n}\nexport function RemoveConnectionFromList(connectionList = [], connection) {\n    if (Array.isArray(connectionList)) {\n        connectionList.splice(connectionList.findIndex(function (i) {\n            return i.id === connection.id;\n        }), 1);\n    }\n}\nexport function RemoveLConnectionFromList(connectionList = [], connection) {\n    if (Array.isArray(connectionList)) {\n        connectionList.splice(connectionList.findIndex(function (i) {\n            return i.id === connection.id;\n        }), 1);\n    }\n}\n","export default function InsertUniqueNumber(Array, toInsert) {\n    if (Array.indexOf(toInsert) === -1) {\n        Array.push(toInsert);\n    }\n    return Array;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from \"./logger.service\";\nexport class EventLogger {\n    static initialize() {\n        console.log(\"Initialized Event Logger...\");\n        // Log unhandled errors\n        window.addEventListener(\"error\", (event) => {\n            var _a, _b;\n            console.log(\"error called...\");\n            Logger.logErrorEvent({\n                message: \"Unhandled Error\",\n                error: ((_a = event.error) === null || _a === void 0 ? void 0 : _a.message) || event.message,\n                source: event.filename,\n                line: event.lineno,\n                column: event.colno,\n                stack: (_b = event.error) === null || _b === void 0 ? void 0 : _b.stack,\n            });\n        });\n        // Log unhandled promise rejections\n        window.addEventListener(\"unhandledrejection\", (event) => {\n            var _a;\n            console.log(\"unhandledrejection called...\");\n            Logger.logErrorEvent({\n                message: \"Unhandled Promise Rejection\",\n                reason: event.reason,\n                stack: (_a = event.reason) === null || _a === void 0 ? void 0 : _a.stack,\n            });\n        });\n        // Log user interactions\n        document.addEventListener(\"click\", (event) => {\n            var _a;\n            const target = event.target;\n            console.log(\"Click Event called...\");\n            Logger.logErrorEvent({\n                message: \"User Click\",\n                element: target.tagName,\n                id: target.id,\n                classes: target.className,\n                text: (_a = target.innerText) === null || _a === void 0 ? void 0 : _a.slice(0, 50),\n            });\n        });\n        // Log network requests (requires interception with Service Worker or monkey-patching)\n        this.logNetworkRequests();\n    }\n    static logNetworkRequests() {\n        const originalFetch = window.fetch;\n        window.fetch = (...args) => __awaiter(this, void 0, void 0, function* () {\n            const [url, options] = args;\n            const urlString = url instanceof Request ? url.url : (url instanceof URL ? url.toString() : url);\n            console.log(\"Custom fetch called for:\", urlString);\n            Logger.logNetwork({\n                type: \"REQUEST\",\n                message: \"Network Request\",\n                method: (options === null || options === void 0 ? void 0 : options.method) || \"GET\",\n                url: urlString,\n                body: options === null || options === void 0 ? void 0 : options.body,\n            });\n            try {\n                const response = yield originalFetch(...args);\n                Logger.logNetwork({\n                    type: \"RESPONSE\",\n                    message: \"Network Response\",\n                    url: urlString,\n                    status: response.status,\n                });\n                return response;\n            }\n            catch (error) {\n                console.error(\"Fetch failed for:\", urlString, error); // Debugging log\n                Logger.logNetwork({\n                    type: \"ERROR\",\n                    message: \"Network Request Failed\",\n                    url: urlString,\n                    error: error instanceof Error ? error.message : String(error),\n                });\n                throw error;\n            }\n        });\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport class Logger {\n    /**\n     * Automatically starts the auto-sync mechanism.\n     * This is private and does not need external interaction.\n     */\n    static startAutoSync() {\n        if (this.autoSyncInterval) {\n            console.warn(\"Auto-sync is already running.\");\n            return;\n        }\n        Logger.nextSyncTime = Date.now() + Logger.SYNC_INTERVAL_MS;\n        console.log(\"AutoSync running every 1 second. Next sync at:\", Logger.nextSyncTime);\n        Logger.nextSyncTime = Date.now() + Logger.SYNC_INTERVAL_MS;\n        this.autoSyncInterval = window.setInterval(() => {\n            const currentTime = Date.now();\n            if (Logger.nextSyncTime && currentTime >= Logger.nextSyncTime) {\n                Logger.nextSyncTime = currentTime + Logger.SYNC_INTERVAL_MS; // Reset for the next interval\n                Logger.sendLogsToServer();\n            }\n        }, 1000); // Check every second\n    }\n    /**\n     * Automatically stops the auto-sync mechanism when required.\n     */\n    static stopAutoSync() {\n        if (this.autoSyncInterval !== null) {\n            clearInterval(this.autoSyncInterval);\n            this.autoSyncInterval = null;\n            Logger.nextSyncTime = null;\n        }\n    }\n    /**\n     * Set the log level (e.g., \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\").\n     */\n    static setLogLevel(level) {\n        Logger.logLevel = level;\n    }\n    /**\n     * Determines whether the current log level permits the given level to be logged.\n     */\n    static shouldLog(level) {\n        return Logger.LOG_LEVELS.indexOf(level) >= Logger.LOG_LEVELS.indexOf(Logger.logLevel);\n    }\n    /**\n     * Logs a message with optional additional structured data.\n     */\n    static formatLogData(level, message, data) {\n        if (!Logger.shouldLog(level))\n            return;\n        const logEntry = Object.assign({ timestamp: new Date().toISOString(), level,\n            message }, data);\n        Logger.logs.push(logEntry);\n        console.log(\"Log Data in Logger Class : \", Logger.logs);\n        this.saveToLocalStorage(logEntry);\n    }\n    static log(type, message, data) {\n        try {\n            Logger.formatLogData(this.logLevel, message, data);\n        }\n        catch (error) {\n            console.error(\"Error on Logger Log : \", error);\n        }\n    }\n    static logInfo(startTime, userId, operationType, requestFrom, requestIP, responseStatus, responseData, functionName, functionParameters, userAgent, conceptsUsed) {\n        const sessionId = getCookie(\"SessionId\");\n        const responseTime = `${(performance.now() - startTime).toFixed(3)}ms`;\n        const responseSize = responseData ? `${JSON.stringify(responseData).length}` : \"0\";\n        const logData = {\n            userId,\n            operationType,\n            requestFrom,\n            requestIP,\n            responseStatus,\n            responseTime,\n            responseSize,\n            sessionId: sessionId === null || sessionId === void 0 ? void 0 : sessionId.toString(),\n            functionName,\n            functionParameters,\n            userAgent,\n            conceptsUsed,\n        };\n        Logger.log(\"INFO\", `Information logged for ${functionName}`, logData);\n    }\n    static logError(startTime, userId, operationType, requestFrom, requestIP, responseStatus, responseData, functionName, functionParameters, userAgent, conceptsUsed) {\n        const sessionId = getCookie(\"SessionId\");\n        const responseTime = `${(performance.now() - startTime).toFixed(3)}ms`;\n        const responseSize = responseData ? `${JSON.stringify(responseData).length}` : \"0\";\n        const logData = {\n            userId,\n            operationType,\n            requestFrom,\n            requestIP,\n            responseStatus,\n            responseTime,\n            responseSize,\n            sessionId: sessionId === null || sessionId === void 0 ? void 0 : sessionId.toString(),\n            functionName,\n            functionParameters,\n            userAgent,\n            conceptsUsed,\n        };\n        Logger.formatLogData(\"ERROR\", `Information logged for ${functionName}`, logData);\n    }\n    static logWarning(startTime, userId, operationType, requestFrom, requestIP, responseStatus, responseData, functionName, functionParameters, userAgent, conceptsUsed) {\n        const sessionId = getCookie(\"SessionId\");\n        const responseTime = `${(performance.now() - startTime).toFixed(3)}ms`;\n        const responseSize = responseData ? `${JSON.stringify(responseData).length}` : \"0\";\n        const logData = {\n            userId,\n            operationType,\n            requestFrom,\n            requestIP,\n            responseStatus,\n            responseTime,\n            responseSize,\n            sessionId: sessionId === null || sessionId === void 0 ? void 0 : sessionId.toString(),\n            functionName,\n            functionParameters,\n            userAgent,\n            conceptsUsed,\n        };\n        Logger.formatLogData(\"WARNING\", `Information logged for ${functionName}`, logData);\n    }\n    static logDebug(startTime, userId, operationType, requestFrom, requestIP, responseStatus, responseData, functionName, functionParameters, userAgent, conceptsUsed) {\n        const sessionId = getCookie(\"SessionId\");\n        const responseTime = `${(performance.now() - startTime).toFixed(3)}ms`;\n        const responseSize = responseData ? `${JSON.stringify(responseData).length}` : \"0\";\n        const logData = {\n            userId,\n            operationType,\n            requestFrom,\n            requestIP,\n            responseStatus,\n            responseTime,\n            responseSize,\n            sessionId: sessionId === null || sessionId === void 0 ? void 0 : sessionId.toString(),\n            functionName,\n            functionParameters,\n            userAgent,\n            conceptsUsed,\n        };\n        Logger.formatLogData(\"DEBUG\", `Information logged for ${functionName}`, logData);\n    }\n    // Log Event\n    static logErrorEvent(message, error, source, line, column, stack) {\n        const logData = {\n            message: message || \"Unknown error\",\n            error: error || \"No error message provided\",\n            source: source || \"Unknown source\",\n            line: line || \"Unknown line\",\n            column: column || \"Unknown column\",\n            stack: stack || \"No stack trace available\",\n            timestamp: new Date().toISOString(),\n        };\n        console.error(\"Error Logged:\", logData);\n        this.saveEventToLocalStorage(JSON.stringify(logData));\n        // send the error data to an external service or save it\n        // sendToLoggingService(logData);\n    }\n    // Log Network Error\n    static logNetwork(logData) {\n        if (logData.type === 'REQUEST') {\n            let networkLog = (logData.message,\n                logData.method,\n                logData.url,\n                logData.body,\n                new Date().toISOString());\n            console.log(\"NETWORK REQUEST LOG : \", networkLog);\n            this.saveEventToLocalStorage(JSON.stringify(logData));\n        }\n        if (logData.type === 'RESPONSE') {\n            let networkLog = (logData.message,\n                logData.method,\n                logData.url,\n                logData.body,\n                new Date().toISOString());\n            console.log(\"NETWORK RESPONSE LOG : \", networkLog);\n            this.saveEventToLocalStorage(JSON.stringify(logData));\n        }\n        if (logData.type === 'ERROR') {\n            let networkLog = (logData.message,\n                logData.url,\n                logData.error,\n                new Date().toISOString());\n            console.log(\"NETWORK ERROR LOG : \", networkLog);\n            this.saveEventToLocalStorage(JSON.stringify(logData));\n        }\n    }\n    /**\n     * Helper method to save logs to localStorage.\n     */\n    static saveToLocalStorage(logMessage) {\n        try {\n            const logs = JSON.parse(localStorage.getItem(\"logs\") || \"[]\");\n            logs.push(logMessage);\n            localStorage.setItem(\"logs\", JSON.stringify(logs));\n        }\n        catch (error) {\n            console.error(\"Failed to save log to localStorage:\", error);\n        }\n    }\n    static saveEventToLocalStorage(logMessage) {\n        try {\n            const logs = JSON.parse(localStorage.getItem(\"EventLogs\") || \"[]\");\n            logs.push(logMessage);\n            localStorage.setItem(\"EventLogs\", JSON.stringify(logs));\n        }\n        catch (error) {\n            console.error(\"Failed to save log to localStorage:\", error);\n        }\n    }\n    /**\n     * Helper method to send logs to the server.\n     */\n    static sendLogsToServer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                console.log(\"Log sending to server...\");\n                const storedLogs = JSON.parse(localStorage.getItem(\"logs\") || \"[]\");\n                if (storedLogs.length === 0)\n                    return;\n                // console.log(\"Stored Logs : \", storedLogs);\n                const chunkSize = 50;\n                for (let i = 0; i < storedLogs.length; i += chunkSize) {\n                    const chunk = storedLogs.slice(i, i + chunkSize);\n                    // console.log(\"Sending logs chunk:\", chunk);\n                    // console.log(\"Payload chunk:\", JSON.stringify(chunk)); \n                    const response = yield fetch(Logger.SERVER_URL, {\n                        method: \"POST\",\n                        headers: { \"Content-Type\": \"application/json\" },\n                        body: JSON.stringify(chunk),\n                    });\n                    if (!response.ok) {\n                        const responseBody = yield response.text();\n                        // console.log(\"Response Body on failed request : \", responseBody);\n                        console.error(\"Failed to send logs:-\", response.status, response.statusText, responseBody);\n                        return;\n                    }\n                }\n                localStorage.removeItem(\"logs\");\n                console.log(\"Logs successfully sent and cleared.\");\n            }\n            catch (error) {\n                console.error(\"Error while sending logs to server:\", error);\n            }\n        });\n    }\n}\nLogger.logLevel = \"INFO\";\nLogger.logs = [];\nLogger.SERVER_URL = \"https://devai.freeschema.com/api/v1/add-logs\";\nLogger.LOG_LEVELS = [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"];\nLogger.SYNC_INTERVAL_MS = 300 * 1000;\nLogger.nextSyncTime = null;\n// Private auto-sync interval management\nLogger.autoSyncInterval = null;\n// Ensure logs are managed automatically\n(() => {\n    console.log(\"Initializing Logger with auto-sync mechanism.\");\n    Logger.startAutoSync();\n})();\n/**\n *\n * @param cname The name of the cookie\n * @returns Cookie value\n */\nexport function getCookie(cname) {\n    let name = cname + \"=\";\n    let decodedCookie = decodeURIComponent(document.cookie);\n    let ca = decodedCookie.split(';');\n    for (let i = 0; i < ca.length; i++) {\n        let c = ca[i];\n        while (c.charAt(0) == ' ') {\n            c = c.substring(1);\n        }\n        if (c.indexOf(name) == 0) {\n            return c.substring(name.length, c.length);\n        }\n    }\n    return \"\";\n}\n","export function CheckForConnectionDeletion(newConnections = [], oldConnections = []) {\n    // for(let i=0; i<oldConnections.length; i++){\n    //     if(Array.isArray(newConnections)){\n    //         if(!newConnections.find(obj => obj.id === oldConnections[i].id)){\n    //             ConnectionData.RemoveConnection(oldConnections[i]);\n    //        }\n    //     }\n    // }\n}\nexport function CheckForConnectionDeletionWithIds(newConnectionIds = [], oldConnections = []) {\n    // for(let i=0; i<oldConnections.length; i++){\n    //     if(!newConnectionIds.includes(oldConnections[i].id)){\n    //           ConnectionData.RemoveConnection(oldConnections[i]);\n    //     }\n    // }\n}\n","/**\n *\n * @param ms The time required to wait before executing this function\n * @param callback This is the function that needs to be executed\n * @returns returns a promise for the resolve\n */\nexport function DelayFunctionExecution(ms, callback) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(callback);\n        }, ms);\n    });\n}\n","import { FreeSchemaResponse } from \"../../DataStructures/Responses/ErrorResponse\";\nexport function HandleHttpError(response) {\n    if (response.status == 401 || response.status == 406) {\n        let errorResponse = new FreeSchemaResponse(response.statusText, false, response.status, \"\");\n        errorResponse.setUrl(response.url);\n        throw errorResponse;\n    }\n    else if (response.status == 500) {\n        let errorResponse = new FreeSchemaResponse(response.statusText, false, response.status, \"\");\n        errorResponse.setUrl(response.url);\n        throw errorResponse;\n    }\n}\nexport function HandleInternalError(error, url = \"\") {\n    if (error.status) {\n        let errorResponse = new FreeSchemaResponse(error.message, false, error.status, error.stack);\n        errorResponse.setUrl(url);\n        throw errorResponse;\n    }\n    else {\n        let errorResponse = new FreeSchemaResponse(error.message, false, 500, error.stack);\n        errorResponse.setUrl(url);\n        throw errorResponse;\n    }\n    throw error;\n}\n","export function removeThePrefix(inputString) {\n    if (inputString.startsWith(\"the_\")) {\n        return inputString.slice(4); // Removes the first 4 characters\n    }\n    return inputString; // Return as-is if it doesn't start with \"the_\"\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from '../../DataStructures/ConceptData';\nimport { CreateDefaultConcept } from '../../Services/CreateDefaultConcept';\nimport { default as GetTheConcept } from '../../Services/GetTheConcept';\n// this is a different type of recurisve fetch because here all the concepts and connections are passed as it is\n// so there is no need to query the connections and concepts from outside\n// if the concept connection is not found then it will go to the backend to fetch it\nexport function recursiveFetchNew(id_1, connectionList_1, conceptList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionList, conceptList, compositionList, visitedConcepts = []) {\n        var _a, _b;\n        let output = {};\n        const arroutput = [];\n        if (id == 0) {\n            return '';\n        }\n        // get concept from a list of concepts\n        let concept = getConceptFromList(conceptList, id);\n        // if we cannot find the concept from the concept list then find it from the backend\n        if ((concept == null || concept.id == 0) && id != null && id != undefined) {\n            // get the concepts tries to find it from the binary tree else from the backend if cannot find it then\n            // it will become null\n            const conceptString = yield GetTheConcept(id);\n            concept = conceptString;\n        }\n        if (concept.id != 0) {\n            // if the concept type is non existent then you have to get the type from the backend\n            if (concept.type == null) {\n                // get the concept type id from the concept which is stored in typeId\n                const toConceptTypeId = concept.typeId;\n                //\n                let toConceptType = getConceptFromList(conceptList, toConceptTypeId);\n                concept.type = toConceptType;\n                if (toConceptType == null &&\n                    toConceptTypeId != null &&\n                    toConceptTypeId != undefined) {\n                    const conceptString = yield GetTheConcept(toConceptTypeId);\n                    toConceptType = conceptString;\n                    concept.type = toConceptType;\n                }\n            }\n        }\n        //let mainString = concept?.type?.characterValue ?? ''\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            // loop over all the connections\n            for (let i = 0; i < connectionList.length; i++) {\n                // if the connection has the id that has been passed in the recursion\n                // oftheconceptId -----> toTheConceptId\n                // this only gives the valid concept id that are inside of this id\n                if (connectionList[i].ofTheConceptId == id) {\n                    // then take out the toTheConceptId from the connection\n                    const toConceptId = connectionList[i].toTheConceptId;\n                    if (compositionList.includes(id)) {\n                        // convert the toTheConceptId to a real Concept Object\n                        let toConcept = getConceptFromList(conceptList, toConceptId);\n                        // get the concept\n                        if ((toConcept == null || toConcept.id == 0) &&\n                            toConceptId != null &&\n                            toConceptId != undefined) {\n                            const conceptString = yield GetTheConcept(toConceptId);\n                            toConcept = conceptString;\n                        }\n                        // if the toConcept is valid\n                        if (toConcept.id != 0) {\n                            if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                                // get the type in casee type is not defined\n                                const toConceptTypeId = toConcept.typeId;\n                                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                                toConcept.type = toConceptType;\n                                if (toConceptType == null &&\n                                    toConceptTypeId != null &&\n                                    toConceptTypeId != undefined) {\n                                    const conceptString = yield GetTheConcept(toConceptTypeId);\n                                    toConceptType = conceptString;\n                                    toConcept.type = toConceptType;\n                                }\n                            }\n                        }\n                        // the regex to filter out the the_ from the type concepts\n                        const regex = 'the_';\n                        // then create the key of the key value pair that is the type of the concept\n                        const localmainString = (_b = (_a = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : '';\n                        // replace the the_ with an empty string\n                        const localKey = localmainString.replace(regex, '');\n                        // if the  type  is a number then put it inside of an object\n                        if (isNaN(Number(localKey))) {\n                            if (localKey) {\n                                const result = yield recursiveFetchNew(toConceptId, connectionList, conceptList, compositionList, visitedConcepts);\n                                output[localKey] = result;\n                            }\n                        }\n                        else {\n                            // if the type is a number then put it inside an array\n                            const result = yield recursiveFetchNew(toConceptId, connectionList, conceptList, compositionList, visitedConcepts);\n                            arroutput[localKey] = result;\n                            output = arroutput;\n                        }\n                    }\n                }\n            }\n        }\n        return output;\n    });\n}\n// gets the concept from the list of concepts using the conceptId\nfunction getConceptFromList(conceptList, conceptId) {\n    let concept = CreateDefaultConcept();\n    for (let i = 0; i < conceptList.length; i++) {\n        if (conceptId == conceptList[i].id) {\n            concept = conceptList[i];\n            return concept;\n        }\n    }\n    return concept;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConceptsData } from '../../DataStructures/ConceptData';\nimport { GetAllConnectionsOfComposition } from '../../Api/GetAllConnectionsOfComposition';\nimport { GetConnectionBulk } from '../../Api/GetConnectionBulk';\nimport { GetConcept } from '../../Api/GetConcept';\nimport { recursiveFetchNew } from './BuildComposition';\nimport { recursiveFetch } from '../GetComposition';\nimport { Composition } from '../../DataStructures/Composition/Composition';\nimport { CompositionBinaryTree } from '../../DataStructures/Composition/CompositionBinaryTree';\nimport { BulkConceptGetterApi } from '../../Api/GetConceptBulk';\n// get the composition with the passed id\n// here an optional parameter is passed which will pass the internal connections if given\n// else the function is designed to get the internal connections itself\nexport function GetCompositionWithCache(id_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionListPassed = []) {\n        var _a, _b;\n        let connectionList = [];\n        const conceptIdList = [];\n        let returnOutput = {};\n        let output = {};\n        const x = yield CompositionBinaryTree.getNodeFromTree(id);\n        const compositionList = [];\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            const conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        if (x == null) {\n            let connectionListString = [];\n            if (connectionListPassed.length > 0) {\n                connectionListString = getMyConnections(id, connectionListPassed);\n            }\n            else {\n                connectionListString = yield GetAllConnectionsOfComposition(id);\n            }\n            connectionList = connectionListString;\n            //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n            for (let i = 0; i < connectionList.length; i++) {\n                if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                    compositionList.push(connectionList[i].ofTheConceptId);\n                    conceptIdList.push(connectionList[i].ofTheConceptId);\n                }\n                if (!conceptIdList.includes(connectionList[i].toTheConceptId)) {\n                    conceptIdList.push(connectionList[i].toTheConceptId);\n                }\n            }\n            SaveToCompositionCache(concept, connectionList, conceptIdList, compositionList);\n            let visitedConcepts = [];\n            output = yield recursiveFetch(id, connectionList, compositionList, visitedConcepts);\n            const mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : '';\n            returnOutput[mainString] = output;\n        }\n        else {\n            output = x.value.GetDataCache();\n            returnOutput = output;\n        }\n        if (concept.id == 0) {\n            return '';\n        }\n        return returnOutput;\n    });\n}\n// this gets the list of connections of a composition from a list of bulk connection pull\nfunction getMyConnections(id, connectionList) {\n    const connections = [];\n    for (let i = 0; i < connectionList.length; i++) {\n        if (connectionList[i].typeId == id) {\n            connections.push(connectionList[i]);\n        }\n    }\n    return connections;\n}\n// get the composition with the passed id\n// here an optional parameter is passed which will pass the internal connections if given\n// else the function is designed to get the internal connections itself\n// this function has a  format of data -- id\nexport function GetCompositionWithDataIdWithCache(id_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionListPassed = []) {\n        var _a, _b;\n        let FinalReturn = {};\n        let connectionList = [];\n        const conceptIdList = [];\n        let output;\n        const returnOutput = {};\n        const x = yield CompositionBinaryTree.getNodeFromTree(id);\n        const compositionList = [];\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            const conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        if (x == null) {\n            let connectionListString = [];\n            if (connectionListPassed.length > 0) {\n                connectionListString = getMyConnections(id, connectionListPassed);\n            }\n            else {\n                connectionListString = yield GetAllConnectionsOfComposition(id);\n            }\n            connectionList = connectionListString;\n            //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n            for (let i = 0; i < connectionList.length; i++) {\n                if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                    compositionList.push(connectionList[i].ofTheConceptId);\n                    conceptIdList.push(connectionList[i].ofTheConceptId);\n                }\n                if (!conceptIdList.includes(connectionList[i].toTheConceptId)) {\n                    conceptIdList.push(connectionList[i].toTheConceptId);\n                }\n            }\n            SaveToCompositionCache(concept, connectionList, conceptIdList, compositionList);\n            output = yield recursiveFetch(id, connectionList, compositionList);\n            const mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : '';\n            returnOutput[mainString] = output;\n            FinalReturn[\"created_at\"] = concept.entryTimeStamp;\n            FinalReturn['data'] = returnOutput;\n            FinalReturn['id'] = id;\n        }\n        else {\n            output = x.value.GetDataCache();\n            FinalReturn = output;\n        }\n        if (concept.id == 0) {\n            return '';\n        }\n        return FinalReturn;\n    });\n}\n// this function needs to be passed with bulk compositions and bulk internal connections of them\n// so that i can conver them to actual list of compositions\nexport function GetCompositionWithDataIdBulk(ids, connections) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connectionList = [];\n        const compositions = [];\n        const newConnections = yield GetConnectionBulk(connections);\n        connectionList = newConnections;\n        for (let i = 0; i < ids.length; i++) {\n            const output = yield GetCompositionWithDataIdWithCache(ids[i], connectionList);\n            if (output) {\n                compositions.push(output);\n            }\n        }\n        return compositions;\n    });\n}\nfunction SaveToCompositionCache(concept, connections, conceptIdList, numbers) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const composition = new Composition();\n        const concepts = yield BulkConceptGetter(conceptIdList);\n        composition.connections = connections;\n        composition.concepts = concepts;\n        composition.id = concept.id;\n        composition.subcompositions = numbers;\n        composition.mainConcept = concept;\n        let visitedConcepts = [];\n        const output = yield recursiveFetchNew(concept.id, connections, concepts, numbers, visitedConcepts);\n        composition.cached = output;\n        CompositionBinaryTree.addCompositionToTree(composition);\n    });\n}\nfunction BulkConceptGetter(conceptIds) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let conceptList = [];\n        const bulkConceptFetch = [];\n        for (let i = 0; i < (conceptIds === null || conceptIds === void 0 ? void 0 : conceptIds.length); i++) {\n            const conceptUse = yield ConceptsData.GetConcept(conceptIds[i]);\n            if (conceptUse.id == 0) {\n                bulkConceptFetch.push(conceptIds[i]);\n            }\n            else {\n                conceptList.push(conceptUse);\n            }\n        }\n        if ((bulkConceptFetch === null || bulkConceptFetch === void 0 ? void 0 : bulkConceptFetch.length) == 0) {\n            return conceptList;\n        }\n        else {\n            conceptList = yield BulkConceptGetterApi(bulkConceptFetch);\n        }\n        return conceptList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateDefaultConcept } from '../CreateDefaultConcept';\nimport { Composition } from '../../DataStructures/Composition/Composition';\nimport MakeTheInstanceConcept from '../MakeTheInstanceConcept';\nimport { createTheConnection } from '../../Services/CreateTheConnection';\n// create a composition with caching mechanism\nexport function CreateTheCompositionWithCache(json_1) {\n    return __awaiter(this, arguments, void 0, function* (json, ofTheConceptId = null, ofTheConceptUserId = null, mainKey = null, userId = null, accessId = null, sessionInformationId = null, composition = null) {\n        const localUserId = userId !== null && userId !== void 0 ? userId : 999;\n        const localAccessId = accessId !== null && accessId !== void 0 ? accessId : 4;\n        const localSessionId = sessionInformationId !== null && sessionInformationId !== void 0 ? sessionInformationId : 999;\n        let MainKeyLocal = mainKey !== null && mainKey !== void 0 ? mainKey : 0;\n        let MainConcept = CreateDefaultConcept();\n        if (composition == null) {\n            // if no composition is passed then create a new composition\n            composition = new Composition();\n        }\n        for (const key in json) {\n            if (typeof json[key] == 'object' || Array.isArray(json[key])) {\n                const conceptString = yield MakeTheInstanceConcept(key, '', true, localUserId, localAccessId, localSessionId);\n                const concept = conceptString;\n                // if (typeof json[key] != 'string' && typeof json[key] != 'number') {\n                if (ofTheConceptId == null && ofTheConceptUserId == null) {\n                    // if there is no parent conceptId and conceptUserId passed then we know this is the main concept\n                    // everything is related to this concept.\n                    let localMainKey = MainKeyLocal;\n                    MainConcept = concept;\n                    localMainKey = concept.id;\n                    MainKeyLocal = concept.id;\n                    composition.concepts.push(concept);\n                    composition.id = concept.id;\n                    yield CreateTheCompositionWithCache(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId, composition);\n                }\n                else {\n                    // this is the concept which has parent passed onto it and this is a subcomposition\n                    const ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                    const ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 999;\n                    const localMainKey = MainKeyLocal;\n                    MainConcept = concept;\n                    composition.concepts.push(concept);\n                    const connectionString = yield createTheConnection(ofThe, ofTheUser, concept.id, localMainKey);\n                    const connection = connectionString;\n                    composition.connections.push(connection);\n                    yield CreateTheCompositionWithCache(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId, composition);\n                }\n                if (json[key] != null && json[key] != undefined) {\n                    composition.subcompositions.push(concept.id);\n                }\n            }\n            else {\n                // this is the part where the concept is now a key value pair and has the actual data\n                const ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                const ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 999;\n                const localMainKey = MainKeyLocal;\n                const conceptString = yield MakeTheInstanceConcept(key, json[key], false, localUserId, localAccessId, localSessionId);\n                const concept = conceptString;\n                composition.concepts.push(concept);\n                const connectionString = yield createTheConnection(ofThe, ofTheUser, concept.id, localMainKey);\n                const connection = connectionString;\n                composition.connections.push(connection);\n            }\n        }\n        // return the main concept\n        return MainConcept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConceptByCharacterValue } from \"../../Api/GetConceptByCharacterValue\";\nimport { GetConceptByCharacterAndCategoryDirectApi } from \"../../Api/SearchConcept/GetConceptByCharacterAndCategoryDirect\";\nimport { ConceptsData, CreateDefaultConcept, SplitStrings } from \"../../app\";\nexport function GetConceptByCharacterAndCategory(character) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = CreateDefaultConcept();\n        if (character == \"the\") {\n            concept.id = 1;\n            concept.typeId = 5;\n            concept.characterValue = \"the\";\n            return concept;\n        }\n        let splittedStringArray = SplitStrings(character);\n        if (splittedStringArray.length > 1) {\n            let category = 1;\n            let prefix = yield GetConceptByCharacterAndCategory(splittedStringArray[0]);\n            if (prefix.id != 0) {\n                category = prefix.id;\n            }\n            concept = yield GetConceptByCharacterAndCategoryFromMemory(character, category);\n        }\n        else if (splittedStringArray[0] == character) {\n            concept = yield GetConceptByCharacter(character);\n        }\n        return concept;\n    });\n}\nexport function GetConceptByCharacter(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = yield ConceptsData.GetConceptByCharacterAndTypeLocal(characterValue, 51);\n        if (concept.id == 0) {\n            concept = yield GetConceptByCharacterValue(characterValue);\n        }\n        return concept;\n    });\n}\nexport function GetConceptByCharacterAndCategoryFromMemory(character, category) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = yield ConceptsData.GetConceptByCharacterAndCategoryLocal(character, category);\n        if (concept.id == 0) {\n            concept = yield GetConceptByCharacterAndCategoryDirectApi(character, category);\n        }\n        return concept;\n    });\n}\n","import { Connection } from \"../../DataStructures/Connection\";\nimport { CreateDefaultConcept } from \"../CreateDefaultConcept\";\nimport { CreateDefaultLConcept } from \"../Local/CreateDefaultLConcept\";\nexport function convertFromConceptToLConcept(concept) {\n    var _a, _b;\n    const LConcept = CreateDefaultLConcept();\n    LConcept.id = concept.id;\n    LConcept.ghostId = concept.ghostId;\n    LConcept.userId = concept.userId;\n    LConcept.accessId = concept.accessId;\n    LConcept.categoryId = concept.categoryId;\n    LConcept.characterValue = concept.characterValue;\n    LConcept.entryTimeStamp = concept.entryTimeStamp;\n    LConcept.typeId = concept.typeId;\n    LConcept.type = concept.type;\n    LConcept.isTemp = false;\n    LConcept.typeCharacter = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n    return LConcept;\n}\nexport function convertFromLConceptToConcept(lconcept) {\n    const concept = CreateDefaultConcept();\n    concept.id = lconcept.id;\n    concept.ghostId = lconcept.ghostId;\n    concept.userId = lconcept.userId;\n    concept.accessId = lconcept.accessId;\n    concept.entryTimeStamp = lconcept.entryTimeStamp;\n    concept.typeId = lconcept.typeId;\n    concept.categoryId = lconcept.categoryId;\n    return concept;\n}\nexport function convertFromConnectionToLConnection(connection) {\n    const Lconnection = new Connection(0, 0, 0, 0, 0, 0, 0);\n    Lconnection.id = connection.id;\n    Lconnection.ghostId = connection.ghostId;\n    Lconnection.accessId = connection.accessId;\n    Lconnection.ofTheConceptId = connection.ofTheConceptId;\n    Lconnection.toTheConceptId = connection.toTheConceptId;\n    Lconnection.entryTimeStamp = connection.entryTimeStamp;\n    Lconnection.typeId = connection.typeId;\n    Lconnection.isTemp = false;\n    return Lconnection;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DelayFunctionExecution } from \"../app\";\nimport { getObjectsFromIndexDb } from \"../Database/indexeddb\";\nimport { ConceptsData } from \"../DataStructures/ConceptData\";\nimport { IdentifierFlags } from \"../DataStructures/IdentifierFlags\";\n/**\n * This function builds up the binary tree on startup from the indexdb\n */\nexport default function CreateConceptBinaryTreeFromIndexDb() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let conceptList = yield getObjectsFromIndexDb(\"concept\");\n            if (Array.isArray(conceptList)) {\n                for (let i = 0; i < conceptList.length; i++) {\n                    let concept = conceptList[i];\n                    ConceptsData.AddConceptToMemory(concept);\n                }\n            }\n            IdentifierFlags.isDataLoaded = true;\n            IdentifierFlags.isCharacterLoaded = true;\n            IdentifierFlags.isTypeLoaded = true;\n        }\n        catch (error) {\n            yield DelayFunctionExecution(2000, CreateConceptBinaryTreeFromIndexDb());\n            let errorObject = {\n                \"message\": \"Cannot create Binary Tree Concept\",\n                \"ok\": false,\n                \"status\": 400,\n                \"data\": error\n            };\n            throw errorObject;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConnectionOfTheConcept } from \"../Api/GetConnectionOfTheConcept\";\nimport { Logger, sendMessage, serviceWorker } from \"../app\";\nimport { Connection } from \"../DataStructures/Connection\";\nimport { SyncData } from \"../DataStructures/SyncData\";\nimport { CreateDefaultConcept } from \"./CreateDefaultConcept\";\nimport { CreateTheConnectionGeneral } from \"./CreateTheConnectionGeneral\";\nimport { DeleteConnectionById } from \"./DeleteConnection\";\nimport GetTheConcept from \"./GetTheConcept\";\nimport MakeTheInstanceConcept from \"./MakeTheInstanceConcept\";\nexport function CreateConnectionBetweenTwoConcepts(ofTheConcept_1, toTheConcept_1, linker_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConcept, toTheConcept, linker, both = false, count = false) {\n        var _a, _b;\n        let startTime = performance.now();\n        if (serviceWorker) {\n            const res = yield sendMessage('CreateConnectionBetweenTwoConcepts', { ofTheConcept, toTheConcept, linker, both, count });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let userId = ofTheConcept.userId;\n        let accessId = 4;\n        if (both) {\n            let prefix1 = ((_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\";\n            let linkerAdd1 = linker + \"_by\";\n            let backwardLinker = prefix1 + \"_\" + linkerAdd1;\n            if (count) {\n                yield CountRelationship(linkerAdd1, toTheConcept, userId);\n            }\n            let connectionConceptReverse = yield MakeTheInstanceConcept(\"connection\", backwardLinker, false, 999, 999, 999);\n            let newConnection = new Connection(0, toTheConcept.id, ofTheConcept.id, userId, connectionConceptReverse.id, 1000, accessId);\n            SyncData.AddConnection(newConnection);\n        }\n        let prefix = ((_b = ofTheConcept.type) === null || _b === void 0 ? void 0 : _b.characterValue) + \"_s\";\n        let linkerAdd = linker + \"_s\";\n        let forwardLinker = prefix + \"_\" + linkerAdd;\n        if (count) {\n            yield CountRelationship(linkerAdd, ofTheConcept, userId);\n        }\n        let connectionConcept = yield MakeTheInstanceConcept(\"connection\", forwardLinker, false, 999, 999, 999);\n        let newConnection = new Connection(0, ofTheConcept.id, toTheConcept.id, userId, connectionConcept.id, 1000, accessId);\n        SyncData.AddConnection(newConnection);\n        // Add Log\n        Logger.logInfo(startTime, \"unknown\", \"create\", \"unknown\", undefined, 500, newConnection, \"CreateConnectionBetweenTwoConcepts\", [ofTheConcept, toTheConcept, linker, both, count], \"unknown\", undefined);\n        return newConnection;\n    });\n}\nexport function CountRelationship(linker_1, concept_1) {\n    return __awaiter(this, arguments, void 0, function* (linker, concept, passedUserId = null) {\n        var _a;\n        let concept1 = concept;\n        let userId = passedUserId !== null && passedUserId !== void 0 ? passedUserId : concept.userId;\n        let accessId = 4;\n        let sessionInformationId = 999;\n        let forwardLinkerCount = linker + \"_count\";\n        let forwardLinkerCountString = ((_a = concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\" + \"_\" + forwardLinkerCount;\n        let forwardLinkerCountConcept = yield MakeTheInstanceConcept(\"connection\", forwardLinkerCountString, false, userId, accessId, sessionInformationId);\n        let connectionsString = yield GetConnectionOfTheConcept(forwardLinkerCountConcept.id, concept.id, userId, 10, 1);\n        let connections = connectionsString;\n        let countConceptList = [];\n        let countConcept = CreateDefaultConcept();\n        for (let i = 0; i < connections.length; i++) {\n            let toConcept = yield GetTheConcept(connections[i].toTheConceptId);\n            countConceptList.push(toConcept);\n        }\n        if (countConceptList.length < 1) {\n            countConcept = yield MakeTheInstanceConcept(\"count\", \"1\", false, userId, accessId, sessionInformationId);\n        }\n        else {\n            let oldcountConcept = countConceptList[0];\n            let count = 0;\n            try {\n                count = Number(oldcountConcept.characterValue);\n            }\n            catch (ex) {\n                count = 0;\n            }\n            count = count + 1;\n            countConcept = yield MakeTheInstanceConcept(\"count\", count.toString(), false, userId, accessId, sessionInformationId);\n            for (let i = 0; i < connections.length; i++) {\n                DeleteConnectionById(connections[i].id);\n            }\n        }\n        let newConnection = new Connection(0, concept1.id, countConcept.id, concept1.userId, forwardLinkerCountConcept.id, 1000, accessId);\n        yield SyncData.AddConnection(newConnection);\n    });\n}\nexport function CreateConnectionBetweenTwoConceptsGeneral(ofTheConcept_1, toTheConcept_1, linker_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConcept, toTheConcept, linker, both = false, count = false) {\n        var _a, _b;\n        let userId = ofTheConcept.userId;\n        let accessId = 4;\n        if (both) {\n            let prefix1 = ((_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\";\n            let linkerAdd1 = linker + \"_by\";\n            let backwardLinker = prefix1 + \"_\" + linkerAdd1;\n            if (count) {\n                yield CountRelationship(linkerAdd1, toTheConcept, userId);\n            }\n            let connectionConceptReverse = yield MakeTheInstanceConcept(\"connection\", backwardLinker, false, 999, 999, 999);\n            let newConnection = new Connection(0, toTheConcept.id, ofTheConcept.id, userId, connectionConceptReverse.id, 1000, accessId);\n            SyncData.AddConnection(newConnection);\n        }\n        let prefix = ((_b = ofTheConcept.type) === null || _b === void 0 ? void 0 : _b.characterValue) + \"_s\";\n        let linkerAdd = linker + \"_s\";\n        let forwardLinker = prefix + \"_\" + linkerAdd;\n        if (count) {\n            yield CountRelationship(linkerAdd, ofTheConcept, userId);\n        }\n        let connectionConcept = yield MakeTheInstanceConcept(\"connection\", forwardLinker, false, 999, 999, 999);\n        let newConnection = yield CreateTheConnectionGeneral(ofTheConcept.id, ofTheConcept.userId, toTheConcept.id, connectionConcept.id, 1000, accessId);\n        return newConnection;\n    });\n}\n","import { Concept } from \"../DataStructures/Concept\";\nexport function CreateDefaultConcept() {\n    let created_on = new Date();\n    let updated_on = new Date();\n    let concept = new Concept(0, 0, 0, 0, 0, \"0\", 0, false, created_on, updated_on, \"0\");\n    return concept;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { sendMessage, serviceWorker } from \"../app\";\nimport { CreateDefaultConcept } from \"./CreateDefaultConcept\";\nimport { createTheConnection } from \"./CreateTheConnection\";\nimport MakeTheInstanceConcept from \"./MakeTheInstanceConcept\";\nexport default function CreateTheComposition(json_1) {\n    return __awaiter(this, arguments, void 0, function* (json, ofTheConceptId = null, ofTheConceptUserId = null, mainKey = null, userId = null, accessId = null, sessionInformationId = null) {\n        if (serviceWorker) {\n            const res = yield sendMessage('CreateTheComposition', { json, ofTheConceptId, ofTheConceptUserId, mainKey, userId, accessId, sessionInformationId });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let localUserId = userId !== null && userId !== void 0 ? userId : 999;\n        let localAccessId = accessId !== null && accessId !== void 0 ? accessId : 4;\n        let localSessionId = sessionInformationId !== null && sessionInformationId !== void 0 ? sessionInformationId : 999;\n        let MainKeyLocal = mainKey !== null && mainKey !== void 0 ? mainKey : 0;\n        let MainConcept = CreateDefaultConcept();\n        for (const key in json) {\n            if ((typeof json[key] != 'string' && typeof json[key] != 'number')) {\n                if (ofTheConceptId == null && ofTheConceptUserId == null) {\n                    let localMainKey = MainKeyLocal;\n                    let conceptString = yield MakeTheInstanceConcept(key, \"\", true, localUserId, localAccessId, localSessionId);\n                    let concept = conceptString;\n                    MainConcept = concept;\n                    localMainKey = concept.id;\n                    MainKeyLocal = concept.id;\n                    yield CreateTheComposition(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId);\n                }\n                else {\n                    let ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                    let ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 999;\n                    let localMainKey = MainKeyLocal;\n                    let conceptString = yield MakeTheInstanceConcept(key, \"\", true, localUserId, localAccessId, localSessionId);\n                    let concept = conceptString;\n                    MainConcept = concept;\n                    yield createTheConnection(ofThe, ofTheUser, concept.id, localMainKey);\n                    yield CreateTheComposition(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId);\n                }\n            }\n            else {\n                let ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                let ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 10267;\n                let localMainKey = MainKeyLocal;\n                let conceptString = yield MakeTheInstanceConcept(key, json[key].toString(), false, localUserId, localAccessId, localSessionId);\n                let concept = conceptString;\n                yield createTheConnection(ofThe, ofTheUser, concept.id, localMainKey);\n            }\n        }\n        return MainConcept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateTheConceptApi } from \"../Api/Create/CreateTheConceptApi\";\nimport { Concept } from \"../DataStructures/Concept\";\nimport { ReservedIds } from \"../DataStructures/ReservedIds\";\nimport { SyncData } from \"../DataStructures/SyncData\";\nimport { ConceptsData } from \"../app\";\nexport default function CreateTheConcept(referent, userId, categoryId, typeId, referentId, accessId, typeCharacter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let id = yield ReservedIds.getId();\n        let isNew = true;\n        let created_on = new Date();\n        let updated_on = new Date();\n        // let concept = new Concept(id,userId,typeId,typeUserId,categoryId,categoryUserId,referentId, referentUserId, referent, securityId,\n        // securityUserId,accessId, accessUserId,sessionInformationId, sessionInformationUserId,isNew,created_on,updated_on);\n        let concept = new Concept(id, userId, typeId, categoryId, referentId, referent, accessId, isNew, created_on, updated_on, typeCharacter);\n        concept.isTemp = false;\n        SyncData.AddConcept(concept);\n        return concept;\n    });\n}\nexport function CreateTheConceptTemporary(referent, userId, categoryId, typeId, referentId, accessId, typeCharacter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let id = yield ReservedIds.getId();\n        let isNew = true;\n        let created_on = new Date();\n        let updated_on = new Date();\n        // let concept = new Concept(id,userId,typeId,typeUserId,categoryId,referentId, referent,\n        //     accessId,isNew,created_on, updated_on);\n        let concept = new Concept(id, userId, typeId, categoryId, referentId, referent, accessId, isNew, created_on, updated_on, typeCharacter);\n        concept.isTemp = true;\n        return concept;\n    });\n}\nexport function CreateTheConceptImmediate(referent, userId, categoryId, typeId, referentId, accessId, typeCharacter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let id = yield ReservedIds.getId();\n        let isNew = false;\n        let created_on = new Date();\n        let updated_on = new Date();\n        // let concept = new Concept(id,userId,typeId,typeUserId,categoryId,categoryUserId,referentId, referentUserId, referent, securityId,\n        //     securityUserId,accessId, accessUserId,sessionInformationId, sessionInformationUserId,isNew,created_on, updated_on);\n        let concept = new Concept(id, userId, typeId, categoryId, referentId, referent, accessId, isNew, created_on, updated_on, typeCharacter);\n        ConceptsData.AddConcept(concept);\n        CreateTheConceptApi([concept]);\n        //SyncData.AddConcept(concept);\n        return concept;\n    });\n}\n","import { Connection } from \"../DataStructures/Connection\";\nimport { SyncData } from \"../DataStructures/SyncData\";\nimport { HandleInternalError } from \"./Common/ErrorPosting\";\n/**\n * This function is used to create a connection that is internal(inside of a composition)\n * @param ofTheConceptId Start of the connection\n * @param userId user id fo the user creating the connection\n * @param toTheConceptId the end of the connection\n * @param typeId this is the type of the connection\n * @returns\n */\nexport function createTheConnection(ofTheConceptId, userId, toTheConceptId, typeId) {\n    var orderId = 1;\n    var localUserId = userId;\n    var accessId = 4;\n    var connection = new Connection(0, ofTheConceptId, toTheConceptId, localUserId, typeId, orderId, accessId);\n    if (ofTheConceptId == toTheConceptId) {\n        connection.ofTheConceptId = 0;\n        connection.toTheConceptId = 1;\n        return connection;\n    }\n    try {\n        connection.isTemp = true;\n        connection.id = Math.floor(Math.random() * 100000000);\n        SyncData.AddConnection(connection);\n    }\n    catch (error) {\n        HandleInternalError(error);\n    }\n    return connection;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Connection } from \"../DataStructures/Connection\";\nimport { ReservedConnectionIds } from \"../DataStructures/ReservedIds\";\nimport { FreeSchemaResponse } from \"../DataStructures/Responses/ErrorResponse\";\nimport { SyncData } from \"../DataStructures/SyncData\";\nexport function CreateTheConnectionGeneral(ofTheConceptId_1, ofTheConceptUserId_1, toTheConceptId_1, typeId_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConceptId, ofTheConceptUserId, toTheConceptId, typeId, orderId = 1, accessId = 4) {\n        if (ofTheConceptId > 0 && toTheConceptId > 0) {\n            var userId = ofTheConceptUserId;\n            var id = yield ReservedConnectionIds.getId();\n            var connection = new Connection(id, ofTheConceptId, toTheConceptId, userId, typeId, orderId, accessId);\n            if (ofTheConceptId == toTheConceptId) {\n                connection.ofTheConceptId = 0;\n                connection.toTheConceptId = 1;\n                return connection;\n            }\n            // this will cause the connection to go and update the existing with the reserved id\n            connection.toUpdate = true;\n            connection.isTemp = false;\n            SyncData.AddConnection(connection);\n            return connection;\n        }\n        else {\n            throw new FreeSchemaResponse(\"cannot create connection because id are negative \", false, 400, \"\");\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DeleteUserInBackend } from \"../Api/Delete/DeleteUserInBackend\";\nimport DeleteTheConcept from \"../Api/DeleteTheConcept\";\nimport { BinaryCharacterTree } from \"../DataStructures/BinaryCharacterTree\";\nimport { BinaryTree } from \"../DataStructures/BinaryTree\";\nimport { BinaryTypeTree } from \"../DataStructures/BinaryTypeTree\";\nimport { ConnectionOfTheTree } from \"../DataStructures/ConnectionBinaryTree/ConnectionOfTheTree\";\nimport { LocalConceptsData, sendMessage, serviceWorker } from \"../app\";\nimport GetTheConcept from \"./GetTheConcept\";\nexport function DeleteConceptById(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('DeleteConceptById', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        if (id > 0) {\n            var concept = yield GetTheConcept(id);\n            if (concept.id > 0) {\n                var typeId = concept.typeId;\n                var character = concept.characterValue;\n                yield BinaryTypeTree.removeTypeConcept(typeId, id);\n                yield BinaryCharacterTree.removeNodeByCharacter(character, id);\n                //removeFromDatabase(\"concept\",id);\n                yield DeleteTheConcept(id);\n                yield BinaryTree.removeNodeFromTree(id);\n                yield ConnectionOfTheTree.removeNodeFromTree(id);\n            }\n        }\n        else {\n            LocalConceptsData.RemoveConceptById(id);\n        }\n    });\n}\nexport function DeleteUser(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('DeleteUser', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        if (id > 0) {\n            DeleteUserInBackend(id);\n        }\n        else {\n            LocalConceptsData.RemoveConceptById(id);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport DeleteTheConnection from \"../Api/DeleteTheConnection\";\nimport { ConnectionBinaryTree } from \"../DataStructures/ConnectionBinaryTree/ConnectionBinaryTree\";\nimport { LocalConnectionData } from \"../DataStructures/Local/LocalConnectionData\";\nimport { sendMessage, serviceWorker } from \"../app\";\nimport { GetConnectionById } from \"./GetConnections\";\nexport function DeleteConnectionById(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('DeleteConnectionById', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        if (id > 0) {\n            let connection = yield GetConnectionById(id);\n            yield DeleteTheConnection(id);\n            //removeFromDatabase(\"connection\",id);\n            ConnectionBinaryTree.removeNodeFromTree(id);\n        }\n        else {\n            LocalConnectionData.RemoveConnectionById(id);\n        }\n        //ConnectionTypeTree.removeTypeConcept(connection.typeId,id);\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAllLinkerConnectionsFromTheConcept } from \"../Api/GetAllLinkerConnectionsFromTheConcept\";\nimport { GetAllLinkerConnectionsToTheConcept } from \"../Api/GetAllLinkerConnectionsToTheConcept\";\nimport { ConnectionData, DeleteConnectionById, GetConceptByCharacter, MakeTheTypeConceptApi, sendMessage, serviceWorker } from \"../app\";\n/**\n *\n * @param id\n * @param linker\n * @returns\n */\nexport function DeleteConnectionByType(id, linker) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('DeleteConnectionByType', { id, linker });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let externalConnections = yield GetAllLinkerConnectionsFromTheConcept(id);\n        for (let i = 0; i < externalConnections.length; i++) {\n            ConnectionData.AddConnection(externalConnections[i]);\n        }\n        let connections = yield ConnectionData.GetConnectionsOfConcept(id);\n        let concept = yield GetConceptByCharacter(linker);\n        let toDelete = [];\n        for (let i = 0; i < connections.length; i++) {\n            if (connections[i].typeId == concept.id) {\n                toDelete.push(connections[i]);\n            }\n        }\n        for (let i = 0; i < toDelete.length; i++) {\n            DeleteConnectionById(toDelete[i].id);\n        }\n    });\n}\n/**\n * This function returns all the connections from the ofTheConceptId and connection type\n * @param id ofTheConceptId\n * @param linker the connection type\n * @returns Array of connections\n */\nexport function GetAllTheConnectionsByTypeAndOfTheConcept(id_1, linker_1) {\n    return __awaiter(this, arguments, void 0, function* (id, linker, reverse = false) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetAllTheConnectionsByTypeAndOfTheConcept', { id, linker, reverse });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let toDelete = [];\n        if (reverse) {\n            let externalConnections = yield GetAllLinkerConnectionsToTheConcept(id);\n            let concept = yield MakeTheTypeConceptApi(linker, 999);\n            for (let i = 0; i < externalConnections.length; i++) {\n                if (externalConnections[i].typeId == concept.id) {\n                    toDelete.push(externalConnections[i]);\n                }\n            }\n        }\n        else {\n            let externalConnections = yield GetAllLinkerConnectionsFromTheConcept(id);\n            for (let i = 0; i < externalConnections.length; i++) {\n                ConnectionData.AddConnection(externalConnections[i]);\n            }\n            let connections = yield ConnectionData.GetConnectionsOfConcept(id);\n            let concept = yield GetConceptByCharacter(linker);\n            for (let i = 0; i < connections.length; i++) {\n                if (connections[i].typeId == concept.id) {\n                    toDelete.push(connections[i]);\n                }\n            }\n        }\n        return toDelete;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConceptBulk } from \"../Api/GetConceptBulk\";\n/**\n * This function takes in a list of connections and in bulk gets the concepts that are related with these connections.\n * @param connectionList list of connections whose concepts need to be found out.\n */\nexport function FindConceptsFromConnections() {\n    return __awaiter(this, arguments, void 0, function* (connectionList = []) {\n        let ConceptList = [];\n        if (connectionList.length > 0) {\n            for (let i = 0; i < connectionList.length; i++) {\n                if (!ConceptList.includes(connectionList[i].ofTheConceptId)) {\n                    ConceptList.push(connectionList[i].ofTheConceptId);\n                }\n                if (!ConceptList.includes(connectionList[i].toTheConceptId)) {\n                    ConceptList.push(connectionList[i].toTheConceptId);\n                }\n            }\n            yield GetConceptBulk(ConceptList);\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { sendMessage, serviceWorker } from \"../app\";\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nexport function FindConnectionsOfCompositionsBulkInMemory() {\n    return __awaiter(this, arguments, void 0, function* (composition_ids = []) {\n        if (serviceWorker) {\n            const res = yield sendMessage('FindConnectionsOfCompositionsBulkInMemory', { composition_ids });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let FinalConnectionList = [];\n        for (let i = 0; i < composition_ids.length; i++) {\n            // let connectionList = await ConnectionData.GetConnectionsOfCompositionLocal(composition_ids[i]);\n            let connectionList = yield ConnectionData.GetConnectionsOfConcept(composition_ids[i]);\n            FinalConnectionList.push(...connectionList);\n        }\n        return FinalConnectionList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConcept } from \"../Api/GetConcept\";\nimport { GetAllConnectionsOfComposition } from \"../Api/GetAllConnectionsOfComposition\";\nimport { ConceptsData } from \"../DataStructures/ConceptData\";\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nimport { GetTheConcept, sendMessage, serviceWorker } from \"../app\";\nexport function GetCompositionById(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionById', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let connectionList = [];\n        let returnOutput = {};\n        let connectionListString = yield GetAllConnectionsOfComposition(id);\n        connectionList = connectionListString;\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        return { \"connectionList\": connectionList, \"compositionList\": compositionList };\n    });\n}\n/**\n * ## format JUSTDATA ##\n * this function builds the composition with the main id as the point of building.\n * @param id id of the main composition that you want to build\n * @param connectionList  list of connections\n * @param compositionList list of of_the_concept_ids for all the connections.\n * @returns\n */\nexport function RecursiveFetchBuildLayer(id, connectionList, compositionList) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let returnOutput = {};\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        return returnOutput;\n    });\n}\n/**\n * ## format DATAID ##\n * this function builds the composition with the main id as the point of building.\n * @param id id of the main composition that you want to build\n * @param connectionList  list of connections\n * @param compositionList list of of_the_concept_ids for all the connections.\n * @returns\n */\nexport function RecursiveFetchBuildLayerDataId(id, connectionList, compositionList) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let returnOutput = {};\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        let FinalReturn = {};\n        FinalReturn['created_at'] = concept.entryTimeStamp;\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        return FinalReturn;\n    });\n}\n/**\n * ## format Normal ##\n * this function builds the composition with the main id as the point of building.\n * @param id id of the main composition that you want to build\n * @param connectionList  list of connections\n * @param compositionList list of of_the_concept_ids for all the connections.\n * @returns\n */\nexport function RecursiveFetchBuildLayerNormal(id, connectionList, compositionList) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let returnOutput = {};\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetchConceptNormal(concept, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        return returnOutput;\n    });\n}\n/**\n * ## format JUSTDATA ##\n * this function builds the composition with the main id as the point of building.\n * This just requires the id\n * @param id id of the main composition that you want to build\n * @param connectionList  list of connections\n * @param compositionList list of of_the_concept_ids for all the connections.\n * @returns\n */\nexport function GetComposition(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (serviceWorker) {\n            const res = yield sendMessage('GetComposition', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let connectionList = [];\n        let returnOutput = {};\n        let connectionListString = yield GetAllConnectionsOfComposition(id);\n        connectionList = connectionListString;\n        console.log(\"this is the connection list online\", connectionList);\n        //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        return returnOutput;\n    });\n}\nexport function GetCompositionWithAllIds(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        let connectionList = [];\n        let returnOutput = {};\n        let connectionListString = yield GetAllConnectionsOfComposition(id);\n        connectionList = connectionListString;\n        //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetchWithSubCompositions(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        return returnOutput;\n    });\n}\n/**\n * ### Format JUSTDATA ###\n * This function just builds data from the memory.\n * This is a function that takes on all the concepts and connections of the concept (as a composition ) and builds\n * it into a json data.\n * @param id this id is just used to get all the composition data from the concepts and connections in memory\n * @returns\n */\nexport function GetCompositionFromMemory(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionFromMemory', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let connectionList = [];\n        let returnOutput = {};\n        //connectionList = await ConnectionData.GetConnectionsOfConcept(id);\n        connectionList = yield ConnectionData.GetConnectionsOfCompositionLocal(id);\n        //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetchConcept(concept, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        return returnOutput;\n    });\n}\n/**\n * ### Format Normal ###\n * This function just builds data from the memory.\n * This is a function that takes on all the concepts and connections of the concept (as a composition ) and builds\n * it into a json data.\n * @param id this id is just used to get all the composition data from the concepts and connections in memory\n * @returns\n */\nexport function GetCompositionFromMemoryNormal(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionFromMemoryNormal', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let connectionList = [];\n        let returnOutput = {};\n        //connectionList = await ConnectionData.GetConnectionsOfConcept(id);\n        connectionList = yield ConnectionData.GetConnectionsOfCompositionLocal(id);\n        //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetchConceptNormal(concept, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        return returnOutput;\n    });\n}\n/**\n * ### Format DATAIDDATE ####\n * Gets data just from memory\n * @param id\n * @returns\n */\nexport function GetCompositionWithIdFromMemory(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionWithIdFromMemory', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let FinalReturn = {};\n        let connectionList = [];\n        let returnOutput = {};\n        // connectionList = await ConnectionData.GetConnectionsOfConcept(id);\n        try {\n            connectionList = yield ConnectionData.GetConnectionsOfCompositionLocal(id);\n            let compositionList = [];\n            for (let i = 0; i < connectionList.length; i++) {\n                if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                    compositionList.push(connectionList[i].ofTheConceptId);\n                }\n            }\n            let concept = yield ConceptsData.GetConcept(id);\n            if (concept.id == 0 && id != null && id != undefined) {\n                let conceptString = yield GetConcept(id);\n                concept = conceptString;\n            }\n            let output = yield recursiveFetchConcept(concept, connectionList, compositionList);\n            // let output = await recursiveFetchConceptSingleLoop(concept, connectionList,compositionList );\n            let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n            returnOutput[mainString] = output;\n            FinalReturn['created_at'] = concept.entryTimeStamp;\n            FinalReturn['data'] = returnOutput;\n            FinalReturn['id'] = id;\n        }\n        catch (error) {\n            console.log(\"this is the exception in GetCompositionWithIdFromMemory\", id);\n        }\n        return FinalReturn;\n    });\n}\n/**\n * ### Format Normal ####\n * Gets data just from memory\n * @param id\n * @returns\n */\nexport function GetCompositionFromMemoryWithConnections(id, connectionList) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionFromMemoryWithConnections', { id, connectionList });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let returnOutput = {};\n        // connectionList = await ConnectionData.GetConnectionsOfConcept(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetchConcept(concept, connectionList, compositionList);\n        // let output = await recursiveFetchConceptSingleLoop(concept, connectionList,compositionList );\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        let FinalReturn = {};\n        FinalReturn['created_at'] = concept.entryTimeStamp;\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        return FinalReturn;\n    });\n}\n/**\n * ### Format DATAIDDATE ####\n * Gets data just from memory\n * @param id\n * @returns\n */\nexport function GetCompositionWithIdFromMemoryFromConnection(id, connectionList) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionWithIdFromMemory', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let returnOutput = {};\n        // connectionList = await ConnectionData.GetConnectionsOfConcept(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetchConcept(concept, connectionList, compositionList);\n        console.log(\"this is the output\", output, concept);\n        // let output = await recursiveFetchConceptSingleLoop(concept, connectionList,compositionList );\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        let FinalReturn = {};\n        FinalReturn['created_at'] = concept.entryTimeStamp;\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        return FinalReturn;\n    });\n}\n/**\n * ### Format DATAIDDATE ####\n * ### experimental ####\n * This is the new format that needs to work with a single or max two loops\n * @param id the id whose composition needs to be created\n * @returns\n */\nexport function GetCompositionWithIdFromMemoryNew(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionWithIdFromMemoryNew', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let connectionList = [];\n        let returnOutput = {};\n        //connectionList = await ConnectionData.GetConnectionsOfConcept(id);\n        connectionList = yield ConnectionData.GetConnectionsOfCompositionLocal(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            console.log(\"this concept you cannot find \", id);\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let startTime = new Date().getTime();\n        //console.log(\"this is the connection list which has to be looped\", connectionList);\n        let output = yield recursiveFetchConceptSingleLoop(concept, connectionList, compositionList);\n        console.log(\"this is the time for the data to be made\", new Date().getTime() - startTime);\n        // let output = await recursiveFetchConceptSingleLoop(concept, connectionList,compositionList );\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput = output;\n        let FinalReturn = {};\n        FinalReturn['created_at'] = concept.entryTimeStamp;\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        return FinalReturn;\n    });\n}\n/**\n * ### Format DATAIDDATE #####\n * ### This just returns composition from memory and not from anywhere else.\n * @param id\n * @returns\n */\nexport function GetCompositionWithIdAndDateFromMemory(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionWithIdAndDateFromMemory', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let connectionList = [];\n        let returnOutput = {};\n        connectionList = yield ConnectionData.GetConnectionsOfCompositionLocal(id);\n        //connectionList = await ConnectionData.GetConnectionsOfConcept(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        let FinalReturn = {};\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        FinalReturn['created_at'] = concept.entryTimeStamp;\n        return FinalReturn;\n    });\n}\nexport function GetCompositionWithIdFromMemoryFromConnections(id_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionList = []) {\n        var _a, _b;\n        let returnOutput = {};\n        //connectionList = await ConnectionData.GetConnectionsOfCompositionLocal(id);\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        let FinalReturn = {};\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        return FinalReturn;\n    });\n}\n/**\n * #### Format DATAID ####\n * ## This will return the composition even if it is not in the local memory ##\n * @param id\n * @returns\n */\nexport function GetCompositionWithId(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionWithId', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let connectionList = [];\n        let returnOutput = {};\n        let connectionListString = yield GetAllConnectionsOfComposition(id);\n        connectionList = connectionListString;\n        let compositionList = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                compositionList.push(connectionList[i].ofTheConceptId);\n            }\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if (concept.id == 0 && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        let output = yield recursiveFetch(id, connectionList, compositionList);\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        returnOutput[mainString] = output;\n        let FinalReturn = {};\n        FinalReturn['data'] = returnOutput;\n        FinalReturn['id'] = id;\n        return FinalReturn;\n    });\n}\n/**\n * ## Format justdata ###\n * ## This contains a concept in the parameter so that you dont have to again find the concept ##\n * This function takes concepts and connections and then builds a json.\n * @param concept The concept that needs to get other concepts that are inside of it.\n * @param connectionList List of connections that are available in the composition. We have to loop over it.\n * @param compositionList Composition list is the list of concepts that have connections inside of them.\n * @param visitedConcepts This is a checking mechanism to not go in loops. So preferably pass an empty array.\n * @returns\n */\nexport function recursiveFetchConcept(concept_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (concept, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d;\n        let output = {};\n        let arroutput = [];\n        let id = concept.id;\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            for (let i = 0; i < connectionList.length; i++) {\n                if (connectionList[i].ofTheConceptId == id) {\n                    if (id != connectionList[i].toTheConceptId) {\n                        let toConceptId = connectionList[i].toTheConceptId;\n                        let toConcept = yield ConceptsData.GetConcept(toConceptId);\n                        if ((toConcept == null || toConcept.id == 0) && toConceptId != null && toConceptId != undefined) {\n                            let conceptString = yield GetConcept(toConceptId);\n                            toConcept = conceptString;\n                        }\n                        if (toConcept.id != 0) {\n                            if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                                let toConceptTypeId = toConcept.typeId;\n                                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                                toConcept.type = toConceptType;\n                                if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                                    let conceptString = yield GetConcept(toConceptTypeId);\n                                    toConceptType = conceptString;\n                                    toConcept.type = toConceptType;\n                                }\n                            }\n                        }\n                        let regex = \"the_\";\n                        let localmainString = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"\";\n                        let localKey = localmainString.replace(regex, \"\");\n                        if (isNaN(Number(localKey))) {\n                            if (localKey) {\n                                const result = yield recursiveFetchConcept(toConcept, connectionList, compositionList, visitedConcepts);\n                                output[localKey] = result;\n                            }\n                        }\n                        else {\n                            const result = yield recursiveFetchConcept(toConcept, connectionList, compositionList, visitedConcepts);\n                            arroutput[localKey] = result;\n                            output = arroutput;\n                        }\n                    }\n                    else {\n                        console.log(\"this is the faulty connection \", connectionList[i]);\n                    }\n                }\n            }\n        }\n        return output;\n    });\n}\n/**\n* ## Format Normal ###\n* ## This contains a concept in the parameter so that you dont have to again find the concept ##\n* This function takes concepts and connections and then builds a json.\n* @param concept The concept that needs to get other concepts that are inside of it.\n* @param connectionList List of connections that are available in the composition. We have to loop over it.\n* @param compositionList Composition list is the list of concepts that have connections inside of them.\n* @param visitedConcepts This is a checking mechanism to not go in loops. So preferably pass an empty array.\n* @returns\n*/\nexport function recursiveFetchConceptNormal(concept_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (concept, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d;\n        let startTime = new Date().getTime();\n        let output = {};\n        let arroutput = [];\n        let id = concept.id;\n        output[\"id\"] = id;\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            for (let i = 0; i < connectionList.length; i++) {\n                if (connectionList[i].ofTheConceptId == id) {\n                    if (id != connectionList[i].toTheConceptId) {\n                        let toConceptId = connectionList[i].toTheConceptId;\n                        let toConcept = yield ConceptsData.GetConcept(toConceptId);\n                        if ((toConcept == null || toConcept.id == 0) && toConceptId != null && toConceptId != undefined) {\n                            let conceptString = yield GetConcept(toConceptId);\n                            toConcept = conceptString;\n                        }\n                        if (toConcept.id != 0) {\n                            if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                                let toConceptTypeId = toConcept.typeId;\n                                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                                toConcept.type = toConceptType;\n                                if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                                    let conceptString = yield GetConcept(toConceptTypeId);\n                                    toConceptType = conceptString;\n                                    toConcept.type = toConceptType;\n                                }\n                            }\n                        }\n                        let regex = \"the_\";\n                        let localmainString = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"\";\n                        let localKey = localmainString.replace(regex, \"\");\n                        if (isNaN(Number(localKey))) {\n                            if (localKey) {\n                                const result = yield recursiveFetchConcept(toConcept, connectionList, compositionList, visitedConcepts);\n                                output[localKey] = result;\n                            }\n                        }\n                        else {\n                            const result = yield recursiveFetchConcept(toConcept, connectionList, compositionList, visitedConcepts);\n                            arroutput[localKey] = result;\n                            output = arroutput;\n                        }\n                    }\n                    else {\n                        console.log(\"this is the faulty connection \", connectionList[i]);\n                    }\n                }\n            }\n        }\n        // console.log(\"second loop normal\", new Date().getTime() - startTime);\n        return output;\n    });\n}\n/**\n * ## experimental ##\n* This function takes concepts and connections and then builds a json.\n* @param concept The concept that needs to get other concepts that are inside of it.\n* @param connectionList List of connections that are available in the composition. We have to loop over it.\n* @param compositionList Composition list is the list of concepts that have connections inside of them.\n* @param visitedConcepts This is a checking mechanism to not go in loops. So preferably pass an empty array.\n* @returns\n*/\nexport function recursiveFetchConceptSingleLoop(concept_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (concept, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        let output = {};\n        let id = concept.id;\n        let startTime = new Date().getTime();\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        if (!compositionList.includes(id)) {\n            let myString = mainString;\n            let returnoutput = { [myString]: concept === null || concept === void 0 ? void 0 : concept.characterValue };\n            return returnoutput;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            for (let i = 0; i < connectionList.length; i++) {\n                let newData = yield GetTheConcept(connectionList[i].ofTheConceptId);\n                let toConcept = yield GetTheConcept(connectionList[i].toTheConceptId);\n                connectionList[i].ofConcept = newData;\n                connectionList[i].toConcept = toConcept;\n                let ofKey = newData.id;\n                let toConceptKey = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"\";\n                let regex = \"the_\";\n                let localmainString = toConceptKey;\n                let localToKey = localmainString.replace(regex, \"\");\n                if (output[ofKey] == undefined || output[ofKey] == null) {\n                    output[ofKey] = {};\n                }\n                output[ofKey][localToKey] = toConcept.characterValue;\n            }\n        }\n        let finalOutput = {};\n        for (let i = 0; i < connectionList.length; i++) {\n            let ofConcept = connectionList[i].ofConcept;\n            let toConcept = connectionList[i].toConcept;\n            let ofConceptKey = (_f = (_e = ofConcept === null || ofConcept === void 0 ? void 0 : ofConcept.type) === null || _e === void 0 ? void 0 : _e.characterValue) !== null && _f !== void 0 ? _f : \"\";\n            let toConceptKey = (_h = (_g = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _g === void 0 ? void 0 : _g.characterValue) !== null && _h !== void 0 ? _h : \"\";\n            let regex = \"the_\";\n            let localmainString = toConceptKey;\n            let localToKey = localmainString.replace(regex, \"\");\n            if (finalOutput[ofConcept.id] == undefined || finalOutput[ofConcept.id] == null) {\n                finalOutput[ofConcept.id] = {};\n            }\n            let internalOutput = finalOutput[ofConcept.id];\n            if (internalOutput[ofConceptKey] == undefined || internalOutput[ofConceptKey] == null) {\n                internalOutput[ofConceptKey] = {};\n            }\n            if (output[connectionList[i].ofTheConceptId] != undefined && output[connectionList[i].toTheConceptId] != undefined) {\n                internalOutput[ofConceptKey][localToKey] = output[toConcept.id];\n            }\n            else {\n                internalOutput[ofConceptKey][localToKey] = toConcept.characterValue;\n            }\n        }\n        return finalOutput[concept.id];\n    });\n}\n/**\n * ## Format justdata ##\n * @param id\n * @param connectionList\n * @param compositionList\n * @param visitedConcepts\n * @returns\n */\nexport function recursiveFetch(id_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d;\n        let output = {};\n        let arroutput = [];\n        if (id == 0) {\n            return null;\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if ((concept == null || concept.id == 0) && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        if (concept.id != 0) {\n            if (concept.type == null) {\n                let toConceptTypeId = concept.typeId;\n                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                concept.type = toConceptType;\n                if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                    let conceptString = yield GetConcept(toConceptTypeId);\n                    toConceptType = conceptString;\n                    concept.type = toConceptType;\n                }\n            }\n        }\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            for (let i = 0; i < connectionList.length; i++) {\n                let insideTime = new Date().getTime();\n                if (connectionList[i].ofTheConceptId == id) {\n                    if (id != connectionList[i].toTheConceptId) {\n                        let toConceptId = connectionList[i].toTheConceptId;\n                        let toConcept = yield ConceptsData.GetConcept(toConceptId);\n                        if ((toConcept == null || toConcept.id == 0) && toConceptId != null && toConceptId != undefined) {\n                            let conceptString = yield GetConcept(toConceptId);\n                            toConcept = conceptString;\n                        }\n                        if (toConcept.id != 0) {\n                            if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                                let toConceptTypeId = toConcept.typeId;\n                                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                                toConcept.type = toConceptType;\n                                if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                                    let conceptString = yield GetConcept(toConceptTypeId);\n                                    toConceptType = conceptString;\n                                    toConcept.type = toConceptType;\n                                }\n                            }\n                        }\n                        let regex = \"the_\";\n                        let localmainString = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"\";\n                        let localKey = localmainString.replace(regex, \"\");\n                        if (isNaN(Number(localKey))) {\n                            if (localKey) {\n                                const result = yield recursiveFetch(toConceptId, connectionList, compositionList, visitedConcepts);\n                                output[localKey] = result;\n                            }\n                        }\n                        else {\n                            const result = yield recursiveFetch(toConceptId, connectionList, compositionList, visitedConcepts);\n                            arroutput[localKey] = result;\n                            output = arroutput;\n                        }\n                    }\n                    else {\n                        console.log(\"this is the faulty connection \", connectionList[i]);\n                    }\n                }\n            }\n        }\n        return output;\n    });\n}\nexport function recursiveFetchWithSubCompositions(id_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d;\n        let output = {};\n        let arroutput = [];\n        if (id == 0) {\n            return null;\n        }\n        let concept = yield ConceptsData.GetConcept(id);\n        if ((concept == null || concept.id == 0) && id != null && id != undefined) {\n            let conceptString = yield GetConcept(id);\n            concept = conceptString;\n        }\n        if (concept.id != 0) {\n            if (concept.type == null) {\n                let toConceptTypeId = concept.typeId;\n                let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                concept.type = toConceptType;\n                if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                    let conceptString = yield GetConcept(toConceptTypeId);\n                    toConceptType = conceptString;\n                    concept.type = toConceptType;\n                }\n            }\n        }\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"\";\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            output[\"id\"] = id;\n            for (let i = 0; i < connectionList.length; i++) {\n                if (connectionList[i].ofTheConceptId == id) {\n                    let toConceptId = connectionList[i].toTheConceptId;\n                    let toConcept = yield ConceptsData.GetConcept(toConceptId);\n                    if ((toConcept == null || toConcept.id == 0) && toConceptId != null && toConceptId != undefined) {\n                        let conceptString = yield GetConcept(toConceptId);\n                        toConcept = conceptString;\n                    }\n                    if (toConcept) {\n                        if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                            let toConceptTypeId = toConcept.typeId;\n                            let toConceptType = yield ConceptsData.GetConcept(toConceptTypeId);\n                            toConcept.type = toConceptType;\n                            if (toConceptType == null && toConceptTypeId != null && toConceptTypeId != undefined) {\n                                let conceptString = yield GetConcept(toConceptTypeId);\n                                toConceptType = conceptString;\n                                toConcept.type = toConceptType;\n                            }\n                        }\n                    }\n                    let regex = \"the_\";\n                    let localmainString = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"\";\n                    let localKey = localmainString.replace(regex, \"\");\n                    if (isNaN(Number(localKey))) {\n                        if (localKey) {\n                            const result = yield recursiveFetchWithSubCompositions(toConceptId, connectionList, compositionList);\n                            output[localKey] = result;\n                        }\n                    }\n                    else {\n                        const result = yield recursiveFetchWithSubCompositions(toConceptId, connectionList, compositionList);\n                        arroutput[localKey] = result;\n                        output = arroutput;\n                    }\n                }\n            }\n        }\n        return output;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAllConnectionsOfCompositionBulk } from \"../Api/GetAllConnectionsOfCompositionBulk\";\nimport { GetConnectionBulk } from \"../Api/GetConnectionBulk\";\nimport { ConnectionData, GetConceptBulk, sendMessage, serviceWorker } from \"../app\";\nimport { FindConnectionsOfCompositionsBulkInMemory } from \"./FindConnectionsOfCompositionBulkInMemory\";\nimport { GetCompositionFromMemory, GetCompositionFromMemoryNormal, GetCompositionFromMemoryWithConnections, GetCompositionWithIdFromMemory, GetCompositionWithIdFromMemoryFromConnection, GetCompositionWithIdFromMemoryNew } from \"./GetComposition\";\n/**\n * ## Format JUSTDATA ##\n * Function converts the conceptIds to json (compositions)\n * This function takes in the conceptIds and returns a list of compositions related to those concepts.\n * @param conceptIds  list of concept ids that are compositions.\n * @returns compositions\n */\nexport function GetCompositionBulk() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = []) {\n        yield GetAllConnectionsOfCompositionBulk(conceptIds);\n        let compositions = [];\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionFromMemory(conceptIds[i]);\n            compositions.push(comp);\n        }\n        return compositions;\n    });\n}\n/**\n * ## FORMAT DATAIDDATE ##\n * Function converts the conceptIds to json (compositions)\n * @param conceptIds this is the list of concept ids that should be converted to compostions in data - id format.\n * @returns list of compositions in the data - id format.\n */\nexport function GetCompositionBulkWithDataId() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = []) {\n        yield GetAllConnectionsOfCompositionBulk(conceptIds);\n        let compositions = [];\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionWithIdFromMemory(conceptIds[i]);\n            compositions.push(comp);\n        }\n        return compositions;\n    });\n}\n/**\n * ## FORMAT DATAIDDATE ##\n * This function converts the conceptIds and internal connectionIds to compositions in data-Id format.\n * @param conceptIds This is the list of concept ids that need to be converted to compositions.\n * @param connectionIds These are the internal connectionIds that need to be passed to create the compositions.\n * @returns list of compositions created from the passed conceptIds and connectionIds.\n */\nexport function GetCompositionFromConnectionsWithDataId() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connectionIds = []) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionFromConnectionsWithDataId', { conceptIds, connectionIds });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let newConnections = yield GetConnectionBulk(connectionIds);\n        let oldConnections = yield FindConnectionsOfCompositionsBulkInMemory(conceptIds);\n        //CheckForConnectionDeletionWithIds(connectionIds,oldConnections);\n        let compositions = [];\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionWithIdFromMemory(conceptIds[i]);\n            compositions.push(comp);\n        }\n        return compositions;\n    });\n}\n/**\n * ## FORMAT DATAIDDATE ##\n * This is just a different version of GetCompositionFromConnectionsWithDataId, This has the added functionality that\n * it also prints out internal connections.\n * This function converts the conceptIds and internal connectionIds to compositions in data-Id format.\n * @param conceptIds This is the list of concept ids that need to be converted to compositions.\n * @param connectionIds These are the internal connectionIds that need to be passed to create the compositions.\n * @returns list of compositions created from the passed conceptIds and connectionIds.\n */\nexport function GetCompositionFromConnectionsWithDataIdFromConnections() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connectionIds = []) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionFromConnectionsWithDataIdFromConnections', { conceptIds, connectionIds });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let newConnections = yield GetConnectionBulk(connectionIds);\n        //CheckForConnectionDeletionWithIds(connectionIds,oldConnections);\n        let compositions = [];\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionWithIdFromMemoryFromConnection(conceptIds[i], newConnections);\n            compositions.push(comp);\n        }\n        return compositions;\n    });\n}\n/**\n * ## Format DATAIDDATE ##\n * This function converts the conceptIds and internal connectionIds to compositions in data-Id format with index(conceptId).\n * @param conceptIds This is the list of concept ids that need to be converted to compositions.\n * @param connectionIds These are the internal connectionIds that need to be passed to create the compositions.\n * @returns dictionary of compositions created from the passed conceptIds and connectionIds with conceptId as its index .\n */\nexport function GetCompositionFromConnectionsWithDataIdIndex() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connectionIds = []) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionFromConnectionsWithDataIdIndex', { conceptIds, connectionIds });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let newConnections = yield GetConnectionBulk(connectionIds);\n        let myNewConnections = newConnections;\n        let oldConnections = yield FindConnectionsOfCompositionsBulkInMemory(conceptIds);\n        //CheckForConnectionDeletionWithIds(connectionIds,oldConnections);\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionWithIdFromMemory(conceptIds[i]);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n/**\n * ## Format is dictionary with key as concept id and value as data (json) ##\n * This function converts the conceptIds and internal connectionIds to compositions format with index(conceptId).\n * @param conceptIds This is the list of concept ids that need to be converted to compositions.\n * @param connectionIds These are the internal connectionIds that need to be passed to create the compositions.\n * @returns dictionary of compositions created from the passed conceptIds and connectionIds with conceptId as its index .\n */\nexport function GetCompositionFromConnectionsWithIndex() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connectionIds = []) {\n        let newConnections = yield GetConnectionBulk(connectionIds);\n        let myNewConnections = newConnections;\n        let oldConnections = yield FindConnectionsOfCompositionsBulkInMemory(conceptIds);\n        //CheckForConnectionDeletionWithIds(connectionIds,oldConnections);\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionFromMemory(conceptIds[i]);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n/**\n * ## FORMAT DATAIDDATE ##\n * This is just a different version of GetCompositionFromConnectionsWithDataId, This has the added functionality that\n * it also prints out internal connections.\n * This function converts the conceptIds and internal connectionIds to compositions in data-Id format.\n * @param conceptIds This is the list of concept ids that need to be converted to compositions.\n * @param connectionIds These are the internal connectionIds that need to be passed to create the compositions.\n * @returns list of compositions created from the passed conceptIds and connectionIds.\n */\nexport function GetCompositionFromConnectionsWithIndexFromConnections() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connectionIds = []) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionFromConnectionsWithIndexFromConnections', { conceptIds, connectionIds });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let newConnections = yield GetConnectionBulk(connectionIds);\n        //CheckForConnectionDeletionWithIds(connectionIds,oldConnections);\n        let compositions = [];\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionFromMemoryWithConnections(conceptIds[i], newConnections);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n/**\n * Used to prefetch all the connections and their related concepts.\n * @param connectionIds these are the connection ids that are used to fetch all the connections and also their related concepts.\n * @returns all the connections that are passed as ids.\n */\nexport function GetConnectionDataPrefetch(connectionIds) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetConnectionDataPrefetch', { connectionIds });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let remainingConnections = [];\n        let connectionsAll = [];\n        let remainingIds = {};\n        for (let i = 0; i < connectionIds.length; i++) {\n            let connection = yield ConnectionData.GetConnection(connectionIds[i]);\n            // console.log(\"this is the connection fetch\", connection);\n            if (connection.id == 0) {\n                remainingConnections.push(connectionIds[i]);\n            }\n            else {\n                connectionsAll.push(connection);\n            }\n        }\n        for (let i = 0; i < connectionIds.length; i++) {\n            remainingIds[connectionIds[i]] = false;\n        }\n        //await ConnectionData.GetConnectionBulkData(connectionIds, connectionsAll, remainingIds);\n        // for(let key in remainingIds){\n        //     if(remainingIds[key] == false){\n        //         remainingConnections.push(Number(key));\n        //     }\n        // }\n        // remainingConnections = connectionIds;\n        let prefetchConcepts = [];\n        let connectionsAllLocal = yield GetConnectionBulk(remainingConnections);\n        connectionsAll = [...connectionsAll, ...connectionsAllLocal];\n        for (let j = 0; j < connectionsAll.length; j++) {\n            prefetchConcepts.push(connectionsAll[j].ofTheConceptId);\n            prefetchConcepts.push(connectionsAll[j].toTheConceptId);\n        }\n        yield GetConceptBulk(prefetchConcepts);\n        return connectionsAll;\n    });\n}\n/**\n * ## Format DATAIDDATE ##\n * This function converts the conceptIds and internal connections to create compositions.\n * Format is of a dictionary with ids as the key and value is the composition data.\n * @param conceptIds these are the concept ids that need to be fetched to create their compositions\n * @param connections these are the connections that are used to create the structure.\n * @returns a dictionary / object that has key as their conceptId and the value as their composition object.\n */\nexport function GetCompositionFromConnectionsWithDataIdInObject() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connections = []) {\n        // get all the connections that are not available in memory from the api.\n        yield GetConnectionBulk(connections);\n        // create a list of compositions from the fetched concepts and connections.\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionWithIdFromMemory(conceptIds[i]);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n/**\n * ## Format DATAIDDATE ##\n * ## duplicate ##\n * This function converts the conceptIds and internal connections to create compositions.\n * @param conceptIds these are the concept ids that need to be fetched to create their compositions\n * @param connections these are the connections that are used to create the structure.\n * @returns a dictionary / object that has key as their conceptId and the value as their composition object.\n */\nexport function GetCompositionFromConnectionsWithDataIdInObjectNew() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connections = []) {\n        // get all the connections that are not available in memory from the api.\n        yield GetConnectionBulk(connections);\n        // create a list of compositions from the fetched concepts and connections.\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionWithIdFromMemoryNew(conceptIds[i]);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n/**\n * ## Format justdata ##\n * This function converts the conceptIds and internal connections to create compositions.\n * @param conceptIds these are the concept ids that need to be fetched to create their compositions\n * @param connections these are the connections that are used to create the structure.\n * @returns a dictionary / object that has key as their conceptId and the value as their composition object.\n */\nexport function GetCompositionFromConnectionsInObject() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connections = []) {\n        // get all the connections that are not available in memory from the api.\n        yield GetConnectionBulk(connections);\n        // create a list of compositions from the fetched concepts and connections.\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionFromMemory(conceptIds[i]);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n/**\n * ## Format Normal ##\n * This function converts the conceptIds and internal connections to create compositions.\n * @param conceptIds these are the concept ids that need to be fetched to create their compositions\n * @param connections these are the connections that are used to create the structure.\n * @returns a dictionary / object that has key as their conceptId and the value as their composition object.\n */\nexport function GetCompositionFromConnectionsInObjectNormal() {\n    return __awaiter(this, arguments, void 0, function* (conceptIds = [], connections = []) {\n        // get all the connections that are not available in memory from the api.\n        yield GetConnectionBulk(connections);\n        // create a list of compositions from the fetched concepts and connections.\n        let compositions = {};\n        for (let i = 0; i < conceptIds.length; i++) {\n            let comp = yield GetCompositionFromMemoryNormal(conceptIds[i]);\n            compositions[conceptIds[i]] = comp;\n        }\n        return compositions;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAllConceptsByType } from \"../Api/GetAllConceptsByType\";\nimport { GetAllConnectionsOfCompositionBulk } from \"../Api/GetAllConnectionsOfCompositionBulk\";\nimport { ConceptsData } from \"../DataStructures/ConceptData\";\nimport { LocalConceptsData } from \"../DataStructures/Local/LocalConceptData\";\nimport { GetCompositionListLocal, GetCompositionLocalWithId, sendMessage, serviceWorker } from \"../app\";\nimport { GetCompositionFromMemory, GetCompositionWithIdFromMemory } from \"./GetComposition\";\nimport GetConceptByCharacter, { GetConceptByCharacterUpdated } from \"./GetConceptByCharacter\";\nimport GetConceptByCharacterLocal from \"./Local/GetConceptByCharacterLocal\";\n// get the list of compositions from the type \n// for eg get list of boomgpt\nexport function GetCompositionList(compositionName_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (compositionName, userId, inpage = 10, page = 1) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionList', { compositionName, userId, inpage, page });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let concept = yield GetConceptByCharacter(compositionName);\n        let CompositionList = [];\n        if (concept) {\n            yield GetAllConceptsByType(compositionName, userId);\n            let conceptList = yield ConceptsData.GetConceptsByTypeIdAndUser(concept.id, userId);\n            let startPage = inpage * (page - 1);\n            let prefetchComposition = [];\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    prefetchComposition.push(conceptList[i].id);\n                }\n            }\n            yield GetAllConnectionsOfCompositionBulk(prefetchComposition);\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    let compositionJson = yield GetCompositionFromMemory(conceptList[i].id);\n                    CompositionList.push(compositionJson);\n                }\n            }\n        }\n        return CompositionList;\n    });\n}\nexport function GetCompositionListAll(compositionName_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (compositionName, userId, inpage = 10, page = 1) {\n        let LocalCompositionList = GetCompositionListLocal(compositionName, userId);\n        let CompositionList = GetCompositionList(compositionName, userId);\n        let AllList = [];\n        Promise.race([LocalCompositionList, CompositionList])\n            .then((result) => {\n            console.log(\"Promise result\", result);\n            AllList.push(...result);\n        })\n            .catch((error) => {\n            console.log(\"error in handling\", error);\n        });\n        CompositionList.then((result) => {\n            console.log(\"This is the second promise result\", result);\n            AllList.push(...result);\n        });\n        return AllList;\n    });\n}\n// export async function GetCompositionListAllWithId(compositionName: string,userId:number,  inpage:number = 10, page:number =1){\n//    let LocalCompositionList =  await GetCompositionListLocalWithId(compositionName, userId);\n//    console.log(\"tbis is the local composition list\", LocalCompositionList);\n//    let CompositionList =    await GetCompositionListWithId(compositionName,userId)\n//    console.log(\"this is the online composition list\", CompositionList);\n//    let AllList: any[] = [];\n//    // Promise.race([LocalCompositionList, CompositionList])\n//    // .then((result)=> {\n//    //    console.log(\"Promise result\", result);\n//    //    AllList.push(...result);\n//    // })\n//    // .catch((error)=>{\n//    //    console.log(\"error in handling\", error);\n//    // });\n//    // CompositionList.then((result)=>{\n//    //    console.log(\"This is the second promise result\", result);\n//    //    AllList.push(...result);\n//    // })\n//    AllList.push(...LocalCompositionList);\n//    AllList.push(...CompositionList);\n//    return AllList;\n// }\nexport function GetCompositionListAllWithId(compositionName_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (compositionName, userId, inpage = 10, page = 1) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionListAllWithId', { compositionName, userId, inpage, page });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let conceptLocal = yield GetConceptByCharacterLocal(compositionName);\n        let conceptOnline = yield GetConceptByCharacter(compositionName);\n        let CompositionList = [];\n        let conceptList = [];\n        let conceptListLocal = [];\n        let finalLocal = [];\n        let conceptListOnline = [];\n        if (conceptLocal.id != 0) {\n            conceptListLocal = yield LocalConceptsData.GetConceptsByTypeIdAndUser(conceptLocal.id, userId);\n        }\n        if (conceptOnline.id != 0) {\n            yield GetAllConceptsByType(compositionName, userId);\n            conceptListOnline = yield ConceptsData.GetConceptsByTypeIdAndUser(conceptOnline.id, userId);\n            conceptList = conceptListOnline;\n        }\n        for (let i = 0; i < conceptListLocal.length; i++) {\n            let isDuplicate = false;\n            for (let j = 0; j < conceptListOnline.length; j++) {\n                if (conceptListLocal[i].ghostId == conceptListOnline[j].ghostId) {\n                    isDuplicate = true;\n                }\n            }\n            if (!isDuplicate) {\n                finalLocal.push(conceptListLocal[i]);\n            }\n        }\n        console.log(\"This is the all list\", finalLocal);\n        let AllList = [];\n        AllList = yield FormatTheConcepts(conceptList, finalLocal, inpage, page);\n        return AllList;\n    });\n}\nexport function GetCompositionListWithId(compositionName_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (compositionName, userId, inpage = 10, page = 1) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionListWithId', { compositionName, userId, inpage, page });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let concept = yield GetConceptByCharacter(compositionName);\n        let CompositionList = [];\n        if (concept) {\n            yield GetAllConceptsByType(compositionName, userId);\n            let conceptList = yield ConceptsData.GetConceptsByTypeIdAndUser(concept.id, userId);\n            let startPage = inpage * (page - 1);\n            let prefetchComposition = [];\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    prefetchComposition.push(conceptList[i].id);\n                }\n            }\n            yield GetAllConnectionsOfCompositionBulk(prefetchComposition);\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    let compositionJson = yield GetCompositionWithIdFromMemory(conceptList[i].id);\n                    CompositionList.push(compositionJson);\n                }\n            }\n        }\n        return CompositionList;\n    });\n}\nexport function GetCompositionListWithIdUpdated(compositionName_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (compositionName, userId, inpage = 10, page = 1) {\n        let concept = yield GetConceptByCharacterUpdated(compositionName);\n        let CompositionList = [];\n        if (concept) {\n            yield GetAllConceptsByType(compositionName, userId);\n            let conceptList = yield ConceptsData.GetConceptsByTypeIdAndUser(concept.id, userId);\n            let startPage = inpage * (page - 1);\n            let prefetchComposition = [];\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    prefetchComposition.push(conceptList[i].id);\n                }\n            }\n            yield GetAllConnectionsOfCompositionBulk(prefetchComposition);\n            for (let i = startPage; i < startPage + inpage; i++) {\n                if (conceptList[i]) {\n                    let compositionJson = yield GetCompositionWithIdFromMemory(conceptList[i].id);\n                    CompositionList.push(compositionJson);\n                }\n            }\n        }\n        return CompositionList;\n    });\n}\nexport function FormatTheConcepts(conceptList_1, localConceptList_1) {\n    return __awaiter(this, arguments, void 0, function* (conceptList, localConceptList, inpage = 10, page = 1) {\n        let CompositionList = [];\n        let startPage = inpage * (page - 1);\n        let prefetchComposition = [];\n        let localConceptLength = localConceptList.length;\n        for (let i = startPage; i < startPage + inpage - localConceptLength; i++) {\n            if (conceptList[i]) {\n                prefetchComposition.push(conceptList[i].id);\n            }\n        }\n        for (let i = 0; i < localConceptList.length; i++) {\n            let compositionJson = yield GetCompositionLocalWithId(localConceptList[i].id);\n            CompositionList.push(compositionJson);\n        }\n        yield GetAllConnectionsOfCompositionBulk(prefetchComposition);\n        for (let i = startPage; i < startPage + inpage - localConceptLength; i++) {\n            if (conceptList[i]) {\n                let compositionJson = yield GetCompositionWithIdFromMemory(conceptList[i].id);\n                CompositionList.push(compositionJson);\n            }\n        }\n        return CompositionList;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConceptByCharacterValue } from \"../Api/GetConceptByCharacterValue\";\nimport { sendMessage, serviceWorker } from \"../app\";\nimport { ConceptsData } from \"../DataStructures/ConceptData\";\nexport default function GetConceptByCharacter(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetConceptByCharacter', { characterValue });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let concept = yield ConceptsData.GetConceptByCharacter(characterValue);\n        let literalCharacter = `${characterValue}`;\n        if ((concept == null || (concept === null || concept === void 0 ? void 0 : concept.id) == 0) && literalCharacter) {\n            yield GetConceptByCharacterValue(characterValue);\n            concept = yield ConceptsData.GetConceptByCharacterAndTypeLocal(characterValue, 51);\n            if (concept.id == 0) {\n                concept = yield ConceptsData.GetConceptByCharacter(characterValue);\n            }\n        }\n        return concept;\n    });\n}\nexport function GetConceptByCharacterUpdated(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetConceptByCharacterUpdated', { characterValue });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let concept = yield ConceptsData.GetConceptByCharacter(characterValue);\n        let literalCharacter = `${characterValue}`;\n        if ((concept == null || (concept === null || concept === void 0 ? void 0 : concept.id) == 0) && literalCharacter) {\n            yield GetConceptByCharacterValue(characterValue);\n            concept = yield ConceptsData.GetConceptByCharacter(characterValue);\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetCompositionConnectionsBetweenTwoConcepts } from \"../Api/GetCompositionConnectionsBetweenTwoConcepts\";\nimport { CreateDefaultConcept, MakeTheTypeConceptApi, sendMessage, serviceWorker } from \"../app\";\nimport MakeTheInstanceConcept from \"./MakeTheInstanceConcept\";\n/**\n * This function will give you all the connections between two concepts by their linker or fullLinker\n * @param ofTheConcept start of the connecction\n * @param toTheConcept end of the connection\n * @param linker the primitive linkers with type connection (16) these are the old type of linkers (if you want full linker then put this as empty string)\n * @param fullLinker fullLinker is the modern linker (if you want linker then put this as empty string)\n * @param forward if you want to get the forward relation in the primitive linker put true else for backward linker false.\n * @returns list of connections\n */\nexport function GetConnectionBetweenTwoConceptsLinker(ofTheConcept_1, toTheConcept_1, linker_1, fullLinker_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConcept, toTheConcept, linker, fullLinker, forward = true) {\n        var _a, _b;\n        if (serviceWorker) {\n            const res = yield sendMessage('GetConnectionBetweenTwoConceptsLinker', { ofTheConcept, toTheConcept, linker, fullLinker, forward });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let typeConcept = CreateDefaultConcept();\n        if (linker != \"\") {\n            let typeLinker = \"\";\n            if (forward) {\n                let prefix = ((_a = ofTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\";\n                let linkerAdd = linker + \"_s\";\n                let forwardLinker = prefix + \"_\" + linkerAdd;\n                typeLinker = forwardLinker;\n            }\n            else {\n                let prefix1 = ((_b = toTheConcept.type) === null || _b === void 0 ? void 0 : _b.characterValue) + \"_s\";\n                let linkerAdd1 = linker + \"_by\";\n                let backwardLinker = prefix1 + \"_\" + linkerAdd1;\n                typeLinker = backwardLinker;\n            }\n            typeConcept = yield MakeTheInstanceConcept(\"connection\", typeLinker, false, 999);\n        }\n        if (fullLinker != \"\") {\n            typeConcept = yield MakeTheTypeConceptApi(fullLinker, 999);\n        }\n        let connections = [];\n        if (!forward)\n            connections = yield GetCompositionConnectionsBetweenTwoConcepts(toTheConcept.id, ofTheConcept.id, typeConcept.id);\n        else\n            connections = yield GetCompositionConnectionsBetweenTwoConcepts(ofTheConcept.id, toTheConcept.id, typeConcept.id);\n        return connections;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { AccessTracker } from \"../AccessTracker/accessTracker\";\nimport { GetConnection } from \"../Api/GetConnection\";\nimport { Logger, sendMessage, serviceWorker } from \"../app\";\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nexport function GetConnectionById(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let startTime = performance.now();\n        // Add connection id in access tracker\n        try {\n            AccessTracker.incrementConnection(id);\n        }\n        catch (_a) {\n            console.error(\"Error adding connections in access tracker\");\n        }\n        if (serviceWorker) {\n            const res = yield sendMessage('GetConnectionById', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let connection = yield ConnectionData.GetConnection(id);\n        if ((connection == null || connection.id == 0) && id != null && id != undefined) {\n            let connectionString = yield GetConnection(id);\n            connection = connectionString;\n        }\n        // Add Log\n        Logger.logInfo(startTime, \"unknown\", \"read\", \"unknown\", undefined, 200, connection, \"GetConnectionById\", [id], \"unknown\", undefined);\n        return connection;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from \"../DataStructures/ConnectionData\";\nimport { LocalConnectionData } from \"../DataStructures/Local/LocalConnectionData\";\nimport { getObjectsFromLocalIndexDb } from \"../Database/indexdblocal\";\nimport { getObjectsFromIndexDb } from \"../Database/indexeddb\";\nexport function GetConnectionsFromIndexDb() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let connectionList = yield getObjectsFromIndexDb(\"connection\");\n            if (Array.isArray(connectionList)) {\n                for (let i = 0; i < connectionList.length; i++) {\n                    ConnectionData.AddConnectionToMemory(connectionList[i]);\n                }\n            }\n        }\n        catch (error) {\n            let errorObject = {\n                \"message\": \"Cannot create Connection Binary Tree Concept\",\n                \"ok\": false,\n                \"status\": 400,\n                \"data\": error\n            };\n            throw errorObject;\n        }\n    });\n}\nexport function GetConnectionsFromIndexDbLocal() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let connectionList = yield getObjectsFromLocalIndexDb(\"localconnection\");\n            if (Array.isArray(connectionList)) {\n                for (let i = 0; i < connectionList.length; i++) {\n                    LocalConnectionData.AddConnectionToMemory(connectionList[i]);\n                }\n            }\n        }\n        catch (error) {\n            let errorObject = {\n                \"message\": \"Cannot create Local Connection Binary Tree Concept\",\n                \"ok\": false,\n                \"status\": 400,\n                \"data\": error\n            };\n            throw errorObject;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConceptByCharacterAndType } from \"../Api/GetConceptByCharacterAndType\";\nimport { GetConnectionOfTheConcept } from \"../Api/GetConnectionOfTheConcept\";\nimport { GetCompositionWithIdAndDateFromMemory } from \"./GetComposition\";\nimport GetTheConcept from \"./GetTheConcept\";\nimport { GetAllConnectionsOfCompositionBulk } from \"../Api/GetAllConnectionsOfCompositionBulk\";\nimport { Logger, sendMessage, serviceWorker } from \"../app\";\nexport function GetLink(id_1, linker_1) {\n    return __awaiter(this, arguments, void 0, function* (id, linker, inpage = 10, page = 1) {\n        var _a;\n        let startTime = performance.now();\n        if (serviceWorker) {\n            const res = yield sendMessage('GetLink', { id, linker, inpage, page });\n            console.log('data received from sw', res);\n            // Add Log\n            Logger.logInfo(startTime, \"unknown\", \"read\", \"unknown\", undefined, 200, res, \"GetLink\", ['id', 'linker', 'inpage', 'page'], \"unknown\", undefined);\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let output = [];\n        let concept = yield GetTheConcept(id);\n        let linkString = ((_a = concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\" + \"_\" + linker;\n        let relatedConceptString = yield GetConceptByCharacterAndType(linkString, 16);\n        let relatedConcept = relatedConceptString;\n        if (relatedConcept.id > 0) {\n            let connectionsString = yield GetConnectionOfTheConcept(relatedConcept.id, concept.id, concept.userId, inpage, page);\n            let connections = connectionsString;\n            let prefetch = [];\n            for (let i = 0; i < connections.length; i++) {\n                prefetch.push(connections[i].toTheConceptId);\n            }\n            yield GetAllConnectionsOfCompositionBulk(prefetch);\n            for (let i = 0; i < connections.length; i++) {\n                let toConceptId = connections[i].toTheConceptId;\n                let toConcept = yield GetTheConcept(toConceptId);\n                let newComposition = yield GetCompositionWithIdAndDateFromMemory(toConcept.id);\n                output.push(newComposition);\n            }\n        }\n        // Add Log\n        Logger.logInfo(startTime, \"unknown\", \"read\", \"unknown\", undefined, 200, output, \"GetLink\", ['id', 'linker', 'inpage', 'page'], \"unknown\", undefined);\n        return output;\n    });\n}\nexport function GetLinkRaw(id_1, linker_1) {\n    return __awaiter(this, arguments, void 0, function* (id, linker, inpage = 10, page = 1) {\n        var _a;\n        let output = [];\n        let concept = yield GetTheConcept(id);\n        let linkString = ((_a = concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\" + \"_\" + linker;\n        let relatedConceptString = yield GetConceptByCharacterAndType(linkString, 16);\n        let relatedConcept = relatedConceptString;\n        if (relatedConcept.id > 0) {\n            let connectionsString = yield GetConnectionOfTheConcept(relatedConcept.id, concept.id, concept.userId, inpage, page);\n            let connections = connectionsString;\n            let prefetch = [];\n            for (let i = 0; i < connections.length; i++) {\n                prefetch.push(connections[i].toTheConceptId);\n            }\n            for (let i = 0; i < connections.length; i++) {\n                let toConceptId = connections[i].toTheConceptId;\n                let toConcept = yield GetTheConcept(toConceptId);\n                output.push(toConcept);\n            }\n        }\n        return output;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAllLinkerConnectionsFromTheConcept } from \"../Api/GetAllLinkerConnectionsFromTheConcept\";\nimport { GetAllLinkerConnectionsToTheConcept } from \"../Api/GetAllLinkerConnectionsToTheConcept\";\nimport GetTheConcept from \"./GetTheConcept\";\nexport function GetLinkerConnectionFromConcepts(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connections = yield GetAllLinkerConnectionsFromTheConcept(id);\n        for (let i = 0; i < connections.length; i++) {\n            let localConnection = connections[i];\n            let connectionIdentifier = localConnection.typeId;\n            let concept = yield GetTheConcept(connectionIdentifier);\n            localConnection.type = concept;\n        }\n        return connections;\n    });\n}\nexport function GetLinkerConnectionToConcepts(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let connections = yield GetAllLinkerConnectionsToTheConcept(id);\n        for (let i = 0; i < connections.length; i++) {\n            let localConnection = connections[i];\n            let connectionIdentifier = localConnection.typeId;\n            let concept = yield GetTheConcept(connectionIdentifier);\n            localConnection.type = concept;\n        }\n        return connections;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConnectionOfTheConcept } from \"../Api/GetConnectionOfTheConcept\";\nimport { GetCompositionWithIdAndDateFromMemory } from \"./GetComposition\";\nimport GetTheConcept from \"./GetTheConcept\";\nimport { GetAllConnectionsOfCompositionBulk } from \"../Api/GetAllConnectionsOfCompositionBulk\";\nimport { GetConceptByCharacterAndCategory } from \"./ConceptFinding/GetConceptByCharacterAndCategory\";\nimport { sendMessage, serviceWorker } from \"../app\";\nexport function GetRelation(id_1, relation_1) {\n    return __awaiter(this, arguments, void 0, function* (id, relation, inpage = 10, page = 1) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetRelation', { id, relation, inpage, page });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let output = [];\n        let concept = yield GetTheConcept(id);\n        let relatedConceptString = yield GetConceptByCharacterAndCategory(relation);\n        let relatedConcept = relatedConceptString;\n        if (relatedConcept.id > 0) {\n            let connectionsString = yield GetConnectionOfTheConcept(relatedConcept.id, concept.id, concept.userId, inpage, page);\n            let connections = connectionsString;\n            let prefetch = [];\n            for (let i = 0; i < connections.length; i++) {\n                prefetch.push(connections[i].toTheConceptId);\n            }\n            yield GetAllConnectionsOfCompositionBulk(prefetch);\n            for (let i = 0; i < connections.length; i++) {\n                let toConceptId = connections[i].toTheConceptId;\n                let toConcept = yield GetTheConcept(toConceptId);\n                let newComposition = yield GetCompositionWithIdAndDateFromMemory(toConcept.id);\n                output.push(newComposition);\n            }\n        }\n        return output;\n    });\n}\nexport function GetRelationRaw(id_1, relation_1) {\n    return __awaiter(this, arguments, void 0, function* (id, relation, inpage = 10, page = 1) {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetRelationRaw', { id, relation, inpage, page });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let output = [];\n        let concept = yield GetTheConcept(id);\n        let relatedConceptString = yield GetConceptByCharacterAndCategory(relation);\n        let relatedConcept = relatedConceptString;\n        if (relatedConcept.id > 0) {\n            let connectionsString = yield GetConnectionOfTheConcept(relatedConcept.id, concept.id, concept.userId, inpage, page);\n            let connections = connectionsString;\n            let prefetch = [];\n            for (let i = 0; i < connections.length; i++) {\n                prefetch.push(connections[i].toTheConceptId);\n            }\n            for (let i = 0; i < connections.length; i++) {\n                let toConceptId = connections[i].toTheConceptId;\n                let toConcept = yield GetTheConcept(toConceptId);\n                output.push(toConcept);\n            }\n        }\n        return output;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { AccessTracker } from \"../AccessTracker/accessTracker\";\nimport { GetConcept } from \"../Api/GetConcept\";\nimport { convertFromLConceptToConcept, GetUserGhostId, Logger, sendMessage, serviceWorker } from \"../app\";\nimport { ConceptsData } from \"../DataStructures/ConceptData\";\nimport { CreateDefaultConcept } from \"./CreateDefaultConcept\";\n/**\n *\n * @param id this is the id that can be used to get the concept.\n * @param userId This is the user that calls the concept\n * @returns Concept if it exists\n */\nexport default function GetTheConcept(id_1) {\n    return __awaiter(this, arguments, void 0, function* (id, userId = 999) {\n        let startTime = performance.now();\n        try {\n            // Add concept id in access tracker\n            try {\n                AccessTracker.incrementConcept(id);\n            }\n            catch (_a) {\n                console.error(\"Error adding concepts in access tracker\");\n            }\n            // Increment count of the concept\n            try {\n                AccessTracker.incrementConcept(id);\n            }\n            catch (error) {\n                console.error(\"Error adding concept in access tracker:\", error);\n            }\n            if (serviceWorker) {\n                const res = yield sendMessage('GetTheConcept', { id, userId });\n                // console.log('data received from sw', res)\n                return res.data;\n            }\n            let concept = CreateDefaultConcept();\n            if (id < 0) {\n                let lconcept = yield GetUserGhostId(userId, id);\n                concept = convertFromLConceptToConcept(lconcept);\n                return concept;\n            }\n            concept = yield ConceptsData.GetConcept(id);\n            if ((concept == null || concept.id == 0) && id != null && id != undefined) {\n                let conceptString = yield GetConcept(id);\n                concept = conceptString;\n            }\n            if (concept.id != 0) {\n                if (concept.type == null) {\n                    let conceptType = yield ConceptsData.GetConcept(concept.typeId);\n                    if (conceptType == null && concept.typeId != null && concept.typeId != undefined) {\n                        let typeConceptString = yield GetConcept(concept.typeId);\n                        let typeConcept = typeConceptString;\n                        concept.type = typeConcept;\n                    }\n                }\n            }\n            // Add Log\n            Logger.logInfo(startTime, userId, \"read\", \"unknown\", undefined, 200, concept, \"GetTheConcept\", ['id', 'userId'], \"unknown\", undefined);\n            return concept;\n        }\n        catch (err) {\n            console.error(\"this is the error in the getting concept\", err);\n            // Add Log\n            Logger.logError(startTime, userId, \"read\", \"unknown\", undefined, 500, err, \"GetTheConcept\", ['id', 'userId'], \"unknown\", undefined);\n            throw err;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAiData } from \"../Api/GetAiData\";\nimport { SettingData } from \"../DataStructures/SettingData\";\nimport { Settings } from \"../DataStructures/Settings\";\nimport { AiUpdateFlag, GetLastSettingsFromDatabase, openDatabase } from \"../Database/indexeddb\";\nimport { openDatabase as localopenDb } from '../Database/indexdblocal';\nexport default function InitializeSystem() {\n    return __awaiter(this, arguments, void 0, function* (enableAi = true) {\n        try {\n            yield openDatabase(\"concepts\");\n            yield localopenDb(\"concepts\");\n            if (enableAi) {\n                var statsData = yield GetLastSettingsFromDatabase();\n                var settings = statsData;\n                if (settings.isOnlineSync) {\n                    return true;\n                }\n                yield GetAiData();\n            }\n            return true;\n        }\n        catch (error) {\n            let errorObject = {\n                \"message\": \"cannot initlize the AI system\",\n                \"ok\": false,\n                \"status\": 400,\n                \"data\": error\n            };\n            console.log(errorObject);\n            return true;\n        }\n    });\n}\nexport function PurgatoryDatabaseUpdated() {\n    return __awaiter(this, void 0, void 0, function* () {\n        Settings.isOnlineSync = true;\n        var settingData = new SettingData(Settings.isOnlineSync);\n        AiUpdateFlag(settingData);\n    });\n}\n","import { Connection } from \"../../DataStructures/Connection\";\nexport function ConvertFromLConnectionToConnection(lconnection) {\n    let connection = new Connection(0, 0, 0, 0, 0, 0, 0);\n    connection.ofTheConceptId = lconnection.ofTheConceptId;\n    connection.toTheConceptId = lconnection.toTheConceptId;\n    connection.typeId = lconnection.typeId;\n    connection.orderId = lconnection.orderId;\n    connection.id = lconnection.id;\n    return connection;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateTheConnectionLocal, MakeTheInstanceConceptLocal, sendMessage, serviceWorker } from \"../../app\";\nimport { Logger } from \"../../Middleware/logger.service\";\nexport function CreateConnectionBetweenTwoConceptsLocal(ofTheConcept_1, toTheConcept_1, linker_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConcept, toTheConcept, linker, both = false, actions = { concepts: [], connections: [] }) {\n        var _a, _b, _c, _d, _e, _f;\n        let startTime = performance.now();\n        try {\n            if (serviceWorker) {\n                const res = yield sendMessage('CreateConnectionBetweenTwoConceptsLocal', { ofTheConcept, toTheConcept, linker, both, actions });\n                // console.log('data received from sw', res)\n                if ((_b = (_a = res === null || res === void 0 ? void 0 : res.actions) === null || _a === void 0 ? void 0 : _a.concepts) === null || _b === void 0 ? void 0 : _b.length)\n                    actions.concepts = JSON.parse(JSON.stringify(res.actions.concepts));\n                if ((_d = (_c = res === null || res === void 0 ? void 0 : res.actions) === null || _c === void 0 ? void 0 : _c.connections) === null || _d === void 0 ? void 0 : _d.length)\n                    actions.connections = JSON.parse(JSON.stringify(res.actions.connections));\n                return res.data;\n            }\n            var userId = ofTheConcept.userId;\n            if (both) {\n                let prefix1 = ((_e = toTheConcept.type) === null || _e === void 0 ? void 0 : _e.characterValue) + \"_s\";\n                let linkerAdd1 = linker + \"_by\";\n                let backwardLinker = prefix1 + \"_\" + linkerAdd1;\n                // if(count){\n                //    await CountRelationship(linkerAdd1, toTheConcept, userId);\n                //   }\n                var connectionConceptReverse = yield MakeTheInstanceConceptLocal(\"connection\", backwardLinker, false, 999, 999, 999, 0, actions);\n                let pewCon = yield CreateTheConnectionLocal(toTheConcept.id, ofTheConcept.id, connectionConceptReverse.id, 1000, undefined, undefined, actions);\n            }\n            let prefix = ((_f = ofTheConcept.type) === null || _f === void 0 ? void 0 : _f.characterValue) + \"_s\";\n            let linkerAdd = linker + \"_s\";\n            let forwardLinker = prefix + \"_\" + linkerAdd;\n            // if(count){\n            // // await CountRelationship(linkerAdd, ofTheConcept, userId);\n            // }\n            var connectionConcept = yield MakeTheInstanceConceptLocal(\"connection\", forwardLinker, false, 999, 999, 999, undefined, actions);\n            let newConnection = yield CreateTheConnectionLocal(ofTheConcept.id, toTheConcept.id, connectionConcept.id, 1000, undefined, undefined, actions);\n            // Add Log\n            Logger.logInfo(startTime, userId, 'create', undefined, undefined, 200, newConnection, 'CreateConnectionBetweenTwoConceptsLocal', ['ofTheConceptId', 'toTheConceptId', 'linker', 'both'], undefined, undefined);\n            return newConnection;\n        }\n        catch (ex) {\n            // Add Log\n            Logger.logError(startTime, ofTheConcept.userId, 'create', undefined, undefined, 500, ex, 'CreateConnectionBetweenTwoConceptsLocal', ['ofTheConceptId', 'toTheConceptId', 'linker', 'both'], undefined, undefined);\n            throw ex;\n        }\n    });\n}\n","import { Concept } from \"../../DataStructures/Concept\";\nexport function CreateDefaultLConcept() {\n    let created_on = new Date();\n    let updated_on = new Date();\n    let concept = new Concept(0, 0, 0, 0, 0, \"0\", 0, false, created_on, updated_on, \"0\");\n    return concept;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { IdentifierFlags } from \"../../DataStructures/IdentifierFlags\";\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { LocalId } from \"../../DataStructures/Local/LocalId\";\nimport { getObjectsFromLocalIndexDb, UpdateToDatabase } from \"../../Database/indexdblocal\";\nimport { BaseUrl, DelayFunctionExecution } from \"../../app\";\n/**\n * This will create a binary tree of local concepts that is saved from the indexdb.\n */\nexport default function CreateLocalBinaryTreeFromIndexDb() {\n    return __awaiter(this, void 0, void 0, function* () {\n        console.log(\"this is trying to create local binary tree\");\n        try {\n            let conceptList = yield getObjectsFromLocalIndexDb(\"localconcept\");\n            if (Array.isArray(conceptList)) {\n                for (let i = 0; i < conceptList.length; i++) {\n                    let concept = conceptList[i];\n                    LocalConceptsData.AddConceptToMemory(concept);\n                }\n            }\n            IdentifierFlags.isLocalDataLoaded = true;\n            IdentifierFlags.isLocalTypeLoaded = true;\n            IdentifierFlags.isLocalCharacterLoaded = true;\n        }\n        catch (error) {\n            yield DelayFunctionExecution(2000, CreateLocalBinaryTreeFromIndexDb());\n            let errorObject = {\n                \"message\": \"Cannot create local binary tree from index db\",\n                \"data\": error,\n                \"ok\": false,\n                \"status\": 400\n            };\n            throw errorObject;\n        }\n    });\n}\n/**\n * We have designed our system to use local concepts and connections with its own local ids(negative ids) that\n * is only valid for the browser that creates this. We have a translator in our node server.\n * We cannot keep on using the indexdb to get the new data so we populate the data from indexdb to our memory\n * then we use these ids from memory and update the indexdb with the latest id frequently.\n * This function does this process in initlization from indexdb to memory.\n *\n * Here we have locked this function so that other processes cannot access this process in the case that this process is ongoing\n *\n *\n */\nexport function PopulateTheLocalConceptsToMemory() {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        try {\n            // put a lock on the indexdb for the domain so that no two things do this same process.\n            yield ((_a = navigator.locks) === null || _a === void 0 ? void 0 : _a.request(\"dblock\", (lock) => __awaiter(this, void 0, void 0, function* () {\n                // get the last local concept id(-ve) from the indexdb\n                let idList = yield getObjectsFromLocalIndexDb(\"localid\");\n                // if the list is valid then.\n                if (Array.isArray(idList)) {\n                    // if the zeroth component that is the concept component is present\n                    if (idList[0]) {\n                        // if the zeroth component (concept component) has a valid value;\n                        let localConceptIdValue = idList[0].value;\n                        if (localConceptIdValue) {\n                            // add the new concept id to the memory\n                            LocalId.AddConceptId(idList[0]);\n                            // update the indexdb with the new concept value that other programs can use and\n                            // reserve the 10 ids for this program.\n                            //   await UpdateToDatabase(\"localid\", {\"id\": 0, \"value\": localConceptIdValue - 10});\n                        }\n                        else {\n                            // incase there is invalid id then choose a random id .\n                            localConceptIdValue = -Math.floor(Math.random() * 100000000);\n                            let object = { \"id\": 0, \"value\": localConceptIdValue };\n                            let newObject = { \"id\": 0, \"value\": localConceptIdValue - 10 };\n                            LocalId.AddConceptId(object);\n                            yield UpdateToDatabase(\"localid\", newObject);\n                        }\n                    }\n                    if (idList[2]) {\n                        // BaseUrl.BASE_RANDOMIZER = idList[2].value;\n                        BaseUrl.setRandomizer(idList[2].value);\n                    }\n                }\n            })));\n        }\n        catch (error) {\n            let errorObject = {\n                \"message\": \"Cannot populate Local Ids from the Index Db\",\n                \"data\": error,\n                \"ok\": false,\n                \"status\": 400\n            };\n            throw errorObject;\n        }\n    });\n}\n/**\n* We have designed our system to use local concepts and connections with its own local ids(negative ids) that\n* is only valid for the browser that creates this. We have a translator in our node server.\n* We cannot keep on using the indexdb to get the new data so we populate the data from indexdb to our memory\n* then we use these ids from memory and update the indexdb with the latest id frequently.\n* This function does this process in initlization from indexdb to memory.\n*\n* This function locked so that no two parallel process can access this functionality at the same time.\n* That might cause some ids to be repeated.\n*\n*\n*/\nexport function PopulateTheLocalConnectionToMemory() {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        try {\n            // put a lock on the indexdb for the domain so that no two things do this same process.\n            yield ((_a = navigator.locks) === null || _a === void 0 ? void 0 : _a.request(\"dblock\", (lock) => __awaiter(this, void 0, void 0, function* () {\n                let idList = yield getObjectsFromLocalIndexDb(\"localid\");\n                if (Array.isArray(idList)) {\n                    if (idList[1]) {\n                        let localConnectionId = idList[1].value;\n                        if (localConnectionId) {\n                            LocalId.AddConnectionId(idList[1]);\n                            yield UpdateToDatabase(\"localid\", { \"id\": 1, \"value\": localConnectionId - 10 });\n                        }\n                        else {\n                            // incase there is invalid id then choose a random id .\n                            localConnectionId = -Math.floor(Math.random() * 100000000);\n                            let object = { \"id\": 0, \"value\": localConnectionId };\n                            let newObject = { \"id\": 0, \"value\": localConnectionId - 10 };\n                            LocalId.AddConnectionId(object);\n                            yield UpdateToDatabase(\"localid\", newObject);\n                        }\n                    }\n                    if (idList[2]) {\n                        // BaseUrl.BASE_RANDOMIZER = idList[2].value;\n                        BaseUrl.setRandomizer(idList[2].value);\n                    }\n                }\n            })));\n        }\n        catch (error) {\n            let errorObject = {\n                \"message\": \"Cannot populate Local Ids from the Index Db\",\n                \"data\": error,\n                \"ok\": false,\n                \"status\": 400\n            };\n            throw errorObject;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger, sendMessage, serviceWorker } from \"../../app\";\nimport { CreateDefaultLConcept } from \"../Local/CreateDefaultLConcept\";\nimport { CreateTheConnectionLocal } from \"./CreateTheConnectionLocal\";\nimport { MakeTheInstanceConceptLocal } from \"./MakeTheInstanceConceptLocal\";\n/**\n * This function converts a json data to concept connection and also preserves its relation.\n * @param json The json data that needs to be converted to the concept connection system\n * @param ofTheConceptId If in case that this composition is part of other composition then this must be the connecting concept.\n * @param ofTheConceptUserId If in case that this composition is part of other composition then this must be the user Id of the  connecting concept.\n * @param mainKey If in case that this composition is part of other composition then this must be the main composition\n * @param userId The user Id of the user creating the composition.\n * @param accessId The accessId of the user creating the composition.\n * @param sessionInformationId Session of the user.\n * @param automaticSync for future use.\n * @returns the main concept of this composition.\n */\nexport function CreateTheCompositionLocal(json_1) {\n    return __awaiter(this, arguments, void 0, function* (json, ofTheConceptId = null, ofTheConceptUserId = null, mainKey = null, userId = null, accessId = null, sessionInformationId = null, automaticSync = false, actions = { concepts: [], connections: [] }) {\n        var _a, _b, _c, _d;\n        let startTime = performance.now();\n        if (serviceWorker) {\n            const res = yield sendMessage('CreateTheCompositionLocal', { json, ofTheConceptId, ofTheConceptUserId, mainKey, userId, accessId, sessionInformationId, actions });\n            // console.log('data received from sw', res)\n            if ((_b = (_a = res === null || res === void 0 ? void 0 : res.actions) === null || _a === void 0 ? void 0 : _a.concepts) === null || _b === void 0 ? void 0 : _b.length)\n                actions.concepts = JSON.parse(JSON.stringify(res.actions.concepts));\n            if ((_d = (_c = res === null || res === void 0 ? void 0 : res.actions) === null || _c === void 0 ? void 0 : _c.connections) === null || _d === void 0 ? void 0 : _d.length)\n                actions.connections = JSON.parse(JSON.stringify(res.actions.connections));\n            return res.data;\n        }\n        let localUserId = userId !== null && userId !== void 0 ? userId : 999;\n        let localAccessId = accessId !== null && accessId !== void 0 ? accessId : 999;\n        let localSessionId = sessionInformationId !== null && sessionInformationId !== void 0 ? sessionInformationId : 999;\n        let MainKeyLocal = mainKey !== null && mainKey !== void 0 ? mainKey : 0;\n        let MainConcept = CreateDefaultLConcept();\n        for (const key in json) {\n            if (typeof json[key] != 'string' && typeof json[key] != 'number') {\n                if (ofTheConceptId == null && ofTheConceptUserId == null) {\n                    let localMainKey = MainKeyLocal;\n                    let conceptString = yield MakeTheInstanceConceptLocal(key, \"\", true, localUserId, localAccessId, localSessionId, undefined, actions);\n                    let concept = conceptString;\n                    MainConcept = concept;\n                    localMainKey = concept.id;\n                    MainKeyLocal = concept.id;\n                    yield CreateTheCompositionLocal(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId, undefined, actions);\n                }\n                else {\n                    let ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                    let ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 999;\n                    let localMainKey = MainKeyLocal;\n                    let conceptString = yield MakeTheInstanceConceptLocal(key, \"\", true, localUserId, localAccessId, localSessionId, undefined, actions);\n                    let concept = conceptString;\n                    yield CreateTheConnectionLocal(ofThe, concept.id, localMainKey, undefined, undefined, undefined, actions);\n                    yield CreateTheCompositionLocal(json[key], concept.id, concept.userId, localMainKey, userId, accessId, sessionInformationId, undefined, actions);\n                }\n            }\n            else {\n                let ofThe = ofTheConceptId !== null && ofTheConceptId !== void 0 ? ofTheConceptId : 999;\n                let ofTheUser = ofTheConceptUserId !== null && ofTheConceptUserId !== void 0 ? ofTheConceptUserId : 999;\n                let localMainKey = MainKeyLocal;\n                let conceptString = yield MakeTheInstanceConceptLocal(key, json[key].toString(), false, localUserId, localAccessId, localSessionId, undefined, actions);\n                let concept = conceptString;\n                yield CreateTheConnectionLocal(ofThe, concept.id, localMainKey, undefined, undefined, undefined, actions);\n            }\n        }\n        // Add Log\n        Logger.logInfo(startTime, userId || \"unknown\", \"create\", \"unknown\", undefined, 200, MainConcept, \"CreateTheCompositionLocal\", ['json', 'ofTheConceptId', 'ofTheConceptUserId', 'mainKey', 'userId', 'accessId', 'sessionInformationId', 'automaticSync'], \"unknown\", undefined);\n        return MainConcept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { sendMessage, serviceWorker } from \"../../app\";\nimport { Concept } from \"../../DataStructures/Concept\";\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { LocalId } from \"../../DataStructures/Local/LocalId\";\nimport { Logger } from \"../../Middleware/logger.service\";\n/**\n * This function creates the concept in the local system (Local memory and IndexDb) but not in the backend database\n * To create this concept in the backend database you need to sync the local data to the backend by LocalSyncData class.\n *\n * This function creates a id and ghost id which are equal to each other.\n * These id and ghostId are negative which means that they are virtual concepts. After these concepts have been synced with the backend\n * they are converted to real id. After returning from the backend the id changes to positive(+) and real id while the ghostId remains the same\n *\n * The system then saves this relation between -ve id and real id in the backend server and also in the local memory.\n *\n * @param referent This is the string that is the actual value of the concept.\n * @param typecharacter The string that defines the type of the concept.\n * @param userId This is the userId of the creator.\n * @param categoryId This is the category Id of the concept.\n * @param typeId This is the type Id of the concept that relates to the typecharacter passed above.\n * @param accessId This is the accessId of the concept(most probably is the accessId of the user)\n * @param isComposition This is set in the case that the composition needs to be created.\n * @param referentId if this concept refers to any other concept then this needs to be passed.\n * @returns\n */\nexport default function CreateTheConceptLocal(referent_1, typecharacter_1, userId_1, categoryId_1, typeId_1, accessId_1) {\n    return __awaiter(this, arguments, void 0, function* (referent, typecharacter, userId, categoryId, typeId, accessId, isComposition = false, referentId = 0, actions = { concepts: [], connections: [] }) {\n        var _a, _b, _c, _d;\n        let startTime = performance.now();\n        try {\n            if (serviceWorker) {\n                const res = yield sendMessage('CreateTheConceptLocal', { referent, typecharacter, userId, categoryId, typeId, accessId, isComposition, referentId });\n                // console.log('data received from sw', res)\n                if ((_b = (_a = res === null || res === void 0 ? void 0 : res.actions) === null || _a === void 0 ? void 0 : _a.concepts) === null || _b === void 0 ? void 0 : _b.length)\n                    actions.concepts = JSON.parse(JSON.stringify(res.actions.concepts));\n                if ((_d = (_c = res === null || res === void 0 ? void 0 : res.actions) === null || _c === void 0 ? void 0 : _c.connections) === null || _d === void 0 ? void 0 : _d.length)\n                    actions.connections = JSON.parse(JSON.stringify(res.actions.connections));\n                return res.data;\n            }\n            //let id = -Math.floor(Math.random() * 100000000);\n            let id = yield LocalId.getConceptId();\n            // console.log(\"this is the getting id type connection\", id);\n            let isNew = true;\n            let created_on = new Date();\n            let updated_on = new Date();\n            if (referent == \"the\") {\n                let concept = new Concept(1, 999, 5, 5, referentId, referent, accessId, isNew, created_on, updated_on, typecharacter);\n                return concept;\n            }\n            let concept = new Concept(id, userId, typeId, categoryId, referentId, referent, accessId, isNew, created_on, updated_on, typecharacter);\n            concept.isTemp = true;\n            concept.isComposition = isComposition;\n            LocalConceptsData.AddConcept(concept);\n            actions.concepts.push(concept);\n            //storeToDatabase(\"localconcept\",concept);\n            // Add Log\n            Logger.logInfo(startTime, userId, \"create\", \"unknown\", \"unknown\", 200, concept, \"createTheConceptLocal\", ['referent', 'typecharacter', 'composition', 'userId', 'categoryId', 'typeId', 'accessId', 'sessionInformationId', 'isComposition', 'referentId'], undefined);\n            return concept;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Connection } from \"../../DataStructures/Connection\";\nimport { LocalConnectionData } from \"../../DataStructures/Local/LocalConnectionData\";\nimport { LocalId } from \"../../DataStructures/Local/LocalId\";\nimport { Logger } from \"../../Middleware/logger.service\";\nimport { LocalSyncData, sendMessage, serviceWorker } from \"../../app\";\n/**\n * This function creates a connection for the concept connection system. This connection will only be created in real sense\n * once the data is synced using LocalSyncData.SyncDataOnline()\n * Here id and ghostId are created which are negative(these are virtual ids). After they are synced then they become real ids\n * The real ids are then associated with these ghost ids in node server (backend) and also in the local memory.\n * @param ofTheConceptId Of the concept Id for the connection\n * @param toTheConceptId To the concept Id for the connection\n * @param typeId Type of the connection, should be the composition id for internal connection and type concept in case\n * of external connection.\n * @param orderId current context is that for internal connections the order id is less than 3 and for external connections greater than 999\n * @param typeString this is the typeString in the case of external connections.\n * @returns a connection that is created and stored in the local system.\n */\nexport function CreateTheConnectionLocal(ofTheConceptId_1, toTheConceptId_1, typeId_1) {\n    return __awaiter(this, arguments, void 0, function* (ofTheConceptId, toTheConceptId, typeId, orderId = 1, typeString = \"\", userId = 999, actions = { concepts: [], connections: [] }) {\n        var _a, _b, _c, _d;\n        let startTime = performance.now();\n        if (serviceWorker) {\n            const res = yield sendMessage('CreateTheConnectionLocal', { ofTheConceptId, toTheConceptId, typeId, orderId, typeString, userId, actions });\n            // console.log('data received from sw', res)\n            if ((_b = (_a = res === null || res === void 0 ? void 0 : res.actions) === null || _a === void 0 ? void 0 : _a.concepts) === null || _b === void 0 ? void 0 : _b.length)\n                actions.concepts = JSON.parse(JSON.stringify(res.actions.concepts));\n            if ((_d = (_c = res === null || res === void 0 ? void 0 : res.actions) === null || _c === void 0 ? void 0 : _c.connections) === null || _d === void 0 ? void 0 : _d.length)\n                actions.connections = JSON.parse(JSON.stringify(res.actions.connections));\n            return res.data;\n        }\n        try {\n            let accessId = 4;\n            // let randomid = -Math.floor(Math.random() * 100000000);\n            let randomid = yield LocalId.getConnectionId();\n            let realOfTheConceptId = 0;\n            let realToTheConceptId = 0;\n            let realTypeId = 0;\n            realOfTheConceptId = ofTheConceptId;\n            realToTheConceptId = toTheConceptId;\n            realTypeId = typeId;\n            let connection = new Connection(0, 0, 0, 0, 0, 0, 0);\n            if (ofTheConceptId != toTheConceptId) {\n                connection = new Connection(randomid, realOfTheConceptId, realToTheConceptId, userId, typeId, orderId, accessId);\n                connection.isTemp = true;\n                connection.typeCharacter = typeString;\n                LocalSyncData.AddConnection(connection);\n                LocalConnectionData.AddConnection(connection);\n                actions.connections.push(connection);\n                //storeToDatabase(\"localconnection\", connection);\n            }\n            /**\n            * Add to Logger\n            */\n            console.log(\"CreateTheConnectionLocal...\");\n            Logger.logInfo(startTime, userId, \"create\", \"Unknown\", \"Unknown\", 200, connection, \"CreateTheConnectionLocal\", ['ofTheConceptId', 'toTheConceptId', 'typeId', 'orderId', 'typeString', 'userId'], \"UnknownUserAgent\", []);\n            /**\n             * End of Logger\n             */\n            return connection;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { sendMessage, serviceWorker } from \"../../app\";\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { GetTheConceptLocal } from \"./GetTheConceptLocal\";\nexport function DeleteConceptLocal(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('DeleteConceptLocal', { id });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let concept = yield GetTheConceptLocal(id);\n        LocalConceptsData.RemoveConcept(concept);\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { sendMessage, serviceWorker } from \"../../app\";\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { GetCompositionLocal, GetCompositionLocalWithId } from \"./GetCompositionLocal\";\nimport GetConceptByCharacterLocal from \"./GetConceptByCharacterLocal\";\n/**\n * This function returns the list of composition which have the type @param compositionName\n * @param compositionName The type of the composition to pull\n * @param userId User Id of the user trying to pull the list\n * @returns list of compositions.\n */\nexport function GetCompositionListLocal(compositionName, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionListLocal', { compositionName, userId });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        try {\n            let concept = yield GetConceptByCharacterLocal(compositionName);\n            let CompositionList = [];\n            if (concept.id != 0) {\n                let conceptList = yield LocalConceptsData.GetConceptsByTypeIdAndUser(concept.id, userId);\n                for (let i = 0; i < conceptList.length; i++) {\n                    let compositionJson = yield GetCompositionLocal(conceptList[i].id);\n                    CompositionList.push(compositionJson);\n                }\n            }\n            return CompositionList;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n/**\n * This function returns the list of composition with data - id format which have the type @param compositionName\n * @param compositionName The type of the composition to pull\n * @param userId User Id of the user trying to pull the list\n * @returns list of compositions with data - id format.\n */\nexport function GetCompositionListLocalWithId(compositionName, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetCompositionListLocalWithId', { compositionName, userId });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        try {\n            let concept = yield GetConceptByCharacterLocal(compositionName);\n            let CompositionList = [];\n            if (concept.id != 0) {\n                let conceptList = yield LocalConceptsData.GetConceptsByTypeIdAndUser(concept.id, userId);\n                for (let i = 0; i < conceptList.length; i++) {\n                    let compositionJson = yield GetCompositionLocalWithId(conceptList[i].id);\n                    CompositionList.push(compositionJson);\n                }\n            }\n            return CompositionList;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { LocalConnectionData } from \"../../DataStructures/Local/LocalConnectionData\";\nimport { TranslateLocalToReal } from \"../../Api/Translate/TranslateLocalToReal\";\nimport { GetComposition } from \"../GetComposition\";\nimport { sendMessage, serviceWorker } from \"../../app\";\nexport function GetCompositionLocal(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        try {\n            if (serviceWorker) {\n                const res = yield sendMessage('GetCompositionLocal', { id });\n                // console.log('data received from sw', res)\n                return res.data;\n            }\n            let connectionList = [];\n            let returnOutput = {};\n            connectionList = yield LocalConnectionData.GetConnectionsOfCompositionLocal(id);\n            //connectionList = ConnectionData.GetConnectionsOfComposition(id);\n            let compositionList = [];\n            for (let i = 0; i < connectionList.length; i++) {\n                if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                    compositionList.push(connectionList[i].ofTheConceptId);\n                }\n            }\n            let concept = yield LocalConceptsData.GetConcept(id);\n            if (concept.id == 0) {\n                let realConcept = yield TranslateLocalToReal(id);\n                if (realConcept.id > 0) {\n                    return yield GetComposition(realConcept.id);\n                }\n            }\n            let output = yield recursiveFetchLocal(id, connectionList, compositionList);\n            let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"top\";\n            returnOutput[mainString] = output;\n            return returnOutput;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\nexport function GetCompositionLocalWithId(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        try {\n            if (serviceWorker) {\n                const res = yield sendMessage('GetCompositionLocalWithId', { id });\n                // console.log('data received from sw', res)\n                return res.data;\n            }\n            let connectionList = [];\n            let returnOutput = {};\n            let FinalReturn = {};\n            connectionList = yield LocalConnectionData.GetConnectionsOfCompositionLocal(id);\n            let compositionList = [];\n            for (let i = 0; i < connectionList.length; i++) {\n                if (!compositionList.includes(connectionList[i].ofTheConceptId)) {\n                    compositionList.push(connectionList[i].ofTheConceptId);\n                }\n            }\n            let concept = yield LocalConceptsData.GetConcept(id);\n            if (concept.id != 0) {\n                let output = yield recursiveFetchLocal(id, connectionList, compositionList);\n                let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"top\";\n                returnOutput[mainString] = output;\n            }\n            FinalReturn['data'] = returnOutput;\n            FinalReturn['id'] = id;\n            return FinalReturn;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\nfunction recursiveFetchLocal(id_1, connectionList_1, compositionList_1) {\n    return __awaiter(this, arguments, void 0, function* (id, connectionList, compositionList, visitedConcepts = []) {\n        var _a, _b, _c, _d;\n        let output = {};\n        let arroutput = [];\n        let concept = yield LocalConceptsData.GetConcept(id);\n        if (concept.id != 0) {\n            if (concept.type == null) {\n                let toConceptTypeId = concept.typeId;\n                let toConceptType = yield LocalConceptsData.GetConcept(toConceptTypeId);\n                concept.type = toConceptType;\n            }\n        }\n        let mainString = (_b = (_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"top\";\n        if (!compositionList.includes(id)) {\n            return concept === null || concept === void 0 ? void 0 : concept.characterValue;\n        }\n        else {\n            if (visitedConcepts.includes(id)) {\n                return \"\";\n            }\n            else {\n                visitedConcepts.push(id);\n            }\n            for (let i = 0; i < connectionList.length; i++) {\n                if (connectionList[i].ofTheConceptId == id) {\n                    let toConceptId = connectionList[i].toTheConceptId;\n                    let toConcept = yield LocalConceptsData.GetConcept(toConceptId);\n                    if (toConcept.id != 0) {\n                        if ((toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) == null) {\n                            let toConceptTypeId = toConcept.typeId;\n                            let toConceptType = yield LocalConceptsData.GetConcept(toConceptTypeId);\n                            toConcept.type = toConceptType;\n                        }\n                    }\n                    let regex = \"the_\";\n                    let localmainString = (_d = (_c = toConcept === null || toConcept === void 0 ? void 0 : toConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"top\";\n                    let localKey = localmainString.replace(regex, \"\");\n                    if (isNaN(Number(localKey))) {\n                        if (localKey) {\n                            const result = yield recursiveFetchLocal(toConceptId, connectionList, compositionList);\n                            output[localKey] = result;\n                        }\n                    }\n                    else {\n                        const result = yield recursiveFetchLocal(toConceptId, connectionList, compositionList);\n                        arroutput[localKey] = result;\n                        output = arroutput;\n                    }\n                }\n            }\n        }\n        return output;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetLocalConceptByCharacterValue } from \"../../Api/Local/GetLocalConceptByCharacterValue\";\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { CreateDefaultLConcept, sendMessage, serviceWorker, SplitStrings } from \"../../app\";\nexport default function GetConceptByCharacterLocal(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = yield LocalConceptsData.GetConceptByCharacterAndTypeLocal(characterValue, 51);\n        return concept;\n    });\n}\n/**\n *\n * @param character the character value of the concept we want to find in our local system.\n * @returns LConcept which will be the associated concept with the character Value.\n */\nexport function GetConceptByCharacterAndCategoryLocal(character) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('GetConceptByCharacterAndCategoryLocal', { character });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let lconcept = CreateDefaultLConcept();\n        if (character == \"the\") {\n            lconcept.id = 1;\n            lconcept.typeId = 5;\n            lconcept.characterValue = \"the\";\n            return lconcept;\n        }\n        let splittedStringArray = SplitStrings(character);\n        if (splittedStringArray.length > 1) {\n            let category = 1;\n            let prefix = yield GetConceptByCharacterAndCategoryLocal(splittedStringArray[0]);\n            if (prefix.id != 0) {\n                category = prefix.id;\n            }\n            lconcept = yield GetConceptByCategoryAndCharacterLocalMemory(character, category);\n        }\n        else if (splittedStringArray[0] == character) {\n            lconcept = yield GetConceptByCharacterLocal(character);\n        }\n        return lconcept;\n    });\n}\nexport function GetConceptByCategoryAndCharacterLocalMemory(value, categoryId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let concept = LocalConceptsData.GetConceptByCharacterAndCategoryLocal(value, categoryId);\n        return concept;\n    });\n}\nexport function GetConceptByCharacterLocalFull(characterValue) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let concept = yield LocalConceptsData.GetConceptByCharacter(characterValue);\n            let literalCharacter = `${characterValue}`;\n            if ((concept == null || (concept === null || concept === void 0 ? void 0 : concept.id) == 0) && literalCharacter) {\n                yield GetLocalConceptByCharacterValue(characterValue);\n                concept = yield LocalConceptsData.GetConceptByCharacter(characterValue);\n            }\n            return concept;\n        }\n        catch (error) {\n            console.log(\"this is the error in Get Concept By Character Local full\", error);\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LocalConnectionData } from \"../../DataStructures/Local/LocalConnectionData\";\nexport function GetConnectionOfTheConceptLocal(ofTheConcept, typeId, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            let connections = yield LocalConnectionData.GetConnectionOfCompositionAndTypeLocal(typeId, ofTheConcept);\n            return connections;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetCompositionLocal, GetConceptByCharacterAndCategoryLocal, serviceWorker, sendMessage } from \"../../app\";\nimport { GetConnectionOfTheConceptLocal } from \"./GetConnectionOfTheConceptLocal\";\nexport function GetRelationLocal(id, relation, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            if (serviceWorker) {\n                const res = yield sendMessage(\"GetRelationLocal\", {\n                    id, relation, userId\n                });\n                // console.log(\"data received from sw\", res);\n                return res.data;\n            }\n            let typeConcept = yield GetConceptByCharacterAndCategoryLocal(relation);\n            let localConnections = [];\n            if (typeConcept.id != 0) {\n                localConnections = yield GetConnectionOfTheConceptLocal(id, typeConcept.id, userId);\n            }\n            let output = [];\n            for (let i = 0; i < localConnections.length; i++) {\n                let comp = yield GetCompositionLocal(localConnections[i].toTheConceptId);\n                output.push(comp);\n            }\n            return output;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { LocalGhostIdTree } from \"../../DataStructures/Local/LocalGhostIdTree\";\nimport { CreateDefaultLConcept, GetTheConcept, Logger, sendMessage, serviceWorker } from \"../../app\";\nimport { convertFromConceptToLConcept } from \"../Conversion/ConvertConcepts\";\n/**\n * This function converts any local/ virtual or real concept id to a LConcept.\n * In case that the id is virtual then it tries to find it from the local memory. This will return -ve id.\n * In case that the virtual id has already been synced to the backend then it gets this from the relational binary tree(LocalGhostIdTree). This will return +ve id.\n * In case that we pass real id then this will return real concept but formatted in LConcept form. This might have undefined ghostId.\n * @param id the id that you want to find out the concept of. This could be a negative (virtual id ) or a real concept id.\n * @returns LConcept with either (-ve or +ve id)\n */\nexport function GetTheConceptLocal(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let startTime = performance.now();\n        try {\n            if (serviceWorker) {\n                const res = yield sendMessage('GetTheConceptLocal', { id });\n                // console.log('data received from sw', res)\n                return res.data;\n            }\n            let lconcept = CreateDefaultLConcept();\n            if (id < 0) {\n                lconcept = yield LocalConceptsData.GetConcept(id);\n                if (lconcept.id == 0) {\n                    let localNode = yield LocalGhostIdTree.getNodeFromTree(id);\n                    if (localNode === null || localNode === void 0 ? void 0 : localNode.value) {\n                        let returnedConcept = localNode.value;\n                        if (returnedConcept) {\n                            lconcept = returnedConcept;\n                        }\n                    }\n                }\n            }\n            else {\n                let concept = yield GetTheConcept(id);\n                lconcept = convertFromConceptToLConcept(concept);\n            }\n            // Add Log\n            Logger.logInfo(startTime, \"unknown\", \"read\", \"unknown\", undefined, 200, lconcept, \"GetTheConceptLocal\", [id], \"unknown\", undefined);\n            return lconcept;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { sendMessage, serviceWorker } from \"../../app\";\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport CreateTheConceptLocal from \"./CreateTheConceptLocal\";\nexport default function MakeTheConceptLocal(referent_1, typeCharacter_1, userId_1, categoryId_1, typeId_1) {\n    return __awaiter(this, arguments, void 0, function* (referent, typeCharacter, userId, categoryId, typeId, actions = { concepts: [], connections: [] }) {\n        var _a, _b, _c, _d;\n        if (serviceWorker) {\n            const res = yield sendMessage(\"MakeTheConceptLocal\", {\n                referent, typeCharacter, userId, categoryId, typeId, actions\n            });\n            // console.log(\"data received from sw\", res);\n            if ((_b = (_a = res === null || res === void 0 ? void 0 : res.actions) === null || _a === void 0 ? void 0 : _a.concepts) === null || _b === void 0 ? void 0 : _b.length)\n                actions.concepts = JSON.parse(JSON.stringify(res.actions.concepts));\n            if ((_d = (_c = res === null || res === void 0 ? void 0 : res.actions) === null || _c === void 0 ? void 0 : _c.connections) === null || _d === void 0 ? void 0 : _d.length)\n                actions.connections = JSON.parse(JSON.stringify(res.actions.connections));\n            return res.data;\n        }\n        let conceptString = yield LocalConceptsData.GetConceptByCharacterAndTypeLocal(referent, typeId);\n        let concept = conceptString;\n        let accessId = 4;\n        if (typeCharacter == \"the\") {\n            categoryId = 1;\n        }\n        if (concept.id == 0) {\n            conceptString = yield CreateTheConceptLocal(referent, typeCharacter, userId, categoryId, typeId, accessId, undefined, undefined, actions);\n            concept = conceptString;\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport CreateTheConceptLocal from \"./CreateTheConceptLocal\";\nimport { MakeTheTypeConceptLocal } from \"./MakeTheTypeLocal\";\nimport { LocalConceptsData } from \"../../DataStructures/Local/LocalConceptData\";\nimport { LocalSyncData, Logger, sendMessage, serviceWorker } from \"../../app\";\n/**\n * This is the basic function of the concept connection system. This function let's you create a concept within the constraints of the\n * concept connection system. This function is the building block of the concept connection system.\n * This function automatically passes the concept to be synced to the background. Next time you sync the data this concept will also be created in the backend.\n * @param type this is the type of the concept. You can also think of this as the key of concept. first_name, last_name etc.\n * @param referent the actual value of the concept. The actual name of value of the concept.\n * @param composition this is a boolean that defines if the concept is a composition or not. If this is a composition then other things are also\n * connected internally with this concept. If composition is true then always a new concept is created otherwise it checks if the concept already exists\n * and creates only in the case that the concept does not already exists with its type and value as its unique identifier.\n * @param userId the userId of the creator.\n * @param accessId this is the accessId of the creator. By default should be 4.\n * @param sessionInformationId this is the session that is created by the system.\n * @param referentId In case we need this concept to refer to any other concept.\n * @param actions InnerActions Array for capturing concepts and connection\n * @returns a concept which is either newly created or an older concept that already exists.\n */\nexport function MakeTheInstanceConceptLocal(type_1, referent_1) {\n    return __awaiter(this, arguments, void 0, function* (type, referent, composition = false, userId, accessId, sessionInformationId = 999, referentId = 0, actions = { concepts: [], connections: [] }) {\n        var _a, _b, _c, _d;\n        let startTime = performance.now();\n        if (serviceWorker) {\n            const res = yield sendMessage('MakeTheInstanceConceptLocal', { type, referent, composition, userId, accessId, sessionInformationId, referentId, actions });\n            // console.log('data received from sw', res)\n            if ((_b = (_a = res === null || res === void 0 ? void 0 : res.actions) === null || _a === void 0 ? void 0 : _a.concepts) === null || _b === void 0 ? void 0 : _b.length)\n                actions.concepts = JSON.parse(JSON.stringify(res.actions.concepts));\n            if ((_d = (_c = res === null || res === void 0 ? void 0 : res.actions) === null || _c === void 0 ? void 0 : _c.connections) === null || _d === void 0 ? void 0 : _d.length)\n                actions.connections = JSON.parse(JSON.stringify(res.actions.connections));\n            return res.data;\n        }\n        try {\n            let sessionInformationId = 999;\n            let categoryId = 4;\n            let sessionInformationUserId = userId;\n            // change this\n            let accessId = 4;\n            let stringToCheck = \"\";\n            let stringLength = referent.length;\n            let typeConcept;\n            let concept;\n            let startsWithThe = type.startsWith(\"the_\");\n            if (startsWithThe) {\n                stringToCheck = type;\n            }\n            else {\n                stringToCheck = \"the_\" + type;\n            }\n            if (composition) {\n                let typeConceptString = yield MakeTheTypeConceptLocal(type, sessionInformationId, userId, userId, actions);\n                typeConcept = typeConceptString;\n                let conceptString = yield CreateTheConceptLocal(referent, type, userId, categoryId, typeConcept.id, accessId, true, referentId, actions);\n                concept = conceptString;\n            }\n            else if (stringLength > 255) {\n                let typeConceptString = yield MakeTheTypeConceptLocal(stringToCheck, sessionInformationId, sessionInformationUserId, userId, actions);\n                typeConcept = typeConceptString;\n                let conceptString = yield CreateTheConceptLocal(referent, stringToCheck, userId, categoryId, typeConcept.id, accessId, undefined, undefined, actions);\n                concept = conceptString;\n            }\n            else {\n                let typeConceptString = yield MakeTheTypeConceptLocal(stringToCheck, sessionInformationId, sessionInformationUserId, userId, actions);\n                typeConcept = typeConceptString;\n                let conceptByCharTypeString = yield LocalConceptsData.GetConceptByCharacterAndTypeLocal(referent, typeConcept.id);\n                let conceptTypeCharacter = conceptByCharTypeString;\n                concept = conceptTypeCharacter;\n                if (conceptTypeCharacter.id == 0 && conceptTypeCharacter.userId == 0) {\n                    let conceptString = yield CreateTheConceptLocal(referent, stringToCheck, userId, categoryId, typeConcept.id, accessId, undefined, undefined, actions);\n                    concept = conceptString;\n                }\n            }\n            concept.type = typeConcept;\n            LocalSyncData.AddConcept(concept);\n            // Add Log\n            Logger.logInfo(startTime, userId, \"create\", \"Unknown\", \"Unknown\", 200, concept, \"MakeTheInstanceConceptLocal\", ['type', 'referent', 'composition', 'userId', 'accessId', 'sessionInformationId', 'referentId'], \"UnknownUserAgent\", []);\n            actions.concepts.push(concept);\n            return concept;\n        }\n        catch (error) {\n            throw error;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport CreateTheConceptLocal from \"./CreateTheConceptLocal\";\nimport { GetConceptByCharacterAndCategoryLocal } from \"./GetConceptByCharacterLocal\";\nimport { SplitStrings } from \"../SplitStrings\";\nimport MakeTheConceptLocal from \"./MakeTheConceptLocal\";\nimport { sendMessage, serviceWorker } from \"../../app\";\n/**\n * There are two types of concepts. One type of concept is a type concept. These concepts have no actual value and do not mean\n * anything unless they are associated with other values. These are placeholders like first_name, last_name, age etc that are required in the system.\n * These types need to be created seperately.\n *\n *\n * @param typeString type of the concept that needs to be created.\n * @param sessionId SessionId of the user\n * @param sessionUserId Not required pass 999\n * @param userId UserId of the user creating this concept\n * @param actions InnerActions|undefined actions to collect\n * @returns\n */\nexport function MakeTheTypeConceptLocal(typeString_1, sessionId_1, sessionUserId_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (typeString, sessionId, sessionUserId, userId, actions = { concepts: [], connections: [] }) {\n        var _a, _b, _c, _d;\n        if (serviceWorker) {\n            const res = yield sendMessage(\"MakeTheTypeConceptLocal\", {\n                typeString, sessionId, sessionUserId, userId, actions\n            });\n            // console.log(\"data received from sw\", res);\n            if ((_b = (_a = res === null || res === void 0 ? void 0 : res.actions) === null || _a === void 0 ? void 0 : _a.concepts) === null || _b === void 0 ? void 0 : _b.length)\n                actions.concepts = JSON.parse(JSON.stringify(res.actions.concepts));\n            if ((_d = (_c = res === null || res === void 0 ? void 0 : res.actions) === null || _c === void 0 ? void 0 : _c.connections) === null || _d === void 0 ? void 0 : _d.length)\n                actions.connections = JSON.parse(JSON.stringify(res.actions.connections));\n            return res.data;\n        }\n        let accessId = 4;\n        let existingConcept = yield GetConceptByCharacterAndCategoryLocal(typeString);\n        if (existingConcept) {\n            if (existingConcept.id == 0 || existingConcept.userId == 0) {\n                let splittedStringArray = SplitStrings(typeString);\n                if (splittedStringArray[0] == typeString) {\n                    let concept = yield MakeTheConceptLocal(typeString, \"the\", userId, 1, 51, actions);\n                    existingConcept = concept;\n                }\n                else {\n                    // var categoryConcept = await MakeTheTypeConceptLocal(splittedStringArray[0], sessionId, sessionUserId, userId);\n                    // var typeConcept = await MakeTheTypeConceptLocal(splittedStringArray[1], sessionId, sessionUserId, userId );\n                    // if(typeConcept){\n                    let categoryConcept = yield MakeTheTypeConceptLocal(splittedStringArray[0], sessionId, sessionUserId, userId, actions);\n                    let typeConcept = yield MakeTheTypeConceptLocal(splittedStringArray[1], sessionId, sessionUserId, userId, actions);\n                    let concept = yield CreateTheConceptLocal(typeString, splittedStringArray[1], userId, categoryConcept.id, typeConcept.id, accessId, undefined, undefined, actions);\n                    existingConcept = concept;\n                    //   }\n                }\n            }\n        }\n        // LocalSyncData.AddConcept(existingConcept);\n        return existingConcept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport InsertUniqueNumber from \"../../Helpers/UniqueInsert\";\nimport { CheckAllConnectionsConnectedInLConnectionArray, CheckIfTypeLConceptsExistsInArray, } from \"../../Helpers/CheckIfExists\";\nimport { GetAllConnectionsOfComposition } from \"../../Api/GetAllConnectionsOfComposition\";\nimport GetTheConcept from \"./../GetTheConcept\";\nimport { DeleteConnectionById } from \"./../DeleteConnection\";\nimport { CreateTheCompositionLocal } from \"./CreateTheCompositionLocal\";\nimport { MakeTheInstanceConceptLocal } from \"./MakeTheInstanceConceptLocal\";\nimport { CreateDefaultLConcept, CreateTheConnectionLocal, LocalSyncData, Logger, sendMessage, serviceWorker, } from \"../../app\";\nimport { convertFromConceptToLConcept, convertFromConnectionToLConnection, } from \"../Conversion/ConvertConcepts\";\n// function to update the cache composition\nexport function UpdateCompositionLocal(patcherStructure_1) {\n    return __awaiter(this, arguments, void 0, function* (patcherStructure, actions = { concepts: [], connections: [] }) {\n        var _a, _b, _c, _d;\n        let startTime = performance.now();\n        if (serviceWorker) {\n            const res = yield sendMessage(\"UpdateCompositionLocal\", {\n                patcherStructure,\n                actions\n            });\n            // console.log(\"data received from sw\", res);\n            if ((_b = (_a = res === null || res === void 0 ? void 0 : res.actions) === null || _a === void 0 ? void 0 : _a.concepts) === null || _b === void 0 ? void 0 : _b.length)\n                actions.concepts = JSON.parse(JSON.stringify(res.actions.concepts));\n            if ((_d = (_c = res === null || res === void 0 ? void 0 : res.actions) === null || _c === void 0 ? void 0 : _c.connections) === null || _d === void 0 ? void 0 : _d.length)\n                actions.connections = JSON.parse(JSON.stringify(res.actions.connections));\n            return res.data;\n        }\n        // get all the default userId, sessionId, accessId passed by the patcherStructure\n        const userId = patcherStructure.userId;\n        const sessionId = patcherStructure.sessionId;\n        const accessId = patcherStructure.accessId;\n        let connectionList = [];\n        const conceptList = [];\n        let composition = CreateDefaultLConcept();\n        let parentConcept = CreateDefaultLConcept();\n        const toDeleteConcepts = [];\n        // the main composition Id that has the data that needs to be patched\n        const compositionId = patcherStructure.compositionId;\n        // if you want to edit the subcompositions of the composition then you have to pass to this\n        const ofTheConceptId = patcherStructure.ofTheCompositionId;\n        let toDeleteConnections = [];\n        // get all connections from the backend because it needs latest data\n        const connectionListString = yield GetAllConnectionsOfComposition(compositionId);\n        let connectionListOriginal = connectionListString;\n        for (let i = 0; i < connectionListOriginal.length; i++) {\n            connectionList.push(convertFromConnectionToLConnection(connectionListOriginal[i]));\n        }\n        const conceptIdList = [];\n        const compositionList = [];\n        // put this in the upper section before updating because this will tell all other distributed\n        //servers to destroy the copy of the composition that they have as new composition is coming up\n        // get all the connections that are inside of the composition and store them in\n        let allConcepts = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            InsertUniqueNumber(compositionList, connectionList[i].ofTheConceptId);\n            InsertUniqueNumber(conceptIdList, connectionList[i].ofTheConceptId);\n            InsertUniqueNumber(conceptIdList, connectionList[i].toTheConceptId);\n            allConcepts.push(connectionList[i].ofTheConceptId);\n        }\n        // get all the concepts that are inside of the composition and store them in a conceptList\n        for (let i = 0; i < conceptIdList.length; i++) {\n            const conceptString = yield GetTheConcept(conceptIdList[i]);\n            const concept = conceptString;\n            if (compositionId == conceptIdList[i]) {\n                composition = convertFromConceptToLConcept(concept);\n            }\n            if (ofTheConceptId == conceptIdList[i]) {\n                parentConcept = convertFromConceptToLConcept(concept);\n            }\n            conceptList.push(convertFromConceptToLConcept(concept));\n        }\n        // now trying to patch the new object into the composition\n        const object = patcherStructure.patchObject;\n        for (const key in object) {\n            let insertingConcept = CreateDefaultLConcept();\n            const value = object[key];\n            let localConcept = composition;\n            // if the immedidate parent exists in the composition (i.e. for multilevel composition)\n            if (parentConcept.id > 0) {\n                localConcept = parentConcept;\n            }\n            if (Array.isArray(value) || typeof value == \"object\") {\n                insertingConcept = yield MakeTheInstanceConceptLocal(key, \"\", true, composition.userId, 4, 999, undefined, actions);\n                yield CreateTheCompositionLocal(object[key], insertingConcept.id, insertingConcept.userId, composition.id, composition.userId, 4, 999, undefined, actions);\n            }\n            else {\n                // make the new concept in the object\n                insertingConcept = yield MakeTheInstanceConceptLocal(key, value, false, userId, accessId, sessionId, undefined, actions);\n            }\n            // check if the concept exists in the concept list because if it exists then we have to delete old connection\n            const ExistingConcepts = CheckIfTypeLConceptsExistsInArray(conceptList, insertingConcept);\n            // if the existing concept then start the process for deleting the concept in the list\n            for (let i = 0; i < ExistingConcepts.length; i++) {\n                if (ExistingConcepts[i].id > 0) {\n                    const deletingConnections = CheckAllConnectionsConnectedInLConnectionArray(connectionList, ExistingConcepts[i].id);\n                    toDeleteConnections = toDeleteConnections.concat(deletingConnections);\n                    toDeleteConcepts.push(ExistingConcepts[i]);\n                }\n            }\n            // create the connection between the new concept and the old composition\n            const connectionString = yield CreateTheConnectionLocal(localConcept.id, insertingConcept.id, composition.id, 2, undefined, undefined, actions);\n            const connection = connectionString;\n            conceptList.push(insertingConcept);\n        }\n        // now you have to delete the connection in bulk\n        for (let j = 0; j < toDeleteConnections.length; j++) {\n            // remove from the cache list\n            // delete the connection in the backend\n            yield DeleteConnectionById(toDeleteConnections[j].id);\n        }\n        // Add Log\n        Logger.logInfo(startTime, userId, \"update\", \"unknown\", undefined, 200, object, \"UpdateCompositionLocal\", ['patcherStructure'], \"unknown\", undefined);\n        yield LocalSyncData.SyncDataOnline(undefined, actions);\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport MakeTheCharacterData from \"./MakeTheCharacterData\";\nimport MakeTheConcept from \"./MakeTheConcept\";\nexport default function MakeTheCharacter(the_character_data, userId, securityId, accessId, accessUserId, sessionId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let categoryUserId = userId;\n        let securityUserId = userId;\n        let categoryId = 4;\n        let typeId = 51;\n        let typeUserId = userId;\n        let sessionUserId = userId;\n        let referentUserId = userId;\n        let lengthOfCharacters = the_character_data.length;\n        let concept;\n        if (lengthOfCharacters == 1) {\n            let referentId = the_character_data.charCodeAt(0);\n            let typeIdForCharacter = 49;\n            let characterDataString = yield MakeTheCharacterData(the_character_data, userId, securityId, accessId, sessionId);\n            concept = MakeTheConcept(the_character_data, userId, categoryId, typeIdForCharacter, referentId, accessId, \"the_character\");\n        }\n        else {\n            let characterDataString = yield MakeTheCharacterData(the_character_data, userId, securityId, accessId, sessionId);\n            let characterData = characterDataString;\n            if (characterData.isNew) {\n                let conceptString = yield MakeTheConcept(the_character_data, userId, categoryId, typeId, characterData.id, accessId, \"the_characters\");\n                concept = conceptString;\n            }\n            else {\n                let conceptString = yield MakeTheConcept(the_character_data, userId, categoryId, typeId, characterData.id, accessId, \"the_characters\");\n                concept = conceptString;\n            }\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateTheCharacter } from \"../Api/Create/CreateTheCharacter\";\nimport { TheCharacter } from \"../DataStructures/TheCharacter\";\nexport default function MakeTheCharacterData(the_character_data, userId, securityId, accessId, sessionId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var categoryUserId = userId;\n        var accessUserId = userId;\n        var securityUserId = userId;\n        var sessionInformationUserId = userId;\n        var theCharacter = new TheCharacter(userId, the_character_data, securityId, securityUserId, accessId, accessUserId, sessionId, sessionInformationUserId, \"\", false);\n        var output = yield CreateTheCharacter(theCharacter);\n        var returner = output;\n        return returner;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetConceptByCharacterAndType } from \"../Api/GetConceptByCharacterAndType\";\nimport CreateTheConcept from \"./CreateTheConcept\";\nexport default function MakeTheConcept(referent, userId, categoryId, typeId, referentId, accessId, typeCharacter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let conceptString = yield GetConceptByCharacterAndType(referent, typeId);\n        let concept = conceptString;\n        if (concept.id == 0) {\n            conceptString = yield CreateTheConcept(referent, userId, categoryId, typeId, referentId, accessId, typeCharacter);\n            concept = conceptString;\n        }\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateTextData } from \"../Api/Create/CreateTheTextData\";\nimport { GetConceptByCharacterAndType } from \"../Api/GetConceptByCharacterAndType\";\nimport { MakeTheNameInBackend } from \"../Api/MakeTheNameInBackend\";\nimport { TheTexts } from \"../DataStructures/TheTexts\";\nimport { Logger, MakeTheTypeConceptApi, sendMessage, serviceWorker } from \"../app\";\nimport { CreateDefaultConcept } from \"./CreateDefaultConcept\";\nimport CreateTheConcept, { CreateTheConceptImmediate } from \"./CreateTheConcept\";\n/**\n * This is the basic function of the concept connection system. This function let's you create a concept within the constraints of the\n * concept connection system. This function is the building block of the concept connection system.\n * @param type this is the type of the concept. You can also think of this as the key of concept. first_name, last_name etc.\n * @param referent the actual value of the concept. The actual name of value of the concept.\n * @param composition this is a boolean that defines if the concept is a composition or not. If this is a composition then other things are also\n * connected internally with this concept. If composition is true then always a new concept is created otherwise it checks if the concept already exists\n * and creates only in the case that the concept does not already exists with its type and value as its unique identifier.\n * @param userId the userId of the creator.\n * @param passedAccessId this is the accessId of the creator. By default should be 4.\n * @param passedSessionId this is the session that is created by the system.\n * @param referentId In case we need this concept to refer to any other concept.\n * @returns a concept which is either newly created or an older concept that already exists.\n */\nexport default function MakeTheInstanceConcept(type_1, referent_1) {\n    return __awaiter(this, arguments, void 0, function* (type, referent, composition = false, userId, passedAccessId = 4, passedSessionId = 999, referentId = 0) {\n        let startTime = performance.now();\n        if (serviceWorker) {\n            const res = yield sendMessage(\"MakeTheInstanceConcept\", {\n                type,\n                referent,\n                composition,\n                userId,\n                passedAccessId,\n                passedSessionId,\n                referentId,\n            });\n            // console.log(\"data received from sw\", res);\n            return res.data;\n        }\n        let sessionInformationId = passedSessionId;\n        let categoryId = 4;\n        let categoryUserId = userId;\n        let referentUserId = 999;\n        let securityId = 999;\n        let securityUserId = userId;\n        let sessionInformationUserId = userId;\n        // change this\n        let accessId = passedAccessId;\n        let accessUserId = userId;\n        let stringToCheck = \"\";\n        let stringLength = referent.length;\n        let typeConcept = CreateDefaultConcept();\n        let concept;\n        let startsWithThe = type.startsWith(\"the_\");\n        if (startsWithThe) {\n            stringToCheck = type;\n        }\n        else {\n            stringToCheck = \"the_\" + type;\n        }\n        if (composition) {\n            let typeConceptString = yield MakeTheTypeConceptApi(type, userId);\n            typeConcept = typeConceptString;\n            let conceptString = yield CreateTheConcept(referent, userId, categoryId, typeConcept.id, referentId, accessId, type);\n            concept = conceptString;\n        }\n        else if (stringLength > 255) {\n            let typeConceptString = yield MakeTheTypeConceptApi(stringToCheck, userId);\n            typeConcept = typeConceptString;\n            let conceptString = yield CreateTheConcept(referent, userId, categoryId, typeConcept.id, referentId, accessId, stringToCheck);\n            concept = conceptString;\n            let TheTextsData = new TheTexts(userId, referent, securityId, securityUserId, accessId, accessUserId, sessionInformationId, sessionInformationUserId, Date.now().toString(), true);\n            CreateTextData(TheTextsData);\n        }\n        else {\n            let typeConceptString = yield MakeTheTypeConceptApi(stringToCheck, userId);\n            typeConcept = typeConceptString;\n            let conceptByCharTypeString = yield GetConceptByCharacterAndType(referent, typeConcept.id);\n            let conceptTypeCharacter = conceptByCharTypeString;\n            concept = conceptTypeCharacter;\n            if (conceptTypeCharacter.id == 0 && conceptTypeCharacter.userId == 0) {\n                // let makeTheNameString = await MakeTheName(referent,userId, securityId, securityUserId, accessId, accessUserId, sessionInformationId, sessionInformationUserId,typeConcept.id, typeConcept.userId,conceptTypeCharacter );\n                // let makeTheNameConcept = makeTheNameString as Concept;\n                // concept = conceptTypeCharacter;\n                let conceptString = yield CreateTheConceptImmediate(referent, userId, categoryId, typeConcept.id, 12, accessId, stringToCheck);\n                concept = conceptString;\n                MakeTheNameInBackend(concept.id, `${referent}`, typeConcept.id, userId);\n            }\n        }\n        // if(concept){\n        //     if(concept.type == null){\n        //         let conceptType = ConceptsData.GetConcept(concept.typeId);\n        //         if(conceptType == null && concept.typeId != null && concept.typeId != undefined){\n        //             let typeConceptStringNew = await GetConcept(concept.typeId);\n        //             let newTypeConcept = typeConceptStringNew as Concept;\n        //             concept.type = newTypeConcept;\n        //         }\n        //     }\n        // }\n        concept.type = typeConcept;\n        // Add Log\n        Logger.logInfo(startTime, \"unknown\", \"create\", \"unknown\", undefined, 200, concept, \"MakeTheInstanceConcept\", ['type', 'referent', 'composition', 'userId', 'passedAccessId', 'passedSessionId', 'referentId'], \"unknown\", undefined);\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { MakeTheTypeConceptApi, sendMessage, serviceWorker } from \"../app\";\nimport { CreateDefaultConcept } from \"./CreateDefaultConcept\";\nimport MakeTheConcept from \"./MakeTheConcept\";\nexport function MakeTheTimestamp(type_1, referent_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (type, referent, userId, accessId = 4, sessionInformationId = 999) {\n        if (serviceWorker) {\n            const res = yield sendMessage('MakeTheTimestamp', { type, referent, userId, accessId, sessionInformationId });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let categoryId = 4;\n        let referentId = 0;\n        // change this\n        let stringToCheck = \"\";\n        let startsWithThe = type.startsWith(\"the_\");\n        let typeConcept = CreateDefaultConcept();\n        let concept;\n        if (startsWithThe) {\n            stringToCheck = type;\n        }\n        else {\n            stringToCheck = \"the_\" + type;\n        }\n        let typeConceptString = yield MakeTheTypeConceptApi(stringToCheck, userId);\n        typeConcept = typeConceptString;\n        let conceptString = yield MakeTheConcept(referent, userId, categoryId, typeConcept.id, referentId, accessId, stringToCheck);\n        concept = conceptString;\n        return concept;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { sendMessage, serviceWorker } from \"../app\";\nimport { CreateTheConceptImmediate } from \"./CreateTheConcept\";\nimport GetConceptByCharacter from \"./GetConceptByCharacter\";\nimport MakeTheCharacter from \"./MakeTheCharacter\";\nimport { SplitStrings } from \"./SplitStrings\";\nexport function MakeTheTypeConcept(typeString, sessionId, sessionUserId, userId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage('MakeTheTypeConcept', { typeString, sessionId, sessionUserId, userId });\n            // console.log('data received from sw', res)\n            return res.data;\n        }\n        let referentId = 999;\n        let securityId = 999;\n        let accessId = 999;\n        let accessUserId = userId;\n        let existingConcept = yield GetConceptByCharacter(typeString);\n        if (existingConcept) {\n            if (existingConcept.id == 0 || existingConcept.userId == 0) {\n                let splittedStringArray = SplitStrings(typeString);\n                if (splittedStringArray.length > 0) {\n                    if (splittedStringArray[0] == typeString) {\n                        let conceptString = yield MakeTheCharacter(typeString, userId, securityId, accessId, accessUserId, sessionId);\n                        existingConcept = conceptString;\n                    }\n                    else {\n                        let categoryId = 1;\n                        let categoryConcept = yield MakeTheTypeConcept(splittedStringArray[0], sessionId, sessionUserId, userId);\n                        let typeConcept = yield MakeTheTypeConcept(splittedStringArray[1], sessionId, sessionUserId, userId);\n                        if (typeConcept) {\n                            let concept = yield CreateTheConceptImmediate(typeString, userId, categoryConcept.id, typeConcept.id, referentId, accessId, splittedStringArray[1]);\n                            existingConcept = concept;\n                        }\n                    }\n                }\n            }\n        }\n        return existingConcept;\n    });\n}\n","import { BaseUrl } from \"../../DataStructures/BaseUrl\";\nexport function publishMessage(topic, message) {\n    if (BaseUrl.MQTT_CONNECTION) {\n        BaseUrl.MQTT_CONNECTION.publish(topic, message);\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetTheConcept } from \"../../app\";\nimport { removeThePrefix } from \"../Common/RegexFunction\";\n/**\n * ######### Format is normal ######### used for listing. This only provides type connections.\n * This is helpful in building a format that has multiple mainCompositions i.e. in the context of the list\n * The list format is helpful because you do not have to go over each individual query.\n * @param connections the type connections that need (external connections) to be passed\n * @param compositionData  this is a dictionary type of format that has all the build compositions {id: { actual data}}\n * @param mainComposition this is list of  ids of the main composition that builds the tree\n * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)\n * @returns\n */\nexport function FormatConceptsAndConnectionsNormalList(connections_1, compositionData_1, mainComposition_1, newCompositionData_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, mainComposition, newCompositionData, reverse = []) {\n        var _a, _b, _c, _d;\n        let mainData = [];\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            let ofTheConcept = yield GetTheConcept(connections[i].ofTheConceptId);\n            let toTheConcept = yield GetTheConcept(connections[i].toTheConceptId);\n            if (reverseFlag == true) {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    if (toTheConcept.id in compositionData) {\n                        let newData;\n                        let key = (_b = (_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"self\";\n                        if (connections[i].toTheConceptId in compositionData) {\n                            newData = compositionData[connections[i].toTheConceptId];\n                        }\n                        else {\n                            newData = {};\n                            newData[key] = {};\n                            compositionData[connections[i].toTheConceptId] = newData;\n                        }\n                        let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                        try {\n                            let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                            let data = compositionData[connections[i].ofTheConceptId];\n                            if (data) {\n                                if (Array.isArray(newData[key][reverseCharater])) {\n                                    newData[key][reverseCharater].push(data);\n                                }\n                                else {\n                                    if (linkerConcept.characterValue.includes(\"_s_\")) {\n                                        newData[key][reverseCharater] = [];\n                                        newData[key][reverseCharater].push(data);\n                                    }\n                                    else {\n                                        newData[key][reverseCharater] = data;\n                                    }\n                                }\n                            }\n                        }\n                        catch (ex) {\n                            console.log(\"this is error\", ex);\n                        }\n                    }\n                }\n            }\n            else {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    if (ofTheConcept.id in compositionData) {\n                        let newData;\n                        let key = (_d = (_c = ofTheConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"self\";\n                        if (connections[i].ofTheConceptId in compositionData) {\n                            newData = compositionData[connections[i].ofTheConceptId];\n                            let newType = typeof newData[key];\n                            if (newType == \"string\") {\n                                newData[key] = {};\n                            }\n                        }\n                        else {\n                            newData = {};\n                            newData[key] = {};\n                            compositionData[connections[i].ofTheConceptId] = newData;\n                        }\n                        let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                        try {\n                            let data = compositionData[connections[i].toTheConceptId];\n                            if (data) {\n                                if (Array.isArray(newData[key][linkerConcept.characterValue])) {\n                                    newData[key][linkerConcept.characterValue].push(data);\n                                }\n                                else {\n                                    if (linkerConcept.characterValue.includes(\"_s_\")) {\n                                        newData[key][linkerConcept.characterValue] = [];\n                                        newData[key][linkerConcept.characterValue].push(data);\n                                    }\n                                    else {\n                                        newData[key][linkerConcept.characterValue] = data;\n                                    }\n                                }\n                            }\n                        }\n                        catch (ex) {\n                            console.log(\"this is error\", ex);\n                        }\n                    }\n                }\n            }\n        }\n        for (let i = 0; i < mainComposition.length; i++) {\n            let mymainData = compositionData[mainComposition[i]];\n            if (mymainData) {\n                mymainData[\"id\"] = mainComposition[i];\n                mainData.push(mymainData);\n            }\n        }\n        return mainData;\n    });\n}\n/**\n * ############ Format is data-id and is used for list. ############\n * This is helpful in building a format that has multiple mainCompositions i.e. in the context of the list\n * The list format is helpful because you do not have to go over each individual query.\n * @param connections the type connections that need (external connections) to be passed\n * @param compositionData  this is a dictionary type of format that has all the build compositions {id: { actual data}}\n * @param mainComposition this is list of  ids of the main composition that builds the tree\n * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)\n * @returns\n */\nexport function FormatFromConnectionsAlteredArrayExternal(connections_1, compositionData_1, newCompositionData_1, mainComposition_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, newCompositionData, mainComposition, reverse = []) {\n        var _a, _b, _c, _d;\n        let startTime = new Date().getTime();\n        let mainData = [];\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            let ofTheConcept = yield GetTheConcept(connections[i].ofTheConceptId);\n            let toTheConcept = yield GetTheConcept(connections[i].toTheConceptId);\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    if (toTheConcept.id in compositionData) {\n                        let newData;\n                        let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                        let key = (_b = (_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"self\";\n                        let flag = false;\n                        if (connections[i].toTheConceptId in compositionData) {\n                            flag = true;\n                        }\n                        if (connections[i].toTheConceptId in compositionData) {\n                            newData = compositionData[connections[i].toTheConceptId];\n                            let newType = typeof newData[key];\n                            if (newType == \"string\") {\n                                newData[key] = {};\n                            }\n                        }\n                        else {\n                            newData = {};\n                            newData[key] = {};\n                            compositionData[connections[i].toTheConceptId] = newData;\n                        }\n                        try {\n                            let isComp = compositionData[connections[i].ofTheConceptId];\n                            if (isComp) {\n                                let data = {\n                                    \"id\": ofTheConcept.id,\n                                    \"data\": compositionData[connections[i].ofTheConceptId]\n                                };\n                                let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                                if (Array.isArray(newData[key][reverseCharater])) {\n                                    newData[key][reverseCharater].push(data);\n                                }\n                                else {\n                                    if (reverseCharater.includes(\"_s_\")) {\n                                        newData[key][reverseCharater] = [];\n                                        newData[key][reverseCharater].push(data);\n                                    }\n                                    else {\n                                        newData[key][reverseCharater] = data;\n                                    }\n                                }\n                            }\n                        }\n                        catch (ex) {\n                            console.log(\"this is error\", ex);\n                        }\n                    }\n                }\n            }\n            else {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    if (ofTheConcept.id in compositionData) {\n                        let newData;\n                        let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                        let key = (_d = (_c = ofTheConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"self\";\n                        let flag = false;\n                        if (connections[i].toTheConceptId in compositionData) {\n                            flag = true;\n                        }\n                        if (connections[i].ofTheConceptId in compositionData) {\n                            newData = compositionData[connections[i].ofTheConceptId];\n                            let newType = typeof newData[key];\n                            if (newType == \"string\") {\n                                newData[key] = {};\n                            }\n                        }\n                        else {\n                            newData = {};\n                            newData[key] = {};\n                            compositionData[connections[i].ofTheConceptId] = newData;\n                        }\n                        try {\n                            let isComp = compositionData[connections[i].toTheConceptId];\n                            if (isComp) {\n                                let data = {\n                                    \"id\": toTheConcept.id,\n                                    \"data\": compositionData[connections[i].toTheConceptId]\n                                };\n                                if (Array.isArray(newData[key][linkerConcept.characterValue])) {\n                                    newData[key][linkerConcept.characterValue].push(data);\n                                }\n                                else {\n                                    if (linkerConcept.characterValue.includes(\"_s_\")) {\n                                        newData[key][linkerConcept.characterValue] = [];\n                                        newData[key][linkerConcept.characterValue].push(data);\n                                    }\n                                    else {\n                                        newData[key][linkerConcept.characterValue] = data;\n                                    }\n                                }\n                            }\n                        }\n                        catch (ex) {\n                            console.log(\"this is error\", ex);\n                        }\n                    }\n                }\n            }\n        }\n        for (let i = 0; i < mainComposition.length; i++) {\n            let mymainData = {};\n            mymainData[\"id\"] = mainComposition[i];\n            mymainData[\"data\"] = compositionData[mainComposition[i]];\n            mainData.push(mymainData);\n        }\n        return mainData;\n    });\n}\n/**\n* ############ Format is Just Id and is used for list. ############\n* This is helpful in building a format that has multiple mainCompositions i.e. in the context of the list\n* The list format is helpful because you do not have to go over each individual query.\n* @param connections the type connections that need (external connections) to be passed\n* @param compositionData  this is a dictionary type of format that has all the build compositions {id: { actual data}}\n* @param mainComposition this is list of  ids of the main composition that builds the tree\n* @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)\n* @returns\n*/\nexport function FormatFromConnectionsAlteredArrayExternalJustId(connections_1, compositionData_1, mainComposition_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, mainComposition, reverse = []) {\n        var _a, _b, _c, _d;\n        let startTime = new Date().getTime();\n        let mainData = [];\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            let ofTheConcept = yield GetTheConcept(connections[i].ofTheConceptId);\n            let toTheConcept = yield GetTheConcept(connections[i].toTheConceptId);\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    if (toTheConcept.id in compositionData) {\n                        let newData;\n                        let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                        let key = (_b = (_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"self\";\n                        let flag = false;\n                        if (connections[i].toTheConceptId in compositionData) {\n                            flag = true;\n                        }\n                        if (connections[i].toTheConceptId in compositionData) {\n                            newData = compositionData[connections[i].toTheConceptId];\n                            let newType = typeof newData[key];\n                            if (newType == \"string\") {\n                                newData[key] = {};\n                            }\n                        }\n                        else {\n                            newData = {};\n                            newData[key] = {};\n                            compositionData[connections[i].toTheConceptId] = newData;\n                        }\n                        try {\n                            let isComp = compositionData[connections[i].ofTheConceptId];\n                            if (isComp) {\n                                let data = compositionData[connections[i].ofTheConceptId];\n                                data[\"id\"] = ofTheConcept.id;\n                                let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                                if (Array.isArray(newData[key][reverseCharater])) {\n                                    newData[key][reverseCharater].push(data);\n                                }\n                                else {\n                                    if (reverseCharater.includes(\"_s_\")) {\n                                        newData[key][reverseCharater] = [];\n                                        newData[key][reverseCharater].push(data);\n                                    }\n                                    else {\n                                        newData[key][reverseCharater] = data;\n                                    }\n                                }\n                            }\n                        }\n                        catch (ex) {\n                            console.log(\"this is error\", ex);\n                        }\n                    }\n                }\n            }\n            else {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    if (ofTheConcept.id in compositionData) {\n                        let newData;\n                        let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                        let key = (_d = (_c = ofTheConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"self\";\n                        let flag = false;\n                        if (connections[i].toTheConceptId in compositionData) {\n                            flag = true;\n                        }\n                        if (connections[i].ofTheConceptId in compositionData) {\n                            newData = compositionData[connections[i].ofTheConceptId];\n                            let newType = typeof newData[key];\n                            if (newType == \"string\") {\n                                newData[key] = {};\n                            }\n                        }\n                        else {\n                            newData = {};\n                            newData[key] = {};\n                            compositionData[connections[i].ofTheConceptId] = newData;\n                        }\n                        try {\n                            let isComp = compositionData[connections[i].toTheConceptId];\n                            if (isComp) {\n                                let data = compositionData[connections[i].toTheConceptId];\n                                data[\"id\"] = toTheConcept.id;\n                                if (Array.isArray(newData[key][linkerConcept.characterValue])) {\n                                    newData[key][linkerConcept.characterValue].push(data);\n                                }\n                                else {\n                                    if (linkerConcept.characterValue.includes(\"_s_\")) {\n                                        newData[key][linkerConcept.characterValue] = [];\n                                        newData[key][linkerConcept.characterValue].push(data);\n                                    }\n                                    else {\n                                        newData[key][linkerConcept.characterValue] = data;\n                                    }\n                                }\n                            }\n                        }\n                        catch (ex) {\n                            console.log(\"this is error\", ex);\n                        }\n                    }\n                }\n            }\n        }\n        console.log(\"this is the main compositions\", mainComposition);\n        for (let i = 0; i < mainComposition.length; i++) {\n            let mymainData = {};\n            console.log(\"this is the main compositions DATA\", compositionData[mainComposition[i]]);\n            mymainData = compositionData[mainComposition[i]];\n            mymainData[\"id\"] = mainComposition[i];\n            mainData.push(mymainData);\n        }\n        return mainData;\n    });\n}\n/**\n *\n * ## Format Normal ##\n * This function takes in the connections and then converts the connections to the single level objects for further processing\n * This function is the builder of the arrays/ objects from the connections.\n */\nexport function formatFunction(connections, compositionData, reverse) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            let ofTheConcept = yield GetTheConcept(connections[i].ofTheConceptId);\n            let toTheConcept = yield GetTheConcept(connections[i].toTheConceptId);\n            if (reverseFlag == true) {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    let newData;\n                    let key = (_b = (_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"self\";\n                    if (connections[i].toTheConceptId in compositionData) {\n                        newData = compositionData[connections[i].toTheConceptId];\n                    }\n                    else {\n                        newData = {};\n                        newData[key] = {};\n                        compositionData[connections[i].toTheConceptId] = newData;\n                    }\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    try {\n                        let mytype = (_d = (_c = ofTheConcept === null || ofTheConcept === void 0 ? void 0 : ofTheConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"none\";\n                        let value = ofTheConcept.characterValue;\n                        let data = {\n                            [mytype]: value\n                        };\n                        let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                        if (linkerConcept.characterValue.includes(\"_s_\")) {\n                            if (!(ofTheConcept.id in compositionData)) {\n                                compositionData[ofTheConcept.id] = {};\n                            }\n                            compositionData[ofTheConcept.id][mytype] = value;\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    let newData;\n                    let key = (_f = (_e = ofTheConcept.type) === null || _e === void 0 ? void 0 : _e.characterValue) !== null && _f !== void 0 ? _f : \"self\";\n                    if (connections[i].ofTheConceptId in compositionData) {\n                        newData = compositionData[connections[i].ofTheConceptId];\n                    }\n                    else {\n                        newData = {};\n                        newData[key] = {};\n                        compositionData[connections[i].ofTheConceptId] = newData;\n                    }\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    try {\n                        let mytype = (_h = (_g = toTheConcept === null || toTheConcept === void 0 ? void 0 : toTheConcept.type) === null || _g === void 0 ? void 0 : _g.characterValue) !== null && _h !== void 0 ? _h : \"none\";\n                        let value = toTheConcept.characterValue;\n                        let data = {\n                            [mytype]: value\n                        };\n                        if (linkerConcept.characterValue.includes(\"_s_\")) {\n                            if (!(toTheConcept.id in compositionData)) {\n                                compositionData[toTheConcept.id] = {};\n                            }\n                            compositionData[toTheConcept.id][mytype] = value;\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        return compositionData;\n    });\n}\n/**\n*\n* ## Format Normal ##\n* This function takes in the connections and then converts the connections to the single level objects for further processing\n* This function is the builder of the arrays/ objects from the connections.\n*/\nexport function formatFunctionForData(connections, compositionData, reverse) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            let ofTheConcept = yield GetTheConcept(connections[i].ofTheConceptId);\n            let toTheConcept = yield GetTheConcept(connections[i].toTheConceptId);\n            if (reverseFlag == true) {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    let newData;\n                    let key = (_b = (_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"self\";\n                    if (connections[i].toTheConceptId in compositionData) {\n                        newData = compositionData[connections[i].toTheConceptId];\n                        if (!(key in newData)) {\n                            newData[key] = {};\n                        }\n                    }\n                    else {\n                        newData = {};\n                        newData[key] = {};\n                        compositionData[connections[i].toTheConceptId] = newData;\n                    }\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    try {\n                        let mytype = (_d = (_c = ofTheConcept === null || ofTheConcept === void 0 ? void 0 : ofTheConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"none\";\n                        let value = ofTheConcept.characterValue;\n                        let dataCharacter = linkerConcept.characterValue;\n                        if (dataCharacter == \"\") {\n                            dataCharacter = mytype;\n                            dataCharacter = removeThePrefix(dataCharacter);\n                        }\n                        let data = {\n                            [mytype]: value\n                        };\n                        let reverseCharater = dataCharacter + \"_reverse\";\n                        if (linkerConcept.characterValue.includes(\"_s_\")) {\n                            // do nothing\n                        }\n                        else {\n                            if (typeof newData[key] == \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][reverseCharater] = data;\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    let newData;\n                    let key = (_f = (_e = ofTheConcept.type) === null || _e === void 0 ? void 0 : _e.characterValue) !== null && _f !== void 0 ? _f : \"self\";\n                    if (connections[i].ofTheConceptId in compositionData) {\n                        newData = compositionData[connections[i].ofTheConceptId];\n                        if (!(key in newData)) {\n                            newData[key] = {};\n                        }\n                    }\n                    else {\n                        newData = {};\n                        newData[key] = {};\n                        compositionData[connections[i].ofTheConceptId] = newData;\n                    }\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    try {\n                        let mytype = (_h = (_g = toTheConcept === null || toTheConcept === void 0 ? void 0 : toTheConcept.type) === null || _g === void 0 ? void 0 : _g.characterValue) !== null && _h !== void 0 ? _h : \"none\";\n                        let value = toTheConcept.characterValue;\n                        let dataCharacter = linkerConcept.characterValue;\n                        if (dataCharacter == \"\") {\n                            dataCharacter = mytype;\n                            dataCharacter = removeThePrefix(dataCharacter);\n                        }\n                        let data = {\n                            [mytype]: value\n                        };\n                        if (linkerConcept.characterValue.includes(\"_s_\")) {\n                            // do nothing\n                        }\n                        else {\n                            if (typeof newData[key] == \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][dataCharacter] = data;\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        return compositionData;\n    });\n}\n/**\n * ## Format DATA-ID ##\n * this function takes in connections and creates a single level objects so that all the data are added to its object/ array.\n * This is then passed on further for stiching.\n * @param connections\n * @param compositionData\n * @param reverse\n * @returns\n */\nexport function FormatFunctionData(connections_1, compositionData_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, reverse = []) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            let ofTheConcept = yield GetTheConcept(connections[i].ofTheConceptId);\n            let toTheConcept = yield GetTheConcept(connections[i].toTheConceptId);\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    let newData;\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let key = (_b = (_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"self\";\n                    if (connections[i].toTheConceptId in compositionData) {\n                        newData = compositionData[connections[i].toTheConceptId];\n                    }\n                    else {\n                        newData = {};\n                        newData[key] = {};\n                        compositionData[connections[i].toTheConceptId] = newData;\n                    }\n                    try {\n                        let mytype = (_d = (_c = ofTheConcept === null || ofTheConcept === void 0 ? void 0 : ofTheConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"none\";\n                        let value = ofTheConcept.characterValue;\n                        let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                        if (reverseCharater.includes(\"_s_\")) {\n                            if (!(ofTheConcept.id in compositionData)) {\n                                compositionData[ofTheConcept.id] = {};\n                            }\n                            compositionData[ofTheConcept.id][mytype] = value;\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    let newData;\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let key = (_f = (_e = ofTheConcept.type) === null || _e === void 0 ? void 0 : _e.characterValue) !== null && _f !== void 0 ? _f : \"self\";\n                    if (connections[i].ofTheConceptId in compositionData) {\n                        newData = compositionData[connections[i].ofTheConceptId];\n                    }\n                    else {\n                        newData = {};\n                        newData[key] = {};\n                        compositionData[connections[i].ofTheConceptId] = newData;\n                    }\n                    try {\n                        let mytype = (_h = (_g = toTheConcept === null || toTheConcept === void 0 ? void 0 : toTheConcept.type) === null || _g === void 0 ? void 0 : _g.characterValue) !== null && _h !== void 0 ? _h : \"none\";\n                        let value = toTheConcept.characterValue;\n                        if (linkerConcept.characterValue.includes(\"_s_\")) {\n                            if (!(toTheConcept.id in compositionData)) {\n                                compositionData[toTheConcept.id] = {};\n                            }\n                            compositionData[toTheConcept.id][mytype] = value;\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        return compositionData;\n    });\n}\n/**\n* ## Format DATA-ID ##\n* this function takes in connections and creates a single level objects so that all the data are added to its object/ array.\n* This is then passed on further for stiching.\n* @param connections\n* @param compositionData\n* @param reverse\n* @returns\n*/\nexport function FormatFunctionDataForData(connections_1, compositionData_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, reverse = []) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            let ofTheConcept = yield GetTheConcept(connections[i].ofTheConceptId);\n            let toTheConcept = yield GetTheConcept(connections[i].toTheConceptId);\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    let newData;\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let key = (_b = (_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"self\";\n                    if (connections[i].toTheConceptId in compositionData) {\n                        newData = compositionData[connections[i].toTheConceptId];\n                        if (!(key in newData)) {\n                            newData[key] = {};\n                        }\n                    }\n                    else {\n                        newData = {};\n                        newData[key] = {};\n                        compositionData[connections[i].toTheConceptId] = newData;\n                    }\n                    try {\n                        let mytype = (_d = (_c = ofTheConcept === null || ofTheConcept === void 0 ? void 0 : ofTheConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"none\";\n                        let value = ofTheConcept.characterValue;\n                        let dataCharacter = linkerConcept.characterValue;\n                        // if there is not connection type defined then put the type of the destination concept.\n                        if (dataCharacter == \"\") {\n                            dataCharacter = mytype;\n                            dataCharacter = removeThePrefix(dataCharacter);\n                        }\n                        let data = {\n                            \"id\": ofTheConcept.id,\n                            \"data\": {\n                                [mytype]: value\n                            }\n                        };\n                        let reverseCharater = dataCharacter + \"_reverse\";\n                        if (reverseCharater.includes(\"_s_\")) {\n                            // do nothing\n                        }\n                        else {\n                            if (typeof newData[key] == \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][reverseCharater] = data;\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    let newData;\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let key = (_f = (_e = ofTheConcept.type) === null || _e === void 0 ? void 0 : _e.characterValue) !== null && _f !== void 0 ? _f : \"self\";\n                    if (connections[i].ofTheConceptId in compositionData) {\n                        newData = compositionData[connections[i].ofTheConceptId];\n                        if (!(key in newData)) {\n                            newData[key] = {};\n                        }\n                    }\n                    else {\n                        newData = {};\n                        newData[key] = {};\n                        compositionData[connections[i].ofTheConceptId] = newData;\n                    }\n                    try {\n                        let mytype = (_h = (_g = toTheConcept === null || toTheConcept === void 0 ? void 0 : toTheConcept.type) === null || _g === void 0 ? void 0 : _g.characterValue) !== null && _h !== void 0 ? _h : \"none\";\n                        let value = toTheConcept.characterValue;\n                        let dataCharacter = linkerConcept.characterValue;\n                        // if there is not connection type defined then put the type of the destination concept.\n                        if (dataCharacter == \"\") {\n                            dataCharacter = mytype;\n                            dataCharacter = removeThePrefix(dataCharacter);\n                        }\n                        let data = {\n                            \"id\": toTheConcept.id,\n                            \"data\": {\n                                [mytype]: value\n                            }\n                        };\n                        if (dataCharacter.includes(\"_s_\")) {\n                            // do nothing\n                        }\n                        else {\n                            if (typeof newData[key] == \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][dataCharacter] = data;\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        return compositionData;\n    });\n}\n/**\n* ## Format Just-Id ##\n* this function takes in connections and creates a single level objects so that all the data are added to its object/ array.\n* This is then passed on further for stiching.\n* @param connections\n* @param compositionData\n* @param reverse\n* @returns\n*/\nexport function FormatFunctionDataForDataJustId(connections_1, compositionData_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, reverse = []) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            let ofTheConcept = yield GetTheConcept(connections[i].ofTheConceptId);\n            let toTheConcept = yield GetTheConcept(connections[i].toTheConceptId);\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    let newData;\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let key = (_b = (_a = toTheConcept.type) === null || _a === void 0 ? void 0 : _a.characterValue) !== null && _b !== void 0 ? _b : \"self\";\n                    if (connections[i].toTheConceptId in compositionData) {\n                        newData = compositionData[connections[i].toTheConceptId];\n                        if (!(key in newData)) {\n                            newData[key] = {};\n                        }\n                    }\n                    else {\n                        newData = {};\n                        newData[key] = {};\n                        compositionData[connections[i].toTheConceptId] = newData;\n                    }\n                    try {\n                        let mytype = (_d = (_c = ofTheConcept === null || ofTheConcept === void 0 ? void 0 : ofTheConcept.type) === null || _c === void 0 ? void 0 : _c.characterValue) !== null && _d !== void 0 ? _d : \"none\";\n                        let value = ofTheConcept.characterValue;\n                        let dataCharacter = linkerConcept.characterValue;\n                        // if there is not connection type defined then put the type of the destination concept.\n                        if (dataCharacter == \"\") {\n                            dataCharacter = mytype;\n                            dataCharacter = removeThePrefix(dataCharacter);\n                        }\n                        let data = {\n                            \"id\": ofTheConcept.id,\n                            [mytype]: value\n                        };\n                        let reverseCharater = dataCharacter + \"_reverse\";\n                        if (reverseCharater.includes(\"_s_\")) {\n                            // do nothing\n                        }\n                        else {\n                            if (typeof newData[key] == \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][reverseCharater] = data;\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (ofTheConcept.id != 0 && toTheConcept.id != 0) {\n                    let newData;\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let key = (_f = (_e = ofTheConcept.type) === null || _e === void 0 ? void 0 : _e.characterValue) !== null && _f !== void 0 ? _f : \"self\";\n                    if (connections[i].ofTheConceptId in compositionData) {\n                        newData = compositionData[connections[i].ofTheConceptId];\n                        if (!(key in newData)) {\n                            newData[key] = {};\n                        }\n                    }\n                    else {\n                        newData = {};\n                        newData[key] = {};\n                        compositionData[connections[i].ofTheConceptId] = newData;\n                    }\n                    try {\n                        let mytype = (_h = (_g = toTheConcept === null || toTheConcept === void 0 ? void 0 : toTheConcept.type) === null || _g === void 0 ? void 0 : _g.characterValue) !== null && _h !== void 0 ? _h : \"none\";\n                        let value = toTheConcept.characterValue;\n                        let dataCharacter = linkerConcept.characterValue;\n                        // if there is not connection type defined then put the type of the destination concept.\n                        if (dataCharacter == \"\") {\n                            dataCharacter = mytype;\n                            dataCharacter = removeThePrefix(dataCharacter);\n                        }\n                        let data = {\n                            \"id\": toTheConcept.id,\n                            [mytype]: value\n                        };\n                        if (dataCharacter.includes(\"_s_\")) {\n                            // do nothing\n                        }\n                        else {\n                            if (typeof newData[key] == \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][dataCharacter] = data;\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        return compositionData;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SearchInternalAllApi, SearchInternalApi } from \"../../Api/Search/SearchInternalApi\";\nimport { ViewInternalData } from \"../../app\";\nexport function SearchLinkInternal(searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchQuery, token = \"\") {\n        try {\n            let conceptsConnections = yield SearchInternalApi(searchQuery, token);\n            let out = yield ViewInternalData(conceptsConnections);\n            return out;\n        }\n        catch (ex) {\n            throw ex;\n        }\n    });\n}\nexport function SearchLinkInternalAll(searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchQuery, token = \"\") {\n        try {\n            let conceptsConnections = yield SearchInternalAllApi(searchQuery);\n            let out = conceptsConnections;\n            return out;\n        }\n        catch (ex) {\n            throw ex;\n        }\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SearchLinkMultipleApi } from \"../../Api/Search/SearchLinkMultipleApi\";\nimport { DATAID, JUSTDATA, LISTNORMAL, NORMAL } from \"../../Constants/FormatConstants\";\nimport { GetConceptBulk, GetConnectionBulk, GetTheConcept, sendMessage, serviceWorker } from \"../../app\";\nimport { GetCompositionFromConnectionsInObject, GetCompositionFromConnectionsInObjectNormal, GetCompositionFromConnectionsWithDataIdInObject, GetCompositionFromConnectionsWithDataIdInObjectNew, GetConnectionDataPrefetch } from \"../GetCompositionBulk\";\nimport { formatDataArrayNormal } from \"./SearchWithTypeAndLinker\";\nexport function SearchLinkMultipleAll(searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchQuery, token = \"\", caller = null, format = DATAID) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (serviceWorker) {\n            const res = yield sendMessage('SearchLinkMultipleAll', { searchQuery, token, caller, format });\n            // console.log('data received search from sw', res)\n            return res.data;\n        }\n        let conceptIds = [];\n        let linkers = [];\n        let connections = [];\n        let reverse = [];\n        let mainCompositionId = searchQuery[0].composition;\n        let conceptsConnections = {};\n        let result = {};\n        try {\n            if (caller === null || caller === void 0 ? void 0 : caller.isDataLoaded) {\n                conceptsConnections.compositionIds = (_a = caller.conceptIds) === null || _a === void 0 ? void 0 : _a.slice();\n                conceptsConnections.internalConnections = (_b = caller.internalConnections) === null || _b === void 0 ? void 0 : _b.slice();\n                conceptsConnections.linkers = (_c = caller.linkers) === null || _c === void 0 ? void 0 : _c.slice();\n                conceptsConnections.reverse = (_d = caller.reverse) === null || _d === void 0 ? void 0 : _d.slice();\n                result = conceptsConnections;\n                conceptIds = result.compositionIds;\n                connections = result.internalConnections;\n                linkers = result.linkers;\n                reverse = result.reverse;\n            }\n            else {\n                conceptsConnections = yield SearchLinkMultipleApi(searchQuery, token);\n                if (caller) {\n                    caller.conceptIds = (_e = conceptsConnections.compositionIds) === null || _e === void 0 ? void 0 : _e.slice();\n                    caller.internalConnections = (_f = conceptsConnections.internalConnections) === null || _f === void 0 ? void 0 : _f.slice();\n                    caller.linkers = (_g = conceptsConnections.linkers) === null || _g === void 0 ? void 0 : _g.slice();\n                    caller.reverse = (_h = conceptsConnections.reverse) === null || _h === void 0 ? void 0 : _h.slice();\n                    caller.isDataLoaded = true;\n                }\n                result = conceptsConnections;\n                conceptIds = result.compositionIds;\n                connections = result.internalConnections;\n                linkers = result.linkers;\n                reverse = result.reverse;\n            }\n            let out = yield DataIdBuildLayer(linkers, conceptIds, connections, reverse, mainCompositionId, searchQuery[0], format);\n            return out;\n        }\n        catch (e) {\n            console.log(\"this is the error in the search link multiple\", e);\n            throw e;\n        }\n    });\n}\n/**\n * ######### This layer builds the data. Format is dataid ##########\n * @param linkers list of ids that help us\n * @param conceptIds this is all the concept ids that need  to be composited\n * @param connections these are the internal connections of the compositions that help in creating individual compositions\n * @param reverse this is the list of connection ids that need to show reverse connections(to->from)\n * @param mainCompositionId this is the main centre point of this data.\n * @returns\n */\nexport function DataIdBuildLayer(linkers_1, conceptIds_1, connections_1, reverse_1, mainCompositionId_1, searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (linkers, conceptIds, connections, reverse, mainCompositionId, searchQuery, format = DATAID) {\n        let startTime = new Date().getTime();\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let concepts;\n        let out;\n        if (format == JUSTDATA) {\n            concepts = yield GetCompositionFromConnectionsInObject(conceptIds, connections);\n            out = yield FormatFromConnections(linkers, concepts, mainCompositionId, reverse);\n        }\n        else if (format == NORMAL) {\n            concepts = yield GetCompositionFromConnectionsInObjectNormal(conceptIds, connections);\n            out = yield FormatFromConnections(linkers, concepts, mainCompositionId, reverse);\n        }\n        else if (format == 100) {\n            concepts = yield GetCompositionFromConnectionsWithDataIdInObjectNew(conceptIds, connections);\n            out = yield FormatFromConnectionsAltered(prefetchConnections, concepts, mainCompositionId, reverse);\n        }\n        else if (format == LISTNORMAL) {\n            out = yield formatDataArrayNormal(linkers, conceptIds, connections, searchQuery.ofCompositions, reverse);\n        }\n        else {\n            concepts = yield GetCompositionFromConnectionsWithDataIdInObject(conceptIds, connections);\n            out = yield FormatFromConnectionsAltered(prefetchConnections, concepts, mainCompositionId, reverse);\n        }\n        return out;\n    });\n}\n/**\n * ## Format is DATAID ##\n * This  is altered format and is different from others because it passes all the connections prebuilt/prefetched\n * This will not let the connections to be again fetched from the memory.\n * @param connections the type connections that need (external connections) to be passed\n * @param compositionData this is a dictionary type of format that has all the build compositions {id: { actual data}}\n * @param mainComposition this is the id of the main composition that builds the tree\n * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)\n * @returns\n */\nexport function FormatFromConnectionsAltered(connections_1, compositionData_1, mainComposition_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, mainComposition, reverse = []) {\n        let startTime = new Date().getTime();\n        let mainData = {};\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].toTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata === null || mydata === void 0 ? void 0 : mydata.data;\n                    let key = Object.keys(newData)[0];\n                    try {\n                        let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][reverseCharater])) {\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][reverseCharater] = [];\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].ofTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata === null || mydata === void 0 ? void 0 : mydata.data;\n                    let key = Object.keys(newData)[0];\n                    try {\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][linkerConcept.characterValue])) {\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][linkerConcept.characterValue] = [];\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        mainData = compositionData[mainComposition];\n        return mainData;\n    });\n}\n/**\n * ######### Format is normal ######### used for listing.\n * This is helpful in building a format that has multiple mainCompositions i.e. in the context of the list\n * The list format is helpful because you do not have to go over each individual query.\n * @param connections the type connections that need (external connections) to be passed\n * @param compositionData  this is a dictionary type of format that has all the build compositions {id: { actual data}}\n * @param mainComposition this is list of  ids of the main composition that builds the tree\n * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)\n * @returns\n */\nexport function FormatConceptsAndConnections(connections_1, compositionData_1, mainComposition_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, mainComposition, reverse = []) {\n        let mainData = [];\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let newData = compositionData[connections[i].toTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let key = Object.keys(newData)[0];\n                    try {\n                        let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][reverseCharater])) {\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][reverseCharater] = [];\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let newData = compositionData[connections[i].ofTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let key = Object.keys(newData)[0];\n                    try {\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][linkerConcept.characterValue])) {\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][linkerConcept.characterValue] = [];\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        for (let i = 0; i < mainComposition.length; i++) {\n            let mymainData = compositionData[mainComposition[i]];\n            if (mymainData) {\n                mainData.push(mymainData);\n            }\n        }\n        return mainData;\n    });\n}\n/**\n * ############ Format is data-id and is used for list. ############\n * This is helpful in building a format that has multiple mainCompositions i.e. in the context of the list\n * The list format is helpful because you do not have to go over each individual query.\n * @param connections the type connections that need (external connections) to be passed\n * @param compositionData  this is a dictionary type of format that has all the build compositions {id: { actual data}}\n * @param mainComposition this is list of  ids of the main composition that builds the tree\n * @param reverse this is the list of connections ids that needs to go to the reverse direction (to---->from)\n * @returns\n */\nexport function FormatFromConnectionsAlteredArray(connections_1, compositionData_1, conceptIds_1, mainComposition_1) {\n    return __awaiter(this, arguments, void 0, function* (connections, compositionData, conceptIds, mainComposition, reverse = []) {\n        let startTime = new Date().getTime();\n        let mainData = [];\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].toTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata === null || mydata === void 0 ? void 0 : mydata.data;\n                    let key = Object.keys(newData)[0];\n                    try {\n                        let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][reverseCharater])) {\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][reverseCharater] = [];\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].ofTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata === null || mydata === void 0 ? void 0 : mydata.data;\n                    let key = Object.keys(newData)[0];\n                    try {\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][linkerConcept.characterValue])) {\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][linkerConcept.characterValue] = [];\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        for (let i = 0; i < mainComposition.length; i++) {\n            let mymainData = compositionData[mainComposition[i]];\n            if (mymainData) {\n                mainData.push(mymainData);\n            }\n        }\n        return mainData;\n    });\n}\n/**\n * ########## Format works with JUSTDATA / NORMAL ########### used for single origin concept\n * @param linkers this is the list of linkers that\n * @param compositionData\n * @param mainComposition\n * @param reverse list of connection ids that need to show reverse conneciton.\n * @returns\n */\nexport function FormatFromConnections(linkers_1, compositionData_1, mainComposition_1) {\n    return __awaiter(this, arguments, void 0, function* (linkers, compositionData, mainComposition, reverse = []) {\n        let mainData = {};\n        let connections = yield GetConnectionBulk(linkers);\n        let myConcepts = [];\n        for (let i = 0; i < connections.length; i++) {\n            myConcepts.push(connections[i].toTheConceptId);\n            myConcepts.push(connections[i].ofTheConceptId);\n            myConcepts.push(connections[i].typeId);\n        }\n        yield GetConceptBulk(myConcepts);\n        connections.sort(function (x, y) {\n            return y.id - x.id;\n        });\n        for (let i = 0; i < connections.length; i++) {\n            let reverseFlag = false;\n            if (reverse.includes(connections[i].id)) {\n                reverseFlag = true;\n            }\n            if (reverseFlag == true) {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].toTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata;\n                    let key = Object.keys(newData)[0];\n                    try {\n                        let reverseCharater = linkerConcept.characterValue + \"_reverse\";\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][reverseCharater])) {\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][reverseCharater] = [];\n                            newData[key][reverseCharater].push(compositionData[connections[i].ofTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n            else {\n                if (compositionData[connections[i].ofTheConceptId] && compositionData[connections[i].toTheConceptId]) {\n                    let mydata = compositionData[connections[i].ofTheConceptId];\n                    let linkerConcept = yield GetTheConcept(connections[i].typeId);\n                    let newData = mydata;\n                    // console.log(\"this is the new data\", newData);\n                    let key = Object.keys(newData)[0];\n                    try {\n                        if (typeof newData === \"string\") {\n                            newData = {};\n                        }\n                        if (Array.isArray(newData[key][linkerConcept.characterValue])) {\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                        else {\n                            if (typeof newData[key] === \"string\") {\n                                newData[key] = {};\n                            }\n                            newData[key][linkerConcept.characterValue] = [];\n                            newData[key][linkerConcept.characterValue].push(compositionData[connections[i].toTheConceptId]);\n                        }\n                    }\n                    catch (ex) {\n                        console.log(\"this is error\", ex);\n                    }\n                }\n            }\n        }\n        mainData = compositionData[mainComposition];\n        return mainData;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SearchWithTypeAndLinkerApi } from '../../app';\nimport { GetCompositionFromConnectionsInObject, GetCompositionFromConnectionsInObjectNormal, GetCompositionFromConnectionsWithDataIdInObject, GetConnectionDataPrefetch } from '../GetCompositionBulk';\nimport { FormatConceptsAndConnectionsNormalList, FormatFromConnectionsAlteredArrayExternal, FormatFromConnectionsAlteredArrayExternalJustId, formatFunction, FormatFunctionData, FormatFunctionDataForData, FormatFunctionDataForDataJustId, formatFunctionForData } from './FormatData';\nimport { FormatConceptsAndConnections, FormatFromConnectionsAlteredArray } from './SearchLinkMultiple';\n/**\n * This function will help you search a concept by their type and also to query inside of it.\n * Put the number of compositions you want to get in the searchStructure which can be set by inpage and page\n * Then the type should be set in searchQuery for the compositionName.\n * Inside the searchQuery array this you can set the full linker / listLinker in the searchQuery.\n * This will give the id of the structures.\n */\nexport function SearchWithTypeAndLinkerDataId(searchStructure_1, searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchStructure, searchQuery, token = \"\") {\n        let result = yield SearchWithTypeAndLinkerApi(searchStructure, searchQuery, token);\n        let conceptIds = result.compositionIds;\n        let connections = result.internalConnections;\n        let linkers = result.linkers;\n        let reverse = result.reverse;\n        let mainCompositionIds = result.mainCompositionIds;\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let concepts = yield GetCompositionFromConnectionsWithDataIdInObject(conceptIds, connections);\n        let output = yield FormatFromConnectionsAlteredArray(prefetchConnections, concepts, conceptIds, mainCompositionIds, reverse);\n        return output;\n    });\n}\n/**\n * This function will help you search a concept by their type and also to query inside of it.\n * Put the number of compositions you want to get in the searchStructure which can be set by inpage and page\n * Then the type should be set in searchQuery for the compositionName.\n * Inside the searchQuery array this you can set the full linker / listLinker in the searchQuery.\n * This will not give the id of the structures.\n */\nexport function SearchWithTypeAndLinker(searchStructure_1, searchQuery_1) {\n    return __awaiter(this, arguments, void 0, function* (searchStructure, searchQuery, token = \"\") {\n        let result = yield SearchWithTypeAndLinkerApi(searchStructure, searchQuery, token);\n        let conceptIds = result.compositionIds;\n        let connections = result.internalConnections;\n        let linkers = result.linkers;\n        let reverse = result.reverse;\n        let mainCompositionIds = result.mainCompositionIds;\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let concepts = yield GetCompositionFromConnectionsInObject(conceptIds, connections);\n        let output = yield FormatConceptsAndConnections(prefetchConnections, concepts, mainCompositionIds, reverse);\n        return output;\n    });\n}\n/**\n * ## Format dataid ##\n * @param linkers\n * @param conceptIds\n * @param connections\n * @param mainCompositionIds\n * @param reverse\n * @returns\n */\nexport function formatDataArrayDataId(linkers, conceptIds, connections, mainCompositionIds, reverse) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let concepts = yield GetCompositionFromConnectionsWithDataIdInObject(conceptIds, connections);\n        let output = yield FormatFromConnectionsAlteredArray(prefetchConnections, concepts, conceptIds, mainCompositionIds, reverse);\n        return output;\n    });\n}\n/**\n * ## Format Normal ##\n * @param linkers\n * @param conceptIds\n * @param connections\n * @param mainCompositionIds\n * @param reverse\n * @returns\n */\nexport function formatDataArrayNormal(linkers, conceptIds, connections, mainCompositionIds, reverse) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let concepts = yield GetCompositionFromConnectionsInObjectNormal(conceptIds, connections);\n        let output = yield FormatConceptsAndConnections(prefetchConnections, concepts, mainCompositionIds, reverse);\n        return output;\n    });\n}\n/**\n * ## Format Normal ##\n * @param linkers\n * @param conceptIds\n * @param connections\n * @param mainCompositionIds\n * @param reverse\n * @returns\n */\nexport function formatLinkersNormal(linkers, conceptIds, connections, mainCompositionIds, reverse) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let concepts = yield GetCompositionFromConnectionsInObjectNormal(conceptIds, connections);\n        let output = yield FormatConceptsAndConnections(prefetchConnections, concepts, mainCompositionIds, reverse);\n        return output;\n    });\n}\n/**\n * ## Format Normal ##\n * This function fetches all the connections and then converts all the connections to the single level connections\n * Then those single level objects are then stiched together to create a complex json/ array.\n * @param linkers\n * @param conceptIds\n * @param mainCompositionIds\n * @param reverse\n * @returns\n */\nexport function formatConnections(linkers, conceptIds, mainCompositionIds, reverse) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let compositionData = [];\n        let newCompositionData = [];\n        compositionData = yield formatFunction(prefetchConnections, compositionData, reverse);\n        compositionData = yield formatFunctionForData(prefetchConnections, compositionData, reverse);\n        let output = yield FormatConceptsAndConnectionsNormalList(prefetchConnections, compositionData, mainCompositionIds, newCompositionData, reverse);\n        return output;\n    });\n}\n/**\n * ## Format JustId ##\n * This function fetches all the connections and then converts all the connections to the single level connections\n * Then those single level objects are then stiched together to create a complex json/ array.\n * @param linkers\n * @param conceptIds\n * @param mainCompositionIds\n * @param reverse\n * @returns\n */\nexport function formatConnectionsJustId(linkers, conceptIds, mainCompositionIds, reverse) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let compositionData = [];\n        let newCompositionData = [];\n        compositionData = yield formatFunction(prefetchConnections, compositionData, reverse);\n        compositionData = yield FormatFunctionDataForDataJustId(prefetchConnections, compositionData, reverse);\n        let output = yield FormatFromConnectionsAlteredArrayExternalJustId(prefetchConnections, compositionData, mainCompositionIds, reverse);\n        return output;\n    });\n}\n/**\n * ## Format DATA-ID ##\n * This function fetches all the connections and then converts all the connections to the single level connections\n * Then those single level objects are then stiched together to create a complex json/ array.\n * @param linkers\n * @param conceptIds\n * @param mainCompositionIds\n * @param reverse\n * @returns\n */\nexport function formatConnectionsDataId(linkers, conceptIds, mainCompositionIds, reverse) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let prefetchConnections = yield GetConnectionDataPrefetch(linkers);\n        let compositionData = [];\n        let newCompositionData = [];\n        compositionData = yield FormatFunctionData(prefetchConnections, compositionData, reverse);\n        compositionData = yield FormatFunctionDataForData(prefetchConnections, compositionData, reverse);\n        let output = yield FormatFromConnectionsAlteredArrayExternal(prefetchConnections, compositionData, newCompositionData, mainCompositionIds, reverse);\n        return output;\n    });\n}\n","import { TokenStorage } from \"../../DataStructures/Security/TokenStorage\";\nexport function GetRequestHeader(contentType = 'application/json', Accept = 'application/json') {\n    var headers = {\n        'Content-Type': contentType,\n        'Authorization': \"Bearer \" + TokenStorage.BearerAccessToken,\n        'Accept': Accept,\n    };\n    return headers;\n}\nexport function GetRequestHeaderWithAuthorization(contentType = 'application/json', token = \"\", Accept = 'application/json') {\n    if (token == \"\") {\n        token = TokenStorage.BearerAccessToken;\n    }\n    var headers = {\n        'Content-Type': contentType,\n        'Authorization': \"Bearer \" + token,\n        'Accept': Accept\n    };\n    return headers;\n}\nexport function GetOnlyTokenHeader() {\n    let token = TokenStorage.BearerAccessToken;\n    const myHeaders = new Headers();\n    myHeaders.append('Authorization', 'Bearer ' + token);\n    return myHeaders;\n}\n","export function SplitStrings(typeString) {\n    const pos = typeString.lastIndexOf(\"_\");\n    let SplittedStrings = [];\n    if (pos > 0) {\n        let rest = typeString.substring(0, pos);\n        let last = typeString.substring(pos + 1, typeString.length);\n        SplittedStrings = [rest, last];\n    }\n    else {\n        SplittedStrings = [typeString];\n    }\n    return SplittedStrings;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateConnectionBetweenTwoConceptsLocal, CreateTheCompositionLocal, CreateTheConnectionLocal, LocalSyncData, MakeTheInstanceConceptLocal, MakeTheTypeConceptLocal } from \"../../app\";\nexport class LocalTransaction {\n    constructor() {\n        this.actions = {\n            concepts: [],\n            connections: []\n        };\n        this.success = true;\n        this.transactionId = Math.random().toString().substring(5);\n    }\n    /**\n     * Method to initialize the transactions for specified transaction\n     */\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield LocalSyncData.initializeTransaction(this.transactionId);\n        });\n    }\n    /**\n     * Method to commi the created Transactions\n     */\n    commitTransaction() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Save the data\n            if (!this.success)\n                throw Error('Query Transaction Expired');\n            yield LocalSyncData.SyncDataOnline(this.transactionId);\n            this.actions = { concepts: [], connections: [] };\n            this.success = false;\n        });\n    }\n    /**\n     * Method to rollback all the tranctions occured\n     */\n    rollbackTransaction() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // rollback all the changes\n            this.success = false;\n            this.actions = { concepts: [], connections: [] };\n            yield LocalSyncData.rollbackTransaction(this.transactionId, this.actions);\n        });\n    }\n    /**\n     * Method to move concepts and connection to transaction collection\n     * @param concept Concept\n     */\n    markAction() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield LocalSyncData.markTransactionActions(this.transactionId, this.actions);\n        });\n    }\n    /**\n     * Concepts\n     */\n    MakeTheInstanceConceptLocal(type_1, referent_1) {\n        return __awaiter(this, arguments, void 0, function* (type, referent, composition = false, userId, accessId, sessionInformationId = 999, referentId = 0) {\n            try {\n                if (!this.success)\n                    throw Error('Query Transaction Expired');\n                const concept = yield MakeTheInstanceConceptLocal(type, referent, composition, userId, accessId, sessionInformationId, referentId, this.actions);\n                yield this.markAction();\n                return concept;\n            }\n            catch (err) {\n                console.log(err);\n                this.success = false;\n                throw err;\n            }\n        });\n    }\n    MakeTheTypeConceptLocal(typeString, sessionId, sessionUserId, userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!this.success)\n                    throw Error('Query Transaction Expired');\n                const concept = yield MakeTheTypeConceptLocal(typeString, sessionId, sessionUserId, userId, this.actions);\n                yield this.markAction();\n                return concept;\n            }\n            catch (err) {\n                console.log(err);\n                this.success = false;\n                throw err;\n            }\n        });\n    }\n    /**\n     * Connections\n     */\n    CreateConnectionBetweenTwoConceptsLocal(ofTheConcept_1, toTheConcept_1, linker_1) {\n        return __awaiter(this, arguments, void 0, function* (ofTheConcept, toTheConcept, linker, both = false) {\n            try {\n                if (!this.success)\n                    throw Error('Query Transaction Expired');\n                const connection = yield CreateConnectionBetweenTwoConceptsLocal(ofTheConcept, toTheConcept, linker, both, this.actions);\n                yield this.markAction();\n                return connection;\n            }\n            catch (err) {\n                console.log(err);\n                this.success = false;\n                throw err;\n            }\n        });\n    }\n    CreateTheConnectionLocal(ofTheConceptId_1, toTheConceptId_1, typeId_1) {\n        return __awaiter(this, arguments, void 0, function* (ofTheConceptId, toTheConceptId, typeId, orderId = 1, typeString = \"\", userId = 999) {\n            try {\n                if (!this.success)\n                    throw Error('Query Transaction Expired');\n                const connection = yield CreateTheConnectionLocal(ofTheConceptId, toTheConceptId, typeId, orderId, typeString, userId, this.actions);\n                yield this.markAction();\n                return connection;\n            }\n            catch (err) {\n                console.log(err);\n                this.success = false;\n                throw err;\n            }\n        });\n    }\n    /**\n     * Compositions\n     */\n    CreateTheCompositionLocal(json_1) {\n        return __awaiter(this, arguments, void 0, function* (json, ofTheConceptId = null, ofTheConceptUserId = null, mainKey = null, userId = null, accessId = null, sessionInformationId = null, automaticSync = false) {\n            try {\n                if (!this.success)\n                    throw Error('Query Transaction Expired');\n                const concept = yield CreateTheCompositionLocal(json, ofTheConceptId, ofTheConceptUserId, mainKey, userId, accessId, sessionInformationId, automaticSync, this.actions);\n                yield this.markAction();\n                return concept;\n            }\n            catch (err) {\n                console.log(err);\n                this.success = false;\n                throw err;\n            }\n        });\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport InsertUniqueNumber from \"../Helpers/UniqueInsert\";\nimport { CheckAllConnectionsConnectedInConnectionArray, CheckIfTypeConceptsExistsInArray, } from \"../Helpers/CheckIfExists\";\nimport { RemoveConceptFromList, RemoveConnectionFromList, } from \"../Helpers/RemoveFromArray\";\nimport { CreateDefaultConcept } from \"./CreateDefaultConcept\";\nimport { GetAllConnectionsOfComposition } from \"../Api/GetAllConnectionsOfComposition\";\nimport GetTheConcept from \"./GetTheConcept\";\nimport MakeTheInstanceConcept from \"./MakeTheInstanceConcept\";\nimport { createTheConnection } from \"./CreateTheConnection\";\nimport { DeleteConnectionById } from \"./DeleteConnection\";\nimport { SyncData } from \"../DataStructures/SyncData\";\nimport { CompositionBinaryTree } from \"../DataStructures/Composition/CompositionBinaryTree\";\nimport { Composition } from \"../DataStructures/Composition/Composition\";\nimport { CreateTheCompositionWithCache } from \"./Composition/CreateCompositionCache\";\nimport { sendMessage, serviceWorker } from \"../app\";\n// function to update the cache composition\nexport default function UpdateComposition(patcherStructure) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (serviceWorker) {\n            const res = yield sendMessage(\"UpdateComposition\", {\n                patcherStructure,\n            });\n            // console.log(\"data received from sw\", res);\n            return res.data;\n        }\n        // get all the default userId, sessionId, accessId passed by the patcherStructure\n        const userId = patcherStructure.userId;\n        const sessionId = patcherStructure.sessionId;\n        const accessId = patcherStructure.accessId;\n        let connectionList = [];\n        const conceptList = [];\n        let composition = CreateDefaultConcept();\n        let parentConcept = CreateDefaultConcept();\n        const toDeleteConcepts = [];\n        // the main composition Id that has the data that needs to be patched\n        let compositionId = patcherStructure.compositionId;\n        // if you want to edit the subcompositions of the composition then you have to pass to this\n        const ofTheConceptId = patcherStructure.ofTheCompositionId;\n        let toDeleteConnections = [];\n        if (compositionId < 0) {\n            let localConcept = yield GetTheConcept(compositionId, userId);\n            if (localConcept.id > 0) {\n                compositionId = localConcept.id;\n            }\n            else {\n                return null;\n            }\n        }\n        // get all connections from the backend because it needs latest data\n        const connectionListString = yield GetAllConnectionsOfComposition(compositionId);\n        connectionList = connectionListString;\n        const conceptIdList = [];\n        const compositionCache = new Composition();\n        const compositionList = [];\n        compositionCache.id = compositionId;\n        // put this in the upper section before updating because this will tell all other distributed\n        //servers to destroy the copy of the composition that they have as new composition is coming up\n        compositionCache.isUpdating();\n        // get all the connections that are inside of the composition and store them in\n        let allConcepts = [];\n        for (let i = 0; i < connectionList.length; i++) {\n            InsertUniqueNumber(compositionList, connectionList[i].ofTheConceptId);\n            InsertUniqueNumber(conceptIdList, connectionList[i].ofTheConceptId);\n            InsertUniqueNumber(conceptIdList, connectionList[i].toTheConceptId);\n            allConcepts.push(connectionList[i].ofTheConceptId);\n        }\n        compositionCache.subcompositions = compositionList;\n        compositionCache.connections = connectionList;\n        // get all the concepts that are inside of the composition and store them in a conceptList\n        for (let i = 0; i < conceptIdList.length; i++) {\n            const conceptString = yield GetTheConcept(conceptIdList[i]);\n            const concept = conceptString;\n            if (compositionId == conceptIdList[i]) {\n                composition = concept;\n            }\n            if (ofTheConceptId == conceptIdList[i]) {\n                parentConcept = concept;\n            }\n            conceptList.push(concept);\n        }\n        // now trying to patch the new object into the composition\n        const object = patcherStructure.patchObject;\n        for (const key in object) {\n            let insertingConcept = CreateDefaultConcept();\n            const value = object[key];\n            let localConcept = composition;\n            // if the immedidate parent exists in the composition (i.e. for multilevel composition)\n            if (parentConcept.id > 0) {\n                localConcept = parentConcept;\n            }\n            if (Array.isArray(value) || typeof value == \"object\") {\n                insertingConcept = yield MakeTheInstanceConcept(key, \"\", true, composition.userId, 4, 999);\n                compositionCache.subcompositions.push(insertingConcept.id);\n                // check if the concept exists in the concept list because if it exists then we have to delete old connection\n                const ExistingConcepts = CheckIfTypeConceptsExistsInArray(conceptList, insertingConcept);\n                // if the existing concept then start the process for deleting the concept in the list\n                for (let i = 0; i < ExistingConcepts.length; i++) {\n                    if (ExistingConcepts[i].id > 0) {\n                        const deletingConnections = CheckAllConnectionsConnectedInConnectionArray(compositionCache.connections, ExistingConcepts[i].id);\n                        toDeleteConnections = toDeleteConnections.concat(deletingConnections);\n                        toDeleteConcepts.push(ExistingConcepts[i]);\n                    }\n                }\n                yield CreateTheCompositionWithCache(object[key], insertingConcept.id, insertingConcept.userId, composition.id, composition.userId, 4, 999, compositionCache);\n            }\n            else {\n                // make the new concept in the object\n                insertingConcept = yield MakeTheInstanceConcept(key, value, false, userId, accessId, sessionId);\n                // check if the concept exists in the concept list because if it exists then we have to delete old connection\n                const ExistingConcepts = CheckIfTypeConceptsExistsInArray(conceptList, insertingConcept);\n                // if the existing concept then start the process for deleting the concept in the list\n                for (let i = 0; i < ExistingConcepts.length; i++) {\n                    if (ExistingConcepts[i].id > 0) {\n                        const deletingConnections = CheckAllConnectionsConnectedInConnectionArray(compositionCache.connections, ExistingConcepts[i].id);\n                        toDeleteConnections = toDeleteConnections.concat(deletingConnections);\n                        toDeleteConcepts.push(ExistingConcepts[i]);\n                    }\n                }\n            }\n            // create the connection between the new concept and the old composition\n            const connectionString = createTheConnection(localConcept.id, localConcept.userId, insertingConcept.id, composition.id);\n            const connection = connectionString;\n            conceptList.push(insertingConcept);\n            compositionCache.connections.push(connection);\n        }\n        // now you have to delete the connection in bulk\n        for (let j = 0; j < toDeleteConnections.length; j++) {\n            // remove from the cache list\n            RemoveConnectionFromList(compositionCache.connections, toDeleteConnections[j]);\n            // delete the connection in the backend\n            DeleteConnectionById(toDeleteConnections[j].id);\n        }\n        // also delete the existing concept from the cache.\n        for (let k = 0; k < toDeleteConcepts.length; k++) {\n            // remove concept from the cache concept list\n            RemoveConceptFromList(conceptList, toDeleteConcepts[k]);\n        }\n        // now create a composition cache object to cache it into node server\n        compositionCache.concepts = compositionCache.concepts.concat(conceptList);\n        compositionCache.mainConcept = composition;\n        compositionCache.id = composition.id;\n        // // create a cache\n        yield compositionCache.updateCache();\n        // update it the binary tree\n        CompositionBinaryTree.addCompositionToTree(compositionCache);\n        SyncData.SyncDataOnline();\n        let x = compositionCache.GetDataCache();\n        return x;\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CreateDefaultLConcept } from './../../Services/Local/CreateDefaultLConcept';\nimport { UserBinaryTree } from './../../DataStructures/User/UserBinaryTree';\nexport function GetUserGhostId(userId_1, ghostId_1) {\n    return __awaiter(this, arguments, void 0, function* (userId, ghostId, sessionId = 999) {\n        let userNode = yield UserBinaryTree.getNodeFromTree(userId, sessionId);\n        console.log(\"this is the ghost id\", userId, sessionId);\n        let realConcept = CreateDefaultLConcept();\n        if (userNode) {\n            for (let i = 0; i < userNode.value.length; i++) {\n                let testConcept = userNode.value[i];\n                if (testConcept.ghostId == ghostId) {\n                    realConcept = testConcept;\n                }\n            }\n        }\n        return realConcept;\n    });\n}\nexport function AddGhostConcept(concept_1, userId_1) {\n    return __awaiter(this, arguments, void 0, function* (concept, userId, sessionId = 999) {\n        UserBinaryTree.addConceptToTree(concept, userId, sessionId);\n    });\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ViewInternalDataApi } from \"../../Api/View/ViewInternalDataApi\";\nimport { GetTheConcept, recursiveFetch } from \"../../app\";\nexport function ViewInternalData(ids) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        try {\n            let connections = yield ViewInternalDataApi(ids);\n            let output = [];\n            for (let i = 0; i < ids.length; i++) {\n                let id = ids[i];\n                let localConnections = connections[id];\n                if (id && localConnections) {\n                    let concepts = [];\n                    let formattedOutput = {};\n                    for (let j = 0; j < localConnections.length; j++) {\n                        if (!concepts.includes(localConnections[j].ofTheConceptId)) {\n                            concepts.push(localConnections[j].ofTheConceptId);\n                        }\n                    }\n                    let out = yield recursiveFetch(id, localConnections, concepts);\n                    formattedOutput.data = out;\n                    formattedOutput.id = id;\n                    output.push(formattedOutput);\n                }\n                else {\n                    let formattedOutput = {};\n                    formattedOutput.id = id;\n                    let concept = yield GetTheConcept(id);\n                    let noconn = {};\n                    if (concept.type) {\n                        noconn[(_a = concept === null || concept === void 0 ? void 0 : concept.type) === null || _a === void 0 ? void 0 : _a.characterValue] = concept.characterValue;\n                        formattedOutput.data = noconn;\n                        output.push(formattedOutput);\n                    }\n                }\n            }\n            return output;\n        }\n        catch (err) {\n            throw err;\n        }\n    });\n}\n","// Data Type Constants\nexport const DATA_TYPES_RULES = {\n    number: /^\\d+(\\.\\d+)?$/, // Matches integers or decimals\n    text: /^[\\s\\S]*$/, // Matches any text\n    textOnly: /^[A-Za-z\\s]+$/, // Matches only letters and spaces, no numbers or special characters\n    email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/, // Matches email\n    document: /\\.(pdf|docx?|pptx?|xlsx?)$/i, // Matches common document file extensions\n    sound: /\\.(mp3|wav|ogg|flac)$/i, // Matches common sound file extensions\n    image: /\\.(jpg|jpeg|png|gif|bmp|svg|webp)$/i, // Matches common image file extensions\n    video: /\\.(mp4|avi|mov|mkv|flv|webm)$/i, // Matches common video file extensions\n    url: /^(https?:\\/\\/)?([\\da-z.-]+)\\.([a-z.]{2,6})([/\\w .-]*)*\\/?$/, // Matches standard URL format\n    date: /^\\d{4}-\\d{2}-\\d{2}$/, // Matches dates in the format YYYY-MM-DD\n    time: /^(?:[01]\\d|2[0-3]):[0-5]\\d$/, // Matches 24-hour format times, HH:MM\n    password: /^.{6,}$/, // Matches passwords with at least 6 characters; you can customize as needed\n    ipaddress: /^(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$|^([0-9a-fA-F]{1,4}:){7}([0-9a-fA-F]{1,4})$/, // Matches IPv4 or IPv6 formats\n    uuid: /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/, // Matches UUID format\n};\n","/**\n * Utility function to get input field data and attributes\n * @param fieldName - The Name of the form field.\n * @returns - An object containing the field's value and constraints (type, maxLength, etc.).\n */\nexport const createFormFieldData = (fieldName) => {\n    var _a;\n    const inputElements = document.getElementsByName(fieldName);\n    const inputElement = inputElements[0];\n    // Check if the element exists\n    if (!inputElement) {\n        console.warn(`Element with NAME \"${fieldName}\" not found.`);\n        return {\n            value: null,\n            fieldType: null,\n            dataType: null,\n            pattern: null,\n            conceptType: null,\n            maxLength: null,\n            minLength: null,\n            minValue: null,\n            maxValue: null,\n            accept: null,\n            file: null,\n            required: false,\n            isUnique: true\n        };\n    }\n    // Check for the `required` and `isUnique` attribute\n    const required = inputElement.hasAttribute('required') || inputElement.getAttribute('data-required') === 'true';\n    const isUnique = inputElement.hasAttribute('isUnique') && inputElement.getAttribute('isUnique') === 'true';\n    // Proceed to gather data if the element exists\n    const data = {\n        value: inputElement.value,\n        fieldType: inputElement.type,\n        dataType: inputElement.getAttribute('data-type'),\n        pattern: inputElement.getAttribute('data-pattern'),\n        conceptType: inputElement.getAttribute('concept-type'),\n        maxLength: inputElement.getAttribute('data-maxlength') ? parseInt(inputElement.getAttribute('data-maxlength')) : null,\n        minLength: inputElement.getAttribute('data-minlength') ? parseInt(inputElement.getAttribute('data-minlength')) : null,\n        minValue: inputElement.getAttribute('data-min') ? parseInt(inputElement.getAttribute('data-min')) : null,\n        maxValue: inputElement.getAttribute('data-max') ? parseInt(inputElement.getAttribute('data-max')) : null,\n        accept: inputElement.getAttribute('accept') || null,\n        file: inputElement.type === 'file' ? ((_a = inputElement.files) === null || _a === void 0 ? void 0 : _a[0]) || null : null,\n        required: required,\n        isUnique: isUnique\n    };\n    return data;\n};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from \"../Middleware/logger.service\";\nimport { GetConceptByCharacterAndType, MakeTheTypeConceptApi } from \"../app\";\nimport { DATA_TYPES_RULES } from \"./constant\";\nexport class Validator {\n    /**\n     * Checks if a concept with the given type and value is unique.\n     * @param type concept type where to check\n     * @param value value to check\n     * @returns boolean indicating uniqueness\n     */\n    checkUniqueness(type, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Ensure 'the_' is at the start of the type\n            if (!type.startsWith('the_')) {\n                type = 'the_' + type;\n            }\n            const sessionId = 999;\n            const sessionUserId = 999;\n            const userId = 999;\n            // Create the type concept based on session data\n            let type_concept = yield MakeTheTypeConceptApi(type, userId);\n            let type_concept_id = type_concept.id;\n            // Check if the concept exists for the provided value and type_concept_id\n            let concept = yield GetConceptByCharacterAndType(value, type_concept_id);\n            console.log(\"This is the concept for validator\", concept);\n            if (concept.id > 0) {\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * Validates a single form field based on its data type, constraints, and uniqueness.\n     * @param fieldName - The name of the field being validated (e.g., \"email\", \"phone\").\n     * @param dataType - The expected data type for the field (e.g., \"text\", \"number\").\n     * @param value - The value of the field to validate.\n     * @param conceptType - The concept type used for uniqueness check.\n     * @param maxLength - The maximum allowed length for the field value.\n     * @param minLength - The minimum allowed length for the field value.\n     * @param minValue - The minimum allowed value for the field (for numeric fields).\n     * @param maxValue - The maximum allowed value for the field (for numeric fields).\n     * @param accept - The 'accept' attribute value for file inputs.\n     * @param file - The file input (if any), used for file type validation.\n     * @param required - Whether the field is required.\n     * @param isUnique - Whether the field value should be unique.\n     * @returns An object of error messages if validation fails\n     */\n    validateField(fieldName_1, fieldType_1, dataType_1, value_1, pattern_1, conceptType_1, maxLength_1, minLength_1, minValue_1, maxValue_1, accept_1, file_1, required_1) {\n        return __awaiter(this, arguments, void 0, function* (fieldName, fieldType, dataType, value, pattern, conceptType, maxLength, minLength, minValue, maxValue, accept, file, required, isUnique = false) {\n            var _a;\n            let startTime = performance.now();\n            const errors = {};\n            // 1. Validate required field (must not be empty)\n            if (required && (value === null || value === '')) {\n                errors['required'] = `This is required field`;\n            }\n            // 2. Validate using regex pattern for the data type\n            if (dataType && value) {\n                let pattern = DATA_TYPES_RULES[dataType];\n                if (pattern && value !== '' && !pattern.test(value)) {\n                    errors['dataType'] = `Invalid value for ${dataType}`;\n                }\n            }\n            // 3. Check if the provided pattern match with the value or not\n            if (pattern && value) {\n                const regex = typeof pattern === 'string' ? new RegExp(pattern) : pattern;\n                if (value !== '' && !regex.test(value)) {\n                    errors['pattern'] = `Pattern doesn't match with value`;\n                }\n            }\n            // 4. Validate maxLength\n            if (value && maxLength !== null && value.length > maxLength) {\n                errors['maxLength'] = `Length exceeds the maximum length of ${maxLength}`;\n            }\n            // 5. Validate minLength\n            if (value && minLength !== null && value.length < minLength) {\n                errors['minLength'] = `Length must be at least ${minLength} characters long`;\n            }\n            // 6. Validate minValue (only for numeric fields)\n            if (minValue !== null && value && !isNaN(Number(value)) && Number(value) < minValue) {\n                errors['minValue'] = `Value must be greater than or equal to ${minValue}`;\n            }\n            // 7. Validate maxValue (only for numeric fields)\n            if (maxValue !== null && value && !isNaN(Number(value)) && Number(value) > maxValue) {\n                errors['maxValue'] = `Value must be less than or equal to ${maxValue}`;\n            }\n            // 8. File validation: Check if this is a file input\n            if (file) {\n                if (fieldType && accept) {\n                    const acceptedTypes = accept.split(',').map(type => type.trim().toLowerCase());\n                    const fileExtension = (_a = file.name.split('.').pop()) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n                    if (fileExtension && !acceptedTypes.includes(fileExtension)) {\n                        errors['accept'] = `File must be a valid file type: ${acceptedTypes.join(', ')}`;\n                    }\n                }\n            }\n            // 9. Check if the field needs to be unique and perform uniqueness validation\n            if (conceptType && isUnique && value) {\n                const isUniqueValue = yield this.checkUniqueness(conceptType, value);\n                if (!isUniqueValue) {\n                    errors['unique'] = `Value is not unique`;\n                }\n            }\n            // Add Log\n            console.log(\"validateField...\");\n            Logger.logInfo(startTime, \"\", undefined, \"Unknown\", \"Unknown\", 200, errors, \"validateField\", ['fieldName', 'fieldType', 'dataType', 'value', 'pattern', 'conceptType', 'minLength', 'maxLength', 'minValue', 'maxValue', 'accept', 'file', 'required', 'isUnique'], // Function parameters\n            \"UnknownUserAgent\", []);\n            return errors;\n        });\n    }\n    /**\n     * Validates all form fields by iterating over the provided form data.\n     * It checks each field's value, data type, and constraints, collecting errors where necessary.\n     *\n     * @param formData - An object representing the form data, where each key is a field name\n     *                   and each value is an object containing the `value`, `dataType`, and constraints (e.g., `maxLength`, `minLength`).\n     *\n     * @returns An object containing validation errors for fields that failed validation.\n     *          If no errors exist, the object will be empty.\n     */\n    validateForm(formData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let startTime = performance.now();\n            const validationErrors = {};\n            // Iterate through the fields in the form data\n            for (const fieldName in formData) {\n                const { value, fieldType, dataType, pattern, conceptType, maxLength = null, minLength = null, minValue = null, maxValue = null, accept = null, file = null, required, isUnique } = formData[fieldName];\n                // Call the validateField function to validate each field\n                const fieldErrors = yield this.validateField(fieldName, fieldType, dataType, value, pattern, conceptType, maxLength, minLength, minValue, maxValue, accept, file, required, isUnique);\n                if (Object.keys(fieldErrors).length > 0)\n                    validationErrors[fieldName] = fieldErrors;\n            }\n            // Add Log\n            console.log(\"validateForm...\");\n            Logger.logInfo(startTime, \"\", undefined, \"Unknown\", \"Unknown\", 200, validationErrors, \"validateForm\", ['formData'], \"UnknownUserAgent\", []);\n            return validationErrors;\n        });\n    }\n    /**\n     *\n     * @param fieldName\n     * @param fieldType\n     * @param dataType\n     * @param value\n     * @param pattern\n     * @param conceptType\n     * @param maxLength\n     * @param minLength\n     * @param minValue\n     * @param maxValue\n     * @param accept\n     * @param file\n     * @param required\n     * @param isUnique\n     * @returns Object with status and details\n     */\n    validate(fieldName, fieldType, dataType, value, pattern, conceptType, maxLength, minLength, minValue, maxValue, accept, file, required, isUnique = false) {\n        let error = {};\n        this.validateField(fieldName, fieldType, dataType, value, pattern, conceptType, maxLength, minLength, minValue, maxValue, accept, file, required, isUnique).then((err) => {\n            if (Object.keys(err).length > 0) {\n                error['status'] = false;\n                error['details'] = err;\n            }\n            else {\n                error['status'] = true;\n            }\n        });\n        return error;\n    }\n}\n","export class BaseObserver {\n    constructor() {\n        /**\n         * This is the subscribers of the data. If any thing on this widget changes then all the functions\n         * in the subscribers are called.\n         */\n        this.subscribers = [];\n    }\n    /**\n    * This is called by any data change. So that any data change will notify all the callback functions to execute.\n    */\n    notify() {\n        this.subscribers.map((subscriber) => {\n            subscriber(this.data);\n        });\n    }\n    /**\n     * This function is used to register the callback into the function in case of any dataChange.\n     * @param callback sets this callback to the subscribers list in the widget. So that in any change we can call this callback\n     * @returns execution of the callback passed.\n     */\n    dataChange(callback) {\n        this.subscribers.push(callback);\n        return callback(this.data);\n    }\n}\n","import { BaseObserver } from \"./BaseObserver\";\nexport class BaseWidget extends BaseObserver {\n    constructor() {\n        super(...arguments);\n        /**\n         * This is a random identifier to the widget that is used to identify the widget and other elements\n         * inside of it.\n         */\n        this.elementIdentifier = 0;\n        /**\n         * This flag is set to denote that that widget has been mounted\n         */\n        this.widgetMounted = false;\n    }\n    getComponent() {\n        let component = document.getElementById(this.elementIdentifier.toString());\n        return component;\n    }\n    getElementById(identifier) {\n        let element = this.getComponent();\n        let selectedElement = document.body;\n        if (element) {\n            let myelement = element.querySelector('#' + identifier);\n            if (myelement) {\n                selectedElement = myelement;\n                return selectedElement;\n            }\n        }\n        return null;\n    }\n    /**\n     *\n     * @returns random number that will be used to put into the main widget div so that we can uniqely identify\n     * the widget and its children from others.\n     */\n    createWidgetWrapperIdentifier() {\n        this.elementIdentifier = Math.random() * 10000;\n        return this.elementIdentifier.toString();\n    }\n}\n","export function TypeEditor(event, that) {\n    if (event) {\n        const inputVal = document.querySelector(\"#widget-properties #widget-type\");\n        console.log(\"This is the input val container\", inputVal, that, event);\n        const existedInputEl = inputVal === null || inputVal === void 0 ? void 0 : inputVal.querySelectorAll(\"input\");\n        existedInputEl === null || existedInputEl === void 0 ? void 0 : existedInputEl.forEach((inputItem) => {\n            inputItem === null || inputItem === void 0 ? void 0 : inputItem.remove();\n        });\n        // this is used to add the type value to the dom so that we can then fix the type in the child widget.\n        console.log(\"event.target\", event.target);\n        const elementParent = event.target.closest(\".added-widget-container\");\n        const elementDivParent = event.target.closest(\"div\");\n        let typeValue = \"\";\n        if (elementParent) {\n            typeValue = elementParent === null || elementParent === void 0 ? void 0 : elementParent.getAttribute(\"data-type-value\");\n        }\n        else if (elementDivParent) {\n            typeValue = elementDivParent === null || elementDivParent === void 0 ? void 0 : elementDivParent.getAttribute(\"data-type-value\");\n        }\n        const inputEl = document.createElement(\"input\");\n        inputEl.setAttribute(\"type\", \"text\");\n        inputEl.setAttribute(\"name\", \"input-widgetTypeValue\");\n        inputEl.setAttribute(\"of\", that.elementIdentifier.toString());\n        inputEl.setAttribute(\"class\", \"form-control\");\n        inputEl.setAttribute(\"id\", \"widgetType\");\n        if (that.widgetType) {\n            inputEl.value = that.widgetType;\n        }\n        else {\n            inputEl.setAttribute(\"placeholder\", \"e.g. the_entity\");\n        }\n        let newThat = that;\n        inputEl.onchange = function (event) {\n            var _a, _b, _c;\n            event.preventDefault();\n            event.stopPropagation();\n            //console.log(\"THAT ->\", that);\n            const inputValue = (_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.value;\n            newThat.widgetType = inputValue;\n            //console.log(\"inputValue\", inputValue);\n            //that.setProperty(inputValue);\n            newThat.componentDidMount();\n            newThat.loadChildWidgets();\n            (_c = (_b = newThat.element) === null || _b === void 0 ? void 0 : _b.parentElement) === null || _c === void 0 ? void 0 : _c.setAttribute(\"data-type-value\", newThat.widgetType);\n        };\n        inputVal === null || inputVal === void 0 ? void 0 : inputVal.appendChild(inputEl);\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { StatefulWidget } from \"./StatefulWidget\";\nimport { CreateTheConnectionLocal, DATAID, FilterSearch, FreeschemaQuery, MakeTheTypeConceptLocal, SchemaQueryListener } from \"../app\";\nimport * as tsccs from \"../app\";\nimport { TypeEditor } from \"./BuilderSpeceficFunctions\";\nexport class BuilderStatefulWidget extends StatefulWidget {\n    constructor() {\n        super(...arguments);\n        this.childComponents = [];\n        this.componentMounted = false;\n        this.oldHtml = null;\n        this.phonebooks = [];\n        this.childrenData = {};\n        this.childWidgets = [];\n        this.typeValueList = [];\n        this.widgetType = \"the_element_name\";\n        this.parentConceptList = [];\n    }\n    // async getWidgetCodeFromId(widgetId: number, token: string) {\n    //   //console.log(\"getWidgetCodeFromId\", widgetId, token);\n    //   return new Promise(async (resolve: any, reject: any) => {\n    //     try {\n    //       let searchFirst = new SearchQuery();\n    //       searchFirst.composition = widgetId;\n    //       searchFirst.fullLinkers = [\n    //         \"the_widgetcode\",\n    //         \"the_widgetcode_widget\",\n    //         \"the_widgetcode_name\",\n    //         \"the_widgetcode_html\",\n    //         \"the_widgetcode_css\",\n    //         \"the_widgetcode_js\",\n    //         \"the_widgetcode_timestamp\",\n    //         \"the_widgetcode_typevalue\",\n    //         \"the_widgetcode_addevent\",\n    //         \"the_widgetcode_onmount\",\n    //         \"the_widgetcode_onupdate\",\n    //         \"the_widgetcode_mountChildWidgets\",\n    //         \"the_widgetcode_cleanhtml\",\n    //         \"the_widgetcode_s_child\",\n    //       ];\n    //       searchFirst.inpage = 100;\n    //       let searchSecond = new SearchQuery();\n    //       searchSecond.fullLinkers = [\n    //         \"the_childwidget\",\n    //         \"the_childwidget_typevalue\",\n    //         \"the_childwidget_widget\",\n    //         \"the_childwidget_wrapperId\",\n    //       ];\n    //       searchSecond.inpage = 100;\n    //       const queryParams = [searchFirst, searchSecond];\n    //       const output = await SearchLinkMultipleAll(queryParams, token);\n    //       //console.log(\"getWidgetCodeFromId output ->\", output);\n    //       resolve(output);\n    //       return output;\n    //     } catch (error: any) {\n    //       console.error(\"error\", error);\n    //       if (error?.status === 401) {\n    //         HandleHttpError(error?.response)\n    //       }\n    //       reject(error);\n    //     }\n    //   });\n    // }\n    // async CreateConceptConnections(){\n    //   let mainConcept = await \n    //   for(let i=0; i<this.childrenData.length; i++){\n    //   }\n    // }\n    getUserId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const profileData = yield new Promise((resolve) => {\n                let dataFromLocalStorage = (localStorage === null || localStorage === void 0 ? void 0 : localStorage.getItem(\"profile\")) || \"\";\n                if (dataFromLocalStorage) {\n                    const profileData = JSON.parse(dataFromLocalStorage);\n                    resolve(profileData);\n                }\n                else {\n                    resolve();\n                }\n            });\n            const userId = profileData === null || profileData === void 0 ? void 0 : profileData.userId;\n            return userId;\n        });\n    }\n    getTypeValueList() {\n        return __awaiter(this, arguments, void 0, function* (typeName = \"\") {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                typeName = this.widgetType;\n                // typeName e.g. \"the_element_name\"\n                const match = typeName === null || typeName === void 0 ? void 0 : typeName.match(/^[a-z0-9]+_[a-z0-9]+/i);\n                const mainComposition = match ? match[0] : \"\";\n                // Output: \"the_element\"\n                const nextMatch = typeName === null || typeName === void 0 ? void 0 : typeName.match(/^([a-z0-9]+).*_([a-z0-9]+)$/i);\n                const typevalueKey = nextMatch ? `${nextMatch[1]}_${nextMatch[2]}` : \"\";\n                // NEW SEARCH WITH FILTER\n                // filters\n                let filters = [];\n                let filter = new FilterSearch();\n                // filter.type = \"the_email\";\n                filter.type = typevalueKey;\n                filter.search = \"1\";\n                filter.logicoperator = \">\";\n                filter.name = \"emailfilter\";\n                filter.operateon = \"entityEmail\";\n                filter.composition = false;\n                filters.push(filter);\n                let emailQuery = new FreeschemaQuery();\n                // emailQuery.typeConnection = \"the_entity_email\";\n                emailQuery.typeConnection = typeName;\n                emailQuery.name = \"entityEmail\";\n                let freeschemaQuery = new FreeschemaQuery();\n                // freeschemaQuery.type = \"the_entity\",\n                (freeschemaQuery.type = mainComposition),\n                    (freeschemaQuery.filterLogic = \"( emailfilter )\");\n                freeschemaQuery.filters = filters;\n                freeschemaQuery.name = \"top\";\n                freeschemaQuery.inpage = 100;\n                freeschemaQuery.freeschemaQueries = [emailQuery];\n                freeschemaQuery.outputFormat = DATAID;\n                SchemaQueryListener(freeschemaQuery, \"\")\n                    .subscribe((output) => {\n                    if (output === null || output === void 0 ? void 0 : output.length) {\n                        const result = output === null || output === void 0 ? void 0 : output.map((item) => {\n                            var _a, _b, _c, _d, _e, _f, _g;\n                            const itemName = (_d = (_c = (_b = (_a = item.data) === null || _a === void 0 ? void 0 : _a[mainComposition]) === null || _b === void 0 ? void 0 : _b[typeName]) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[typevalueKey];\n                            const itemId = (_g = (_f = (_e = item.data) === null || _e === void 0 ? void 0 : _e[mainComposition]) === null || _f === void 0 ? void 0 : _f[typeName]) === null || _g === void 0 ? void 0 : _g.id;\n                            return {\n                                id: itemId,\n                                name: itemName,\n                                text: itemName,\n                            };\n                        });\n                        //console.log(\"result =>\", result);\n                        this.typeValueList = result;\n                        resolve(result);\n                        return result;\n                    }\n                });\n            }));\n        });\n    }\n    setTitle(title) {\n        document.title = title;\n    }\n    getHtml() {\n        return this.html;\n    }\n    createRandomNumber() {\n        this.elementIdentifier = Math.random() * 10000;\n        return this.elementIdentifier;\n    }\n    mountChildWidgets() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const dynamicAsyncFunction = new Function(\"tsccs\", `\r\n      return (async function() {\r\n        ${this.mountChildWidgetsFunction}\r\n      }).call(this);\r\n    `).bind(this);\n            dynamicAsyncFunction(tsccs);\n        });\n    }\n    setProperty(widgetTypeName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.widgetType = widgetTypeName;\n            this.getTypeValueList(this.widgetType).then(() => {\n                var _a, _b, _c;\n                (_a = this.element) === null || _a === void 0 ? void 0 : _a.setAttribute(\"data-type-value\", this.widgetType);\n                (_c = (_b = this.element) === null || _b === void 0 ? void 0 : _b.parentElement) === null || _c === void 0 ? void 0 : _c.setAttribute(\"data-type-value\", this.widgetType);\n                this.render();\n            });\n            return this;\n        });\n    }\n    createTypeEditor(event) {\n        TypeEditor(event, this);\n    }\n    /**\n     *\n     * @param parent This is the function that creates a new div and then mounts the html element to the parent.\n     */\n    mount(parent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            //console.log('mount parent',)\n            if (parent) {\n                this.element = document.createElement(\"div\");\n                let that = this;\n                this.element.onclick = function (event) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    that.createTypeEditor(event);\n                };\n                this.element.id = this.createWidgetWrapperIdentifier();\n                this.element.className = \"p-2 mftsccs-marking-element\";\n                this.element.innerHTML = this.getHtml();\n                parent === null || parent === void 0 ? void 0 : parent.setAttribute(\"data-type-value\", that.widgetType);\n                parent.appendChild(this.element);\n                this.parentElement = parent.id;\n                if (this.componentMounted == false || this.widgetMounted == false) {\n                    // Simulate componentDidMount by calling it after the component is inserted into the DOM\n                    this.componentDidMount();\n                    this.mountChildWidgets();\n                    this.widgetMounted = true;\n                    this.componentMounted = true;\n                }\n                else {\n                    this.render();\n                }\n                this.childWidgetElement = this.getElementByClassName(\"added-widget-container\");\n            }\n        });\n    }\n    /**\n     * This function will be called after the component mounts.\n     */\n    componentDidMount() {\n        //console.log(\"onmountVal\", onmountVal);\n        const dynamicAsyncFunction = new Function(\"tsccs\", `\r\n      return (async function() {\r\n        ${this.componentDidMountFunction}\r\n      }).call(this);\r\n    `).bind(this);\n        dynamicAsyncFunction(tsccs);\n        // dynamicAsyncFunction(tsccs);\n        // const AsyncFunction = Object.getPrototypeOf(\n        //   async function () {}\n        // ).constructor;\n        // const renderOnmount = AsyncFunction(\n        //   \"tsccs\",\n        //   this.componentDidMountFunction\n        // );\n        // renderOnmount.call(this, tsccs);\n    }\n    addEvents() {\n        // const AsyncFunction = Object.getPrototypeOf(\n        //   async function () {}\n        // ).constructor;\n        const dynamicAsyncFunction = new Function(\"tsccs\", `\r\n      return (async function() {\r\n        ${this.addEventFunction}\r\n      }).call(this);\r\n    `).bind(this);\n        dynamicAsyncFunction(tsccs);\n        // const renderOnmount = AsyncFunction(\"tsccs\", this.addEventFunction);\n        // renderOnmount.call(this, tsccs);\n    }\n    // async getWidgetClassFunction(widgetId: number) {\n    //   return new Promise(async (resolve: any) => {\n    //     const profileData: any = await new Promise((resolve2: any) => {\n    //       let dataFromLocalStorage: string = localStorage?.getItem(\"profile\") || \"\";\n    //       if (dataFromLocalStorage) {\n    //         const profileData = JSON.parse(dataFromLocalStorage);\n    //         resolve2(profileData)\n    //       } else {\n    //         resolve2()\n    //       }\n    //     });\n    //     const token = profileData?.token;\n    //     let output: any = await this.getWidgetCodeFromId(widgetId, token);\n    //     const widgetInfo = output?.data?.the_widgetcode;\n    //     const widgetName = widgetInfo?.the_widgetcode_name?.[0]?.data?.the_name;\n    //     const widgetHTML = widgetInfo?.the_widgetcode_html?.[0]?.data?.the_html;\n    //     const widgetCSS = widgetInfo?.the_widgetcode_css?.[0]?.data?.the_css;\n    //     const widgetJS = widgetInfo?.the_widgetcode_js?.[0]?.data?.the_js;\n    //     const widgetTimestamp =\n    //       widgetInfo?.the_widgetcode_timestamp?.[0]?.data?.the_timestamp;\n    //     const widgetPackageId = widgetInfo?.the_widgetcode_widget?.[0].id;\n    //     const widgetAddEvent =\n    //       widgetInfo?.the_widgetcode_addevent?.[0]?.data?.the_addevent;\n    //     const widgetOnmount =\n    //       widgetInfo?.the_widgetcode_onmount?.[0]?.data?.the_onmount;\n    //     const widgetOnupdate =\n    //       widgetInfo?.the_widgetcode_onupdate?.[0]?.data?.the_onupdate;\n    //     const widgetMountChildWidgets =\n    //       widgetInfo?.the_widgetcode_mountChildWidgets?.[0]?.data\n    //         ?.the_mountChildWidgets;\n    //     const widgetData = {\n    //       id: output?.id,\n    //       name: widgetName,\n    //       html: widgetHTML,\n    //       css: widgetCSS,\n    //       js: widgetJS,\n    //       timestamp: widgetTimestamp,\n    //       widgetId: widgetPackageId,\n    //       addevent: widgetAddEvent,\n    //       onmount: widgetOnmount,\n    //       onupdate: widgetOnupdate,\n    //       mountChildWidgets: widgetMountChildWidgets,\n    //     };\n    //     const widgetInstance = new BuilderStatefulWidget();\n    //     widgetInstance.html = widgetData?.html;\n    //     widgetInstance.componentDidMountFunction = widgetData?.onmount;\n    //     widgetInstance.addEventFunction = widgetData?.addevent;\n    //     widgetInstance.mountChildWidgetsFunction = widgetData?.mountChildWidgets;\n    //     resolve(widgetInstance);\n    //   });\n    // }\n    CreateConnectionBetweenEntityLocal(concept1Data, concept2Data, linker) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const userId = concept1Data.userId;\n            const sessionInformationId = 999;\n            const sessionInformationUserId = 999;\n            const prefix = (_a = concept1Data.type) === null || _a === void 0 ? void 0 : _a.characterValue;\n            const linkerAdd = linker;\n            const forwardLinker = prefix + \"_\" + linkerAdd;\n            const connectionConcept = yield MakeTheTypeConceptLocal(forwardLinker, sessionInformationId, sessionInformationUserId, userId);\n            yield CreateTheConnectionLocal(concept1Data.id, concept2Data.id, connectionConcept.id, 1000);\n            return \"connection created\";\n        });\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BaseWidget } from \"./BaseWidget\";\n/**\n * Implementation of a widget system. If you need to create a widget that is compatible with the concept connection\n * system them extend this class and populate the functions such as getHtml() and widgetDidMount()\n */\nexport class StatefulWidget extends BaseWidget {\n    constructor() {\n        super(...arguments);\n        this.html = \"\";\n        /**\n         * These are the child widgets that need to be added to  this widget\n         */\n        this.childWidgets = [];\n        this.childWidgetElement = [];\n        /**\n         * This is the id of the parentElement of this widget.\n         */\n        this.parentElement = \"\";\n        /**\n         * This is the element that is a copy of the element that is mounted.\n         */\n        this.element = null;\n    }\n    getElement() {\n        return this.element;\n    }\n    setTitle(title) {\n        document.title = title;\n    }\n    /**\n     *\n     * @returns the html string that needs to be mounted to the DOM.\n     */\n    getHtml() {\n        return this.html;\n    }\n    /**\n     * This will help us update the data of the child widget. This will also call another function inside of the child widget\n     * called udpateWidget which the user can call after some data is udpated.\n     * @param value\n     * @param widget\n     */\n    UpdateChildData(value, widget) {\n        let passedWidget = widget;\n        passedWidget.data = value;\n        passedWidget.render();\n        passedWidget.updateWidget();\n    }\n    /**\n     * This is called after the data has been udpated by some other component.\n     */\n    updateWidget() { }\n    /**\n     *\n     * @param newState\n     */\n    setState(newState) {\n        this.data = newState;\n        this.notify();\n        this.render();\n    }\n    /**\n     * If any child widgets are registered in the widget. Then without any other changes to the contents and state\n     * this loadChildWidgets will be called which will help the child widgets be rendered to their respective positions.\n     */\n    loadChildWidgets() {\n        this.childWidgets.map((child) => {\n            let widget = this.getElementById(child.parentElement);\n            if (widget) {\n                widget.innerHTML = \"\";\n            }\n            child.mount(widget);\n        });\n    }\n    /**\n     * This is the main function that adds the html of the component to the element.\n     * The element is the mounted widget\n     */\n    render() {\n        if (this.element) {\n            this.element.innerHTML = this.getHtml();\n        }\n        //console.log(\"added-widget-container\",this.childWidgetElement);\n        // addEvents is called after the element has been mounted.\n        this.addEvents();\n        // then after the child widgets are again loaded.\n        if (this.widgetMounted) {\n            this.loadChildWidgets();\n        }\n    }\n    getElementByClassName(identifier) {\n        let element = this.getComponent();\n        if (element) {\n            let myelement = element === null || element === void 0 ? void 0 : element.querySelectorAll('.' + identifier);\n            console.log(\"this is the element\", element, myelement, identifier);\n            return myelement;\n        }\n        return [];\n    }\n    /**\n     * This is the function that needs to be called.\n     */\n    mountChildWidgets() {\n    }\n    /**\n     *\n     * @param parent This is the function that creates a new div and then mounts the html element to the parent.\n     */\n    mount(parent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (parent) {\n                // create a div to wrap everything inside of it.\n                this.element = document.createElement(\"div\");\n                // assign an identifier to the element so that it does not conflict with others.\n                this.element.id = this.createWidgetWrapperIdentifier();\n                // then assign the html to the element.\n                this.element.innerHTML = this.getHtml();\n                // mount the div with unique identifier to the parent element.\n                parent.appendChild(this.element);\n                // also save in the widget its parent identifier.\n                this.parentElement = parent.id;\n                // if the widget has not been mounted.\n                if (this.widgetMounted == false) {\n                    // then after the widget has been mounted for the first time call this function\n                    // user can update this function as per their requirement \n                    //this will mostly be used to bind data / call data \n                    this.widgetDidMount();\n                    // since this is the first time the widget is being created. then all the child widgets are being mounted \n                    // as well here.\n                    this.mountChildWidgets();\n                    // after the widget has been mounted for the first time then the widget has been updated.\n                    this.widgetMounted = true;\n                }\n                else {\n                    // if the widget has already been mounted before then only render the new widget\n                    this.render();\n                }\n            }\n        });\n    }\n    /**\n     * This function will be called after the component mounts.\n     */\n    widgetDidMount() {\n        this.render();\n    }\n    /**\n     * This is called after the render function has been called. So this is used for the user functions to be added\n     * for the widget and its html element. User can add any logic here.\n     */\n    addEvents() {\n    }\n}\n","//import { BuilderStatefulWidget } from \"../default/StatefulWidget\"\nimport { BuilderStatefulWidget } from \"./BuilderStatefulWidget\";\nexport class WidgetTree {\n    constructor() {\n        this.id = 0;\n        this.name = \"\";\n        this.html = \"\";\n        this.css = \"\";\n        this.js = \"\";\n        this.timestamp = \"\";\n        this.widgetId = 0;\n        this.typeValue = \"\";\n        this.cleanHtml = \"\";\n        this.addEvent = \"\";\n        this.onmount = \"\";\n        this.onupdate = \"\";\n        this.mountChildWidgets = \"\";\n        this.children = [];\n        this.wrapperId = 0;\n        this.widget = new BuilderStatefulWidget();\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData } from \"../app\";\nimport { NORMAL } from \"../Constants/FormatConstants\";\n/**\n * This is the class that helps us observe anything that the function is doing\n * This wrapper will allow all the concepts and connections to be tracked inside of the called function\n * This function helps us manage state using the concept connection system.\n */\nexport class DependencyObserver {\n    constructor() {\n        this.subscribers = []; // this is the list of subscribers that are added to this observer.\n        this.mainConcept = 0;\n        this.compositionIds = [];\n        this.conceptIds = [];\n        this.internalConnections = [];\n        this.reverse = [];\n        this.linkers = [];\n        this.dependency = [];\n        this.isDataLoaded = false; // checks to see if the data has been loaded to the widget/ function\n        this.isUpdating = false; // this flag helps us check if the state is being updated while the connection updates.\n        this.fetched = false;\n        this.format = NORMAL;\n    }\n    /**\n     * This function will be called when there is a need to listen to a certain type of concept that will update\n     *  the ui.\n     * @param id this is the type id which needs to be tracked\n     */\n    listenToEventType(id) {\n        window.addEventListener(`${id}`, (event) => {\n            if (!this.isUpdating) {\n                this.isUpdating = true;\n                let that = this;\n                setTimeout(function () {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        let myEvent = event;\n                        if (!that.compositionIds.includes(myEvent === null || myEvent === void 0 ? void 0 : myEvent.detail)) {\n                            that.compositionIds.unshift(myEvent === null || myEvent === void 0 ? void 0 : myEvent.detail);\n                            that.listenToEvent(myEvent === null || myEvent === void 0 ? void 0 : myEvent.detail);\n                        }\n                        that.isUpdating = false;\n                        yield that.bind();\n                        that.notify();\n                    });\n                }, 200);\n            }\n            else {\n                console.log(\"rejected this\");\n            }\n        });\n    }\n    /**\n     * This is the of the concept id that needs to be listened . If this is called. All the connections that are\n     * created with of the concepts id with this passed id then the event is fired.\n     *\n     * @param id Of the concept id that needs to be listened.\n     */\n    listenToEvent(id) {\n        window.addEventListener(`${id}`, (event) => {\n            if (!this.isUpdating) {\n                this.isUpdating = true;\n                let that = this;\n                setTimeout(function () {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        let newConnection = yield ConnectionData.GetConnectionByOfTheConceptAndType(id, id);\n                        for (let i = 0; i < newConnection.length; i++) {\n                            yield ConnectionData.GetConnection(newConnection[i]).then((conn) => {\n                                if (conn.typeId == that.mainConcept) {\n                                    if (!that.internalConnections.includes(conn.id)) {\n                                        that.internalConnections.push(conn.id);\n                                    }\n                                }\n                                else {\n                                    if (!that.linkers.includes(conn.id)) {\n                                        that.linkers.push(conn.id);\n                                    }\n                                }\n                                if (!that.conceptIds.includes(conn.toTheConceptId)) {\n                                    that.conceptIds.push(conn.toTheConceptId);\n                                }\n                                if (!that.compositionIds.includes(conn.ofTheConceptId)) {\n                                    that.compositionIds.push(conn.ofTheConceptId);\n                                }\n                            });\n                        }\n                        that.isUpdating = false;\n                        yield that.bind();\n                        that.notify();\n                    });\n                }, 200);\n            }\n            else {\n                console.log(\"rejected this\");\n            }\n        });\n    }\n    /**\n * This is the of the concept id that needs to be listened . If this is called. All the connections that are\n * created with of the concepts id with this passed id then the event is fired.\n *\n * @param id Of the concept id that needs to be listened.\n */\n    listenToEventConnectionType(id, connectionType) {\n        window.addEventListener(`${id}`, (event) => {\n            if (!this.isUpdating) {\n                this.isUpdating = true;\n                let that = this;\n                setTimeout(function () {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        let newConnection = yield ConnectionData.GetConnectionByOfTheConceptAndType(id, id);\n                        for (let i = 0; i < newConnection.length; i++) {\n                            if (newConnection.typeId == connectionType) {\n                                yield ConnectionData.GetConnection(newConnection[i]).then((conn) => {\n                                    if (conn.typeId == that.mainConcept) {\n                                        if (!that.internalConnections.includes(conn.id)) {\n                                            that.internalConnections.push(conn.id);\n                                        }\n                                    }\n                                    else {\n                                        if (!that.linkers.includes(conn.id)) {\n                                            that.linkers.push(conn.id);\n                                        }\n                                    }\n                                    if (!that.conceptIds.includes(conn.toTheConceptId)) {\n                                        that.conceptIds.push(conn.toTheConceptId);\n                                    }\n                                    if (!that.compositionIds.includes(conn.ofTheConceptId)) {\n                                        that.compositionIds.push(conn.ofTheConceptId);\n                                    }\n                                });\n                            }\n                        }\n                        that.isUpdating = false;\n                        yield that.bind();\n                        that.notify();\n                    });\n                }, 200);\n            }\n            else {\n                console.log(\"rejected this\");\n            }\n        });\n    }\n    /**\n     * This function will bind the actual data to the widget or the function.\n     */\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(\"this is the old execute data\");\n        });\n    }\n    /**\n     *\n     * @param callback the function that needs to be called with the data.\n     * @returns returns the callback with this data as the state.\n     */\n    subscribe(callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.subscribers.push(callback);\n            console.log('again executing data');\n            yield this.bind();\n            return callback(this.data);\n        });\n    }\n    /**\n     *\n     * @param callback function that you need to remove from the subscribers list.\n     * @returns\n     */\n    unsubscribe(callback) {\n        this.subscribers.filter(fn => fn != callback);\n        return this.subscribers.length;\n    }\n    /**\n     * This function will call all the subscribers that are registered in this wrapper.\n     */\n    notify() {\n        console.log('notifiers', this.subscribers);\n        this.subscribers.map(subscriber => {\n            console.log('notify');\n            subscriber(this.data);\n        });\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAllConceptsByType } from \"../Api/GetAllConceptsByType\";\nimport { ConceptsData, DATAID, GetAllConnectionsOfCompositionBulk, GetConceptByCharacter, JUSTDATA, NORMAL } from \"../app\";\nimport { Logger } from \"../Middleware/logger.service\";\nimport { GetCompositionFromMemory, GetCompositionFromMemoryNormal, GetCompositionWithIdFromMemory } from \"../Services/GetComposition\";\nimport { DependencyObserver } from \"./DepenedencyObserver\";\n/**\n * This wrapper will wrap the listing function and then allow users to return the list.\n */\nexport class GetCompositionListObservable extends DependencyObserver {\n    constructor(compositionName, userId, inpage, page, format) {\n        super();\n        this.data = [];\n        this.startPage = 0;\n        this.compositionName = compositionName;\n        this.userId = userId;\n        this.inpage = inpage;\n        this.page = page;\n        this.format = format;\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isDataLoaded) {\n                console.log(\"again data loading mechanism\");\n                var concept = yield GetConceptByCharacter(this.compositionName);\n                if (concept) {\n                    yield GetAllConceptsByType(this.compositionName, this.userId);\n                    console.log(\"getting the user data\", concept.id, this.userId);\n                    let conceptList = yield ConceptsData.GetConceptsByTypeIdAndUser(concept.id, this.userId);\n                    console.log(\"this is the concept list\", conceptList);\n                    var startPage = this.inpage * (this.page - 1);\n                    for (var i = startPage; i < startPage + this.inpage; i++) {\n                        if (conceptList[i]) {\n                            this.compositionIds.push(conceptList[i].id);\n                        }\n                    }\n                }\n                yield GetAllConnectionsOfCompositionBulk(this.compositionIds);\n                this.isDataLoaded = true;\n                this.listenToEventType(concept.id);\n                for (let i = 0; i < this.compositionIds.length; i++) {\n                    console.log(\"list listen\", this.compositionIds[i]);\n                    this.listenToEvent(this.compositionIds[i]);\n                }\n            }\n            return yield this.build();\n        });\n    }\n    build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.data = [];\n            console.log(\"this is building the data list\");\n            if (this.format == JUSTDATA) {\n                for (let i = this.startPage; i < this.startPage + this.inpage; i++) {\n                    if (this.compositionIds[i]) {\n                        let compositionJson = yield GetCompositionFromMemory(this.compositionIds[i]);\n                        this.data.push(compositionJson);\n                    }\n                }\n            }\n            else if (this.format == DATAID) {\n                for (let i = this.startPage; i < this.startPage + this.inpage; i++) {\n                    if (this.compositionIds[i]) {\n                        let compositionJson = yield GetCompositionWithIdFromMemory(this.compositionIds[i]);\n                        this.data.push(compositionJson);\n                    }\n                }\n            }\n            else if (this.format == NORMAL) {\n                for (let i = this.startPage; i < this.startPage + this.inpage; i++) {\n                    if (this.compositionIds[i]) {\n                        let compositionJson = yield GetCompositionFromMemoryNormal(this.compositionIds[i]);\n                        this.data.push(compositionJson);\n                    }\n                }\n            }\n            else {\n                for (let i = this.startPage; i < this.startPage + this.inpage; i++) {\n                    if (this.compositionIds[i]) {\n                        let compositionJson = yield GetCompositionFromMemory(this.compositionIds[i]);\n                        this.data.push(compositionJson);\n                    }\n                }\n            }\n            return this.data;\n        });\n    }\n}\n/**\n * This function will give you the list of the concepts by composition name with a listener to any data change.\n */\nexport function GetCompositionListListener(compositionName, userId, inpage, page, format = JUSTDATA) {\n    let startTime = performance.now();\n    const compositionResult = new GetCompositionListObservable(compositionName, userId, inpage, page, format);\n    // Add Log\n    console.log(\"GetCompositionListListener...\");\n    Logger.logInfo(startTime, userId, \"read\", \"Unknown\", \"Unknown\", 200, compositionResult, \"GetCompositionListListener\", ['compositionName', 'userId', 'inpage', 'page', 'format'], \"UnknownUserAgent\", []);\n    return compositionResult;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData, DATAID, JUSTDATA, NORMAL } from \"../app\";\nimport { GetCompositionById, RecursiveFetchBuildLayer, RecursiveFetchBuildLayerDataId, RecursiveFetchBuildLayerNormal } from \"../Services/GetComposition\";\nimport { DependencyObserver } from \"./DepenedencyObserver\";\nexport class GetCompositionObservable extends DependencyObserver {\n    constructor(id, format = JUSTDATA) {\n        super();\n        this.id = id;\n        this.format = format;\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isDataLoaded) {\n                let conceptConnections = yield GetCompositionById(this.id);\n                this.mainConcept = this.id;\n                this.compositionIds = conceptConnections.compositionList;\n                let internalConnections = conceptConnections.connectionList;\n                for (let i = 0; i < internalConnections.length; i++) {\n                    this.internalConnections.push(internalConnections[i].id);\n                }\n                this.isDataLoaded = true;\n                this.listenToEvent(this.mainConcept);\n            }\n            return yield this.build();\n        });\n    }\n    build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let latestConnectionList = [];\n            let latestConnectionIds = this.internalConnections;\n            for (let i = 0; i < latestConnectionIds.length; i++) {\n                latestConnectionList.push(yield ConnectionData.GetConnection(latestConnectionIds[i]));\n            }\n            if (this.format == JUSTDATA) {\n                console.log(\"this is the data for the build layer\", latestConnectionList, this.mainConcept, this.internalConnections, this.compositionIds);\n                this.data = yield RecursiveFetchBuildLayer(this.mainConcept, latestConnectionList, this.compositionIds);\n            }\n            else if (this.format == DATAID) {\n                this.data = yield RecursiveFetchBuildLayerDataId(this.mainConcept, latestConnectionList, this.compositionIds);\n            }\n            else if (this.format == NORMAL) {\n                this.data = yield RecursiveFetchBuildLayerNormal(this.mainConcept, latestConnectionList, this.compositionIds);\n            }\n            else {\n                this.data = yield RecursiveFetchBuildLayer(this.mainConcept, latestConnectionList, this.compositionIds);\n            }\n            return this.data;\n        });\n    }\n}\n/**\n *\n * @param id Id of the composition\n * @returns composition of the id given in the json form.\n */\nexport function GetCompositionListener(id, format = JUSTDATA) {\n    return new GetCompositionObservable(id, format);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData, DATAID, GetConceptBulk, GetConceptByCharacter, SearchWithTypeAndLinkerApi } from \"../app\";\nimport { TokenStorage } from \"../DataStructures/Security/TokenStorage\";\nimport { formatDataArrayDataId, formatDataArrayNormal } from \"../Services/Search/SearchWithTypeAndLinker\";\nimport { DependencyObserver } from \"./DepenedencyObserver\";\nexport class GetLinkListObservable extends DependencyObserver {\n    constructor(searchStructure, searchQuery, token, format = DATAID) {\n        super();\n        this.searchQuery = [];\n        this.format = DATAID;\n        this.mainCompositionIds = [];\n        this.searchCharacter = \"\";\n        this.token = \"\";\n        this.searchStructure = searchStructure;\n        this.searchQuery = searchQuery;\n        this.searchQuery[0].type = searchStructure.composition;\n        this.searchCharacter = searchStructure.composition;\n        this.format = format;\n        this.token = TokenStorage.BearerAccessToken;\n    }\n    /**\n * This function will be called when there is a need to listen to a certain type of concept that will update\n *  the ui.\n * @param id this is the type id which needs to be tracked\n */\n    listenToEventType(id) {\n        window.addEventListener(`${id}`, (event) => {\n            if (!this.isUpdating) {\n                this.isUpdating = true;\n                let that = this;\n                setTimeout(function () {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        let myEvent = event;\n                        if (!that.mainCompositionIds.includes(myEvent === null || myEvent === void 0 ? void 0 : myEvent.detail)) {\n                            that.mainCompositionIds.unshift(myEvent === null || myEvent === void 0 ? void 0 : myEvent.detail);\n                            that.conceptIds.push(myEvent === null || myEvent === void 0 ? void 0 : myEvent.detail);\n                            that.listenToEvent(myEvent === null || myEvent === void 0 ? void 0 : myEvent.detail);\n                            ConnectionData.GetConnectionsOfConcept(myEvent === null || myEvent === void 0 ? void 0 : myEvent.detail).then((connectionList) => {\n                                for (let i = 0; i < connectionList.length; i++) {\n                                    that.linkers.push(connectionList[i].id);\n                                }\n                            });\n                        }\n                        that.isUpdating = false;\n                        yield that.bind();\n                        that.notify();\n                    });\n                }, 200);\n            }\n            else {\n                console.log(\"rejected this\");\n            }\n        });\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isDataLoaded) {\n                this.isDataLoaded = true;\n                var concept = yield GetConceptByCharacter(this.searchCharacter);\n                let result = yield SearchWithTypeAndLinkerApi(this.searchStructure, this.searchQuery, this.token);\n                this.conceptIds = result.compositionIds;\n                this.internalConnections = result.internalConnections;\n                this.linkers = result.linkers;\n                this.reverse = result.reverse;\n                this.mainCompositionIds = result.mainCompositionIds;\n                this.listenToEventType(concept.id);\n                for (let i = 0; i < this.mainCompositionIds.length; i++) {\n                    this.listenToEvent(this.mainCompositionIds[i]);\n                }\n            }\n            return yield this.build();\n        });\n    }\n    build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield GetConceptBulk(this.conceptIds);\n            if (this.format == DATAID) {\n                this.data = yield formatDataArrayDataId(this.linkers, this.conceptIds, this.internalConnections, this.mainCompositionIds, this.reverse);\n            }\n            else {\n                this.data = yield formatDataArrayNormal(this.linkers, this.conceptIds, this.internalConnections, this.mainCompositionIds, this.reverse);\n            }\n            return this.data;\n        });\n    }\n}\n/**\n *\n * @param id this is the id whose links need to be found\n * @param linker this is the type connection that is connected to the mainConcept(id)\n * @param inpage number of outputs that has to be displayed\n * @param page the page which needs to be displayed as per the inpage parameter\n * @param format the format in which the output should be displayed (NORMAL, DATAID,JUSTDATA,DATAIDDATE)\n */\nexport function GetLinkListListener(searchStructure, searchQuery, token, format = DATAID) {\n    return new GetLinkListObservable(searchStructure, searchQuery, token, format);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { GetAllConnectionsOfCompositionBulk, GetCompositionWithIdAndDateFromMemory, GetConceptByCharacterAndType, GetConnectionBulk, GetConnectionOfTheConcept, GetTheConcept } from \"../app\";\nimport { DATAIDDATE, JUSTDATA, NORMAL } from \"../Constants/FormatConstants\";\nimport { GetCompositionFromMemory, GetCompositionWithIdFromMemory } from \"../Services/GetComposition\";\nimport { DependencyObserver } from \"./DepenedencyObserver\";\n/**\n * This is a class that will give you the observable for the links from a certain concept.\n */\nexport class GetLinkObservable extends DependencyObserver {\n    /**\n     *\n     * @param id this is the id whose links need to be found\n     * @param linker this is the type connection that is connected to the mainConcept(id)\n     * @param inpage number of outputs that has to be displayed\n     * @param page the page which needs to be displayed as per the inpage parameter\n     * @param format the format in which the output should be displayed (NORMAL, DATAID,JUSTDATA,DATAIDDATE)\n     */\n    constructor(id, linker, inpage, page, format) {\n        super();\n        this.connections = [];\n        this.data = [];\n        this.mainConcept = id;\n        this.linker = linker;\n        this.inpage = inpage;\n        this.page = page;\n        this.format = format;\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            if (!this.isDataLoaded) {\n                let concept = yield GetTheConcept(this.mainConcept);\n                let linkString = ((_a = concept.type) === null || _a === void 0 ? void 0 : _a.characterValue) + \"_s\" + \"_\" + this.linker;\n                let relatedConceptString = yield GetConceptByCharacterAndType(linkString, 16);\n                let relatedConcept = relatedConceptString;\n                if (relatedConcept.id > 0) {\n                    let connectionsString = yield GetConnectionOfTheConcept(relatedConcept.id, concept.id, concept.userId, this.inpage, this.page);\n                    this.connections = connectionsString;\n                    var prefetch = [];\n                    for (var i = 0; i < this.connections.length; i++) {\n                        prefetch.push(this.connections[i].toTheConceptId);\n                        this.linkers.push(this.connections[i].id);\n                        this.listenToEvent(this.connections[i].toTheConceptId);\n                    }\n                    // await GetAllConnectionsOfCompositionBulk(prefetch);\n                    yield GetAllConnectionsOfCompositionBulk(prefetch);\n                }\n                this.isDataLoaded = true;\n                this.listenToEvent(this.mainConcept);\n            }\n            return yield this.build();\n        });\n    }\n    build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.data = [];\n            this.connections = yield GetConnectionBulk(this.linkers);\n            for (var i = 0; i < this.connections.length; i++) {\n                let toConceptId = this.connections[i].toTheConceptId;\n                let toConcept = yield GetTheConcept(toConceptId);\n                console.log(\"this is the format\", this.format);\n                if (this.format == NORMAL) {\n                    let newComposition = yield GetCompositionWithIdFromMemory(toConcept.id);\n                    this.data.push(newComposition);\n                }\n                else if (this.format == JUSTDATA) {\n                    let newComposition = yield GetCompositionFromMemory(toConcept.id);\n                    this.data.push(newComposition);\n                }\n                else if (this.format == DATAIDDATE) {\n                    let newComposition = yield GetCompositionWithIdAndDateFromMemory(toConcept.id);\n                    this.data.push(newComposition);\n                }\n                else {\n                    let newComposition = yield GetCompositionWithIdAndDateFromMemory(toConcept.id);\n                    this.data.push(newComposition);\n                }\n            }\n            return this.data;\n        });\n    }\n}\n// class GetLinkServiceObservable\n// {\n//     mainConcept: number\n//     linker:string;\n//     inpage: number;\n//     page: number;\n//     format: number = NORMAL;\n//     connections: Connection[] = [];\n//     data: any = [];\n//     subscribers: any[] = []\n//     /**\n//      * \n//      * @param id this is the id whose links need to be found\n//      * @param linker this is the type connection that is connected to the mainConcept(id)\n//      * @param inpage number of outputs that has to be displayed\n//      * @param page the page which needs to be displayed as per the inpage parameter\n//      * @param format the format in which the output should be displayed (NORMAL, DATAID,JUSTDATA,DATAIDDATE)\n//      */\n//     constructor(id: number, linker:string, inpage: number, page: number, format: number){\n//         this.mainConcept = id;\n//         this.linker = linker;\n//         this.inpage = inpage;\n//         this.page = page;\n//         this.format = format;\n//     }\n//     async subscribe(callback: Function) {\n//         this.subscribers.push(callback);\n//         const listenerId = Date.now() + '-' + Math.floor(Math.random() * 99999999)\n//         const listener = {\n//             listenerId: listenerId,\n//             callback: callback,\n//             createdAt: Date.now()\n//         }\n//         subscribedListeners.push(listener)\n//         console.log('listener', serviceWorker)\n//         // const res: any = await sendMessage('GetLinkListener', {id: this.mainConcept, linker: this.linker, inpage: this.inpage, page: this.page, format: this.format, listener })\n//         const res: any = await sendMessage('GetLinkListener', {id: this.mainConcept, linker: this.linker, inpage: this.inpage, page: this.page, format: this.format, listener: {\n//             listenerId: listenerId,\n//             createdAt: Date.now()\n//         } })\n//         return callback(res.data);\n//     }\n// }\n/**\n *\n * @param id this is the id whose links need to be found\n * @param linker this is the type connection that is connected to the mainConcept(id)\n * @param inpage number of outputs that has to be displayed\n * @param page the page which needs to be displayed as per the inpage parameter\n * @param format the format in which the output should be displayed (NORMAL, DATAID,JUSTDATA,DATAIDDATE)\n */\nexport function GetLinkListener(id, linker, inpage, page, format = NORMAL) {\n    return new GetLinkObservable(id, linker, inpage, page, format);\n    // console.log(\"serviceworker\", serviceWorker);\n    // if (serviceWorker) {\n    //   return new GetLinkServiceObservable(id, linker, inpage, page, format);\n    // } else return new GetLinkObservable(id, linker, inpage, page, format);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ConnectionData, DependencyObserver, GetCompositionFromConnectionsWithDataId, GetConnectionBulk, RecursiveSearchApiRaw, } from \"../app\";\nimport { RAW } from \"../Constants/FormatConstants\";\nclass RecursiveSearchObservable extends DependencyObserver {\n    /**\n     *\n     * @param id this is the id whose links need to be found\n     * @param linker this is the type connection that is connected to the mainConcept(id)\n     * @param inpage number of outputs that has to be displayed\n     * @param page the page which needs to be displayed as per the inpage parameter\n     * @param format the format in which the output should be displayed (RAW, undefined)\n     */\n    constructor(id, linkers, textSearch = \"\", format) {\n        super();\n        this.searchText = \"\";\n        this.connections = [];\n        this.externalConnectionIds = [];\n        this.data = [];\n        this.mainConcept = id;\n        this.searchLinkers = linkers;\n        this.textSearch = textSearch;\n        if (format)\n            this.format = format;\n    }\n    /**\n     * This is the of the concept id that needs to be listened . If this is called. All the connections that are\n     * created with of the concepts id with this passed id then the event is fired.\n     *\n     * @param id Of the concept id that needs to be listened.\n     */\n    listenToEvent(id) {\n        window.addEventListener(`${id}`, (event) => {\n            // console.log(\"this is listening after the event is fired\", id, event);\n            if (!this.isUpdating) {\n                this.isUpdating = true;\n                let that = this;\n                setTimeout(function () {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        let newConnection = yield ConnectionData.GetConnectionByOfTheConceptAndType(id, id);\n                        for (let i = 0; i < newConnection.length; i++) {\n                            yield ConnectionData.GetConnection(newConnection[i]).then((conn) => {\n                                if (conn.typeId == that.mainConcept) {\n                                    if (!that.internalConnections.includes(conn.id)) {\n                                        that.internalConnections.push(conn.id);\n                                    }\n                                }\n                                else {\n                                    if (!that.linkers.includes(conn.id)) {\n                                        that.linkers.push(conn.id);\n                                    }\n                                }\n                                if (!that.conceptIds.includes(conn.toTheConceptId)) {\n                                    that.conceptIds.push(conn.toTheConceptId);\n                                }\n                                // compositions\n                                if (!that.compositionIds.includes(conn.ofTheConceptId)) {\n                                    that.compositionIds.push(conn.ofTheConceptId);\n                                }\n                                if (!that.compositionIds.includes(conn.toTheConceptId)) {\n                                    that.compositionIds.push(conn.toTheConceptId);\n                                }\n                            });\n                        }\n                        that.isUpdating = false;\n                        yield that.bind();\n                        that.notify();\n                    });\n                }, 200);\n            }\n            else {\n                console.log(\"rejected this\");\n            }\n        });\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isDataLoaded) {\n                this.isDataLoaded = true;\n                const result = yield RecursiveSearchApiRaw(this.mainConcept, this.searchLinkers, this.textSearch);\n                this.compositionIds = result.compositionIds || [];\n                this.internalConnections = result.internalConnections || [];\n                this.externalConnectionIds = result.externalConnections || [];\n                this.linkers = this.externalConnectionIds;\n                // const internalConnections = await GetConnectionBulk(\n                //   this.internalConnections\n                // );\n                this.connections = yield GetConnectionBulk(this.externalConnectionIds);\n                var prefetch = [];\n                // listen external connection\n                // for (var i = 0; i < this.connections.length; i++) {\n                //   prefetch.push(this.connections[i].toTheConceptId);\n                //    this.listenToEvent(this.connections[i].toTheConceptId);\n                // }\n                // listen internal connection\n                // for (var i = 0; i < this.internalConnections.length; i++) {\n                //   //prefetch.push(internalConnections[i].toTheConceptId);\n                //    this.listenToEvent(this.internalConnections[i]);\n                // }\n                for (let i = 0; i < this.compositionIds.length; i++) {\n                    this.listenToEvent(this.compositionIds[i]);\n                }\n                //await GetAllConnectionsOfCompositionBulk(prefetch);\n                this.listenToEvent(this.mainConcept);\n            }\n            return yield this.build();\n        });\n    }\n    build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.externalConnectionIds = this.linkers;\n            if (this.format && this.format == RAW) {\n                this.data = {\n                    compositionIds: this.compositionIds,\n                    internalConnections: this.internalConnections,\n                    externalConnections: this.externalConnectionIds,\n                };\n            }\n            else {\n                this.data = yield GetCompositionFromConnectionsWithDataId(this.compositionIds, this.internalConnections);\n            }\n            return this.data;\n        });\n    }\n}\n/**\n * Method to listen the changes in recursive search data\n * @param id this is the id whose links need to be found\n * @param linker this is the type connection that is connected to the mainConcept(id)\n * @param inpage number of outputs that has to be displayed\n * @param page the page which needs to be displayed as per the inpage parameter\n * @param format the format in which the output should be displayed (RAW, undefined)\n */\nexport function RecursiveSearchListener(id, linkers, searchText = \"\", format) {\n    return new RecursiveSearchObservable(id, linkers, searchText, format);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FreeschemaQuery, FreeschemaQueryApi } from \"../app\";\nimport { ALLID, DATAID, JUSTDATA } from \"../Constants/FormatConstants\";\nimport { formatConnections, formatConnectionsDataId, formatConnectionsJustId } from \"../Services/Search/SearchWithTypeAndLinker\";\nimport { DependencyObserver } from \"./DepenedencyObserver\";\nexport class SearchLinkMultipleAllObservable extends DependencyObserver {\n    constructor(query, token) {\n        super();\n        this.mainCompositionIds = [];\n        this.query = new FreeschemaQuery();\n        this.query = query;\n        this.format = query.outputFormat;\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isDataLoaded) {\n                this.isDataLoaded = true;\n                this.query.outputFormat = ALLID;\n                let result = yield FreeschemaQueryApi(this.query, \"\");\n                this.conceptIds = result.conceptIds;\n                this.internalConnections = result.internalConnections;\n                this.linkers = result.linkers;\n                this.reverse = result.reverse;\n                this.mainCompositionIds = result.mainCompositionIds;\n            }\n            return yield this.build();\n        });\n    }\n    build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.format == DATAID) {\n                this.data = yield formatConnectionsDataId(this.linkers, this.conceptIds, this.mainCompositionIds, this.reverse);\n            }\n            else if (this.format == JUSTDATA) {\n                this.data = yield formatConnectionsJustId(this.linkers, this.conceptIds, this.mainCompositionIds, this.reverse);\n            }\n            else {\n                this.data = yield formatConnections(this.linkers, this.conceptIds, this.mainCompositionIds, this.reverse);\n                //this.data = await formatDataArrayNormal(this.linkers, this.conceptIds, this.internalConnections,  this.mainCompositionIds, this.reverse );\n            }\n            return this.data;\n        });\n    }\n}\n/**\n *\n * @param id this is the id whose links need to be found\n * @param linker this is the type connection that is connected to the mainConcept(id)\n * @param inpage number of outputs that has to be displayed\n * @param page the page which needs to be displayed as per the inpage parameter\n * @param format the format in which the output should be displayed (NORMAL, DATAID,JUSTDATA,DATAIDDATE)\n */\nexport function SchemaQueryListener(query, token) {\n    return new SearchLinkMultipleAllObservable(query, token);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SearchLinkMultipleAll } from \"../app\";\nimport { DATAID } from \"../Constants/FormatConstants\";\nimport { DependencyObserver } from \"./DepenedencyObserver\";\nexport class SearchLinkMultipleAllObservable extends DependencyObserver {\n    constructor(searchQuery, token, format = DATAID) {\n        super();\n        this.searchQuery = [];\n        this.format = DATAID;\n        this.searchQuery = searchQuery;\n        this.format = format;\n    }\n    bind() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.data = yield SearchLinkMultipleAll(this.searchQuery, \"\", this, this.format);\n            this.mainConcept = this.searchQuery[0].composition;\n            this.listenToEvent(this.mainConcept);\n            console.log(\"this is the data\", this.data);\n            return this.data;\n        });\n    }\n}\n/**\n *\n * @param searchQueries Queries that need to be executed.\n * @param token token of the user.\n * @returns  returns the json format of the output.\n */\nexport function searchLinkMultipleListener(searchQueries, token, format = DATAID) {\n    return new SearchLinkMultipleAllObservable(searchQueries, token !== null && token !== void 0 ? token : \"\", format);\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport { init, updateAccessToken };\nimport CreateConceptBinaryTreeFromIndexDb from \"./Services/CreateBinaryTreeFromData\";\nimport { IdentifierFlags } from './DataStructures/IdentifierFlags';\nexport { SearchLinkMultipleApi } from './Api/Search/SearchLinkMultipleApi';\nexport { SplitStrings } from './Services/SplitStrings';\nexport { GetCompositionList, GetCompositionListWithId } from './Services/GetCompositionList';\nexport { GetCompositionListLocal, GetCompositionListLocalWithId } from './Services/Local/GetCompositionListLocal';\nexport { GetAllConnectionsOfComposition } from './Api/GetAllConnectionsOfComposition';\nexport { GetComposition, GetCompositionWithId, recursiveFetch, GetCompositionWithAllIds } from './Services/GetComposition';\nexport { GetCompositionLocal, GetCompositionLocalWithId } from './Services/Local/GetCompositionLocal';\nexport { default as CreateComposition } from './Services/CreateTheComposition';\nexport { CreateTheCompositionLocal } from './Services/Local/CreateTheCompositionLocal';\nexport { CreateConnectionBetweenTwoConcepts, CreateConnectionBetweenTwoConceptsGeneral } from './Services/CreateConnectionBetweenTwoConcepts';\nexport { default as GetTheConcept } from './Services/GetTheConcept';\nexport { default as MakeTheInstanceConcept } from './Services/MakeTheInstanceConcept';\nexport { MakeTheInstanceConceptLocal } from './Services/Local/MakeTheInstanceConceptLocal';\nexport { storeToDatabase, getFromDatabaseWithType, getObjectsFromIndexDb } from './Database/NoIndexDb';\nexport { createTheConnection as CreateTheConnection } from './Services/CreateTheConnection';\nexport { default as GetConceptByCharacter } from './Services/GetConceptByCharacter';\nexport { GetLink, GetLinkRaw } from './Services/GetLink';\nexport { CreateDefaultConcept } from './Services/CreateDefaultConcept';\nexport { MakeTheTypeConceptLocal } from './Services/Local/MakeTheTypeLocal';\nexport { MakeTheTypeConcept } from './Services/MakeTheTypeConcept';\nexport { MakeTheTypeConceptApi } from './Api/MakeTheTypeConceptApi';\nexport { GetLinkerConnectionFromConcepts, GetLinkerConnectionToConcepts } from './Services/GetLinkerConnectionFromConcept';\nexport { DeleteConceptById } from './Services/DeleteConcept';\nexport { DeleteConnectionById } from './Services/DeleteConnection';\nexport { TrashTheConcept } from './Api/Delete/DeleteConceptInBackend';\nexport { GetConnectionById } from './Services/GetConnections';\nexport { MakeTheTimestamp } from './Services/MakeTheTimestamp';\nexport { RecursiveSearchApi, RecursiveSearchApiWithInternalConnections, RecursiveSearchApiRaw, RecursiveSearchApiRawFullLinker, RecursiveSearchApiNewRawFullLinker } from './Api/RecursiveSearch';\nexport { GetCompositionBulkWithDataId, GetCompositionFromConnectionsWithDataIdFromConnections, GetCompositionFromConnectionsWithIndexFromConnections, GetCompositionBulk, GetCompositionFromConnectionsWithDataId } from './Services/GetCompositionBulk';\nexport { GetConceptBulk } from './Api/GetConceptBulk';\nexport { GetConnectionBulk } from './Api/GetConnectionBulk';\nexport { GetAllConnectionsOfCompositionBulk } from './Api/GetAllConnectionsOfCompositionBulk';\nexport { LoginToBackend } from './Api/Login';\nexport { GetConnectionOfTheConcept } from './Api/GetConnectionOfTheConcept';\nexport { default as Signup } from './Api/Signup';\nexport { default as Signin } from './Api/Signin';\nexport { SignupEntity } from './Api/Signup';\nexport { default as UpdateComposition } from './Services/UpdateComposition';\nexport { SearchAllConcepts } from './Api/Search/Search';\nexport { SearchWithLinker } from './Api/Search/SearchWithLinker';\nexport { GetCompositionWithCache, GetCompositionWithDataIdWithCache, GetCompositionWithDataIdBulk } from './Services/Composition/CompositionCache';\nexport { CreateSession } from './Api/Session/CreateSession';\nexport { CreateSessionVisit } from './Api/Session/CreateSessionVisit';\nexport { GetRelation, GetRelationRaw } from './Services/GetRelation';\nexport { recursiveFetchNew } from './Services/Composition/BuildComposition';\nexport { CreateTheCompositionWithCache } from './Services/Composition/CreateCompositionCache';\nexport { CreateDefaultLConcept } from './Services/Local/CreateDefaultLConcept';\nexport { CreateTheConnectionGeneral } from './Services/CreateTheConnectionGeneral';\nexport { CreateTheConnectionLocal } from './Services/Local/CreateTheConnectionLocal';\nexport { GetCompositionListAll, GetCompositionListAllWithId, GetCompositionListWithIdUpdated } from './Services/GetCompositionList';\nexport { GetUserGhostId, AddGhostConcept } from './Services/User/UserTranslation';\nexport { SearchLinkMultipleAll, FormatFromConnections } from './Services/Search/SearchLinkMultiple';\nexport { GetTheConceptLocal } from './Services/Local/GetTheConceptLocal';\nexport { UpdateCompositionLocal } from './Services/Local/UpdateCompositionLocal';\nexport { GetCompositionFromConnectionsWithDataIdInObject, GetCompositionFromConnectionsWithIndex, GetCompositionFromConnectionsWithDataIdIndex } from './Services/GetCompositionBulk';\nexport { GetRelationLocal } from './Services/Local/GetRelationLocal';\nexport { GetConceptByCharacterAndCategoryLocal } from './Services/Local/GetConceptByCharacterLocal';\nexport { ViewInternalData } from './Services/View/ViewInternalData';\nexport { ViewInternalDataApi } from './Api/View/ViewInternalDataApi';\nexport { convertFromLConceptToConcept, convertFromConceptToLConcept } from './Services/Conversion/ConvertConcepts';\nexport { SearchLinkInternal, SearchLinkInternalAll } from './Services/Search/SearchLinkInternal';\nexport { CreateConnectionBetweenTwoConceptsLocal } from './Services/Local/CreateConnectionBetweenTwoConceptsLocal';\nexport { DeleteConceptLocal } from './Services/Local/DeleteConceptLocal';\nexport { GetConnectionBetweenTwoConceptsLinker } from './Services/GetConnectionBetweenTwoConceptsLinker';\nexport { DelayFunctionExecution } from './Services/Common/DelayFunction';\nexport { GetCompositionWithIdAndDateFromMemory, GetCompositionFromMemoryWithConnections } from './Services/GetComposition';\nexport { GetConceptByCharacterAndType } from './Api/GetConceptByCharacterAndType';\nexport { GetConnectionDataPrefetch } from './Services/GetCompositionBulk';\nexport { FormatFromConnectionsAltered } from './Services/Search/SearchLinkMultiple';\nexport { NORMAL, JUSTDATA, DATAID, DATAIDDATE, RAW, ALLID, LISTNORMAL } from './Constants/FormatConstants';\nexport { PRIVATE, PUBLIC, ADMIN } from './Constants/AccessConstants';\nexport { SearchWithTypeAndLinkerApi } from './Api/Search/SearchWithTypeAndLinker';\nexport { DependencyObserver } from './WrapperFunctions/DepenedencyObserver';\nexport { SearchLinkMultipleAllObservable, searchLinkMultipleListener } from './WrapperFunctions/SearchLinkMultipleAllObservable';\nexport { GetCompositionListener } from './WrapperFunctions/GetCompositionObservable';\nexport { GetCompositionListListener } from './WrapperFunctions/GetCompositionListObservable';\nexport { SearchWithTypeAndLinker } from './Services/Search/SearchWithTypeAndLinker';\nexport { GetLinkListener } from './WrapperFunctions/GetLinkObservable';\nexport { RecursiveSearchListener } from './WrapperFunctions/RecursiveSearchObservable';\nexport { GetLinkListListener } from './WrapperFunctions/GetLinkListObservable';\nexport { SyncData } from './DataStructures/SyncData';\nexport { Concept } from './DataStructures/Concept';\nexport { LConcept } from './DataStructures/Local/LConcept';\nexport { LConnection } from './DataStructures/Local/LConnection';\nexport { Connection } from './DataStructures/Connection';\nexport { ConceptsData } from './DataStructures/ConceptData';\nexport { ConnectionData } from './DataStructures/ConnectionData';\nexport { BinaryTree } from './DataStructures/BinaryTree';\nexport { SearchQuery } from './DataStructures/SearchQuery';\nexport { PatcherStructure } from './DataStructures/PatcherStructure';\nexport { SessionData } from './DataStructures/Session/SessionData';\nexport { Composition } from './DataStructures/Composition/Composition';\nexport { CompositionBinaryTree } from './DataStructures/Composition/CompositionBinaryTree';\nexport { CompositionNode } from './DataStructures/Composition/CompositionNode';\nexport { LocalSyncData } from './DataStructures/Local/LocalSyncData';\nexport { UserBinaryTree } from './DataStructures/User/UserBinaryTree';\nexport { FilterSearch } from './DataStructures/FilterSearch';\nexport { SearchStructure } from './DataStructures/Search/SearchStructure';\nexport { LocalConceptsData } from './DataStructures/Local/LocalConceptData';\nimport { GetConnectionsFromIndexDb, GetConnectionsFromIndexDbLocal } from './Services/GetDataFromIndexDb';\nimport CreateLocalBinaryTreeFromIndexDb, { PopulateTheLocalConnectionToMemory } from './Services/Local/CreateLocalBinaryTreeFromData';\nimport InitializeSystem from './Services/InitializeSystem';\nimport { BaseUrl } from './DataStructures/BaseUrl';\nimport { TokenStorage } from './DataStructures/Security/TokenStorage';\nimport { broadcastChannel } from \"./Constants/general.const\";\nexport { Logger } from \"./Middleware/logger.service\";\nimport { HandleHttpError, HandleInternalError } from \"./Services/Common/ErrorPosting\";\nimport { EventLogger } from \"./Middleware/EventLogger\";\nexport { BuilderStatefulWidget } from \"./Widgets/BuilderStatefulWidget\";\nexport { LocalTransaction } from \"./Services/Transaction/LocalTransaction\";\nexport { Anomaly } from './Anomaly/anomaly';\nexport { Validator } from './Validator/validator';\nexport { createFormFieldData } from './Validator/utils';\nexport { BaseUrl } from './DataStructures/BaseUrl';\nexport { StatefulWidget } from './Widgets/StatefulWidget';\nexport { DeleteConnectionByType, GetAllTheConnectionsByTypeAndOfTheConcept } from './Services/DeleteConnectionByType';\nexport { FreeschemaQuery } from './DataStructures/Search/FreeschemaQuery';\nexport { FreeschemaQueryApi } from './Api/Search/FreeschemaQueryApi';\nexport { SchemaQueryListener } from './WrapperFunctions/SchemaQueryObservable';\nexport { WidgetTree } from './Widgets/WidgetTree';\nexport { DeleteUser } from './Services/DeleteConcept';\nexport { AccessTracker } from './AccessTracker/accessTracker';\nexport var serviceWorker;\nconst TABID = Date.now().toString(36) + Math.random().toString(36).substring(2);\nexport let subscribedListeners = [];\nlet serviceWorkerReady = false;\nlet messageQueue = [];\n/**\n * This function lets you update the access token that the package uses. If this is not passed you cannot create, update, view or delete\n * Your concepts using this package.\n * @param accessToken access token got from the sign in process\n */\nfunction updateAccessToken(accessToken = \"\") {\n    TokenStorage.BearerAccessToken = accessToken;\n    if (serviceWorker)\n        sendMessage('updateAccessToken', { accessToken });\n}\n/**\n *\n * @param url This is the url for the backend c# system or our main data fabric server\n * @param aiurl This is the AI url that pulls in the data using our AI system . If you do not enter this then also disable the enableAi flag.\n * @param accessToken This is the JWT token that needs to be passed (But since you have just initilized the system). There is no way we can get access token\n * So this access token can be empty string. You can set it afterwards with another function UpdateAccessToken();\n * @param nodeUrl This is the url for the node server. This is another server in the data fabric that is used as server for business logic and security features.\n * @param enableAi This flag is used to enable or disable the AI feature that preloads data in the indexdb.\n * @param applicationName This is an unique name that is given to a program. Use this to discern one indexdb from another.\n * @param enableSW {activate: boolean, scope?: string, pathToSW?: string, manual?: boolean} | undefined - This is for enabling service worker with its scope\n */\nfunction init() {\n    return __awaiter(this, arguments, void 0, function* (url = \"\", aiurl = \"\", accessToken = \"\", nodeUrl = \"\", enableAi = true, applicationName = \"\", enableSW = undefined, isTest = false) {\n        try {\n            BaseUrl.BASE_URL = url;\n            BaseUrl.AI_URL = aiurl;\n            BaseUrl.NODE_URL = nodeUrl;\n            BaseUrl.BASE_APPLICATION = applicationName;\n            TokenStorage.BearerAccessToken = accessToken;\n            let randomizer = Math.floor(Math.random() * 100000000);\n            // BaseUrl.BASE_RANDOMIZER = randomizer;\n            // BaseUrl.BASE_RANDOMIZER = 999;\n            BaseUrl.setRandomizer(randomizer);\n            if (isTest) {\n                IdentifierFlags.isDataLoaded = true;\n                IdentifierFlags.isCharacterLoaded = true;\n                IdentifierFlags.isTypeLoaded = true;\n                IdentifierFlags.isLocalDataLoaded = true;\n                IdentifierFlags.isLocalTypeLoaded = true;\n                IdentifierFlags.isLocalCharacterLoaded = true;\n                IdentifierFlags.isConnectionLoaded = true;\n                IdentifierFlags.isConnectionTypeLoaded = true;\n                IdentifierFlags.isLocalConnectionLoaded = true;\n                EventLogger.initialize();\n                return true;\n            }\n            if (!(\"serviceWorker\" in navigator)) {\n                yield initConceptConnection();\n                console.warn(\"Service Worker not supported in this browser.\");\n                return;\n            }\n            listenBroadCastMessages();\n            if (enableSW && enableSW.activate && enableSW.manual) {\n                yield new Promise((resolve, reject) => {\n                    navigator.serviceWorker.ready\n                        .then((registration) => __awaiter(this, void 0, void 0, function* () {\n                        console.log('registraions ready', registration);\n                        serviceWorker = registration.active;\n                        yield sendMessage(\"init\", {\n                            url,\n                            aiurl,\n                            accessToken,\n                            nodeUrl,\n                            enableAi,\n                            applicationName,\n                            isTest,\n                        });\n                        resolve('done');\n                    }))\n                        .catch(err => {\n                        console.error(\"Error: Ready service worker\", err);\n                        reject(err);\n                    })\n                        .finally(() => console.log('Finally service worker ready done'));\n                    setTimeout(() => reject('Timeout ready'), 30000);\n                });\n            }\n            else if (enableSW &&\n                (enableSW === null || enableSW === void 0 ? void 0 : enableSW.activate)) {\n                try {\n                    console.log(\"service worker initialiing\");\n                    // navigator.serviceWorker\n                    //   .getRegistrations()\n                    //   .then(async (registrations) => {\n                    //     console.log(\"Service Workers registered:\", registrations);\n                    //     if (registrations.length > 0) {\n                    //       // TODO:: check if the domain has our own service worker or others\n                    //       registrations.forEach((registration, index) => {\n                    //         console.log(`Service Worker ${index + 1}:`, registration);\n                    //         if (registration.installing) {\n                    //           console.log(\"Status: Installing\");\n                    //         } else if (registration.waiting) {\n                    //           console.log(\"Status: Waiting\");\n                    //         } else if (registration.active) {\n                    //           console.log(\"Status: Active\");\n                    //           serviceWorker = registration.active;\n                    //           // sendMessage('init', {})\n                    //         } else {\n                    //           console.log(\"Status: No active worker\", registration);\n                    //         }\n                    //       });\n                    //     } else {\n                    // let serviceWorkerPath = enableSW.path ? enableSW.path : './serviceWorker.bundle.js'\n                    // if (enableSW.path && enableSW.path.slice(-1) == '/') serviceWorkerPath = enableSW.path + 'serviceWorker.bundle.js'\n                    // else if (enableSW.path && enableSW.path.length > 2 && !enableSW.path.includes('serviceWorker.bundle.js')) serviceWorkerPath = enableSW.path + './serviceWorker.bundle.js'\n                    yield new Promise((resolve, reject) => {\n                        var _a, _b;\n                        let success = false;\n                        navigator.serviceWorker\n                            .register((_a = enableSW.pathToSW) !== null && _a !== void 0 ? _a : \"./serviceWorker.bundle.js\", {\n                            // type: \"module\",\n                            scope: (_b = enableSW.scope) !== null && _b !== void 0 ? _b : \"/\",\n                        })\n                            .then((registration) => __awaiter(this, void 0, void 0, function* () {\n                            console.log(\"Service Worker registered:\", registration);\n                            // If the service worker is already active, mark it as ready\n                            if (registration.active) {\n                                serviceWorkerReady = true;\n                                console.log(\"active sw\");\n                                serviceWorker = registration.active;\n                                yield sendMessage(\"init\", {\n                                    url,\n                                    aiurl,\n                                    accessToken,\n                                    nodeUrl,\n                                    enableAi,\n                                    applicationName,\n                                    isTest,\n                                });\n                                processMessageQueue();\n                                resolve();\n                            }\n                            else {\n                                // Handle if on state change didn't trigger\n                                setTimeout(() => {\n                                    if (!success)\n                                        reject(\"Not Completed Initialization\");\n                                }, 5000);\n                            }\n                            // state change \n                            if (registration.installing || registration.waiting || registration.active) {\n                                registration.addEventListener('statechange', (event) => __awaiter(this, void 0, void 0, function* () {\n                                    var _a;\n                                    if (((_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.state) === 'activating') {\n                                        serviceWorker = navigator.serviceWorker.controller;\n                                        console.log('Service Worker is activating statechange');\n                                        yield sendMessage(\"init\", {\n                                            url,\n                                            aiurl,\n                                            accessToken,\n                                            nodeUrl,\n                                            enableAi,\n                                            applicationName,\n                                            isTest,\n                                        });\n                                    }\n                                }));\n                            }\n                            // Listen for updates to the service worker\n                            console.log(\"update listen start\");\n                            registration.onupdatefound = () => {\n                                const newWorker = registration.installing;\n                                console.log(\"new worker\", newWorker);\n                                if (newWorker) {\n                                    newWorker.onstatechange = () => __awaiter(this, void 0, void 0, function* () {\n                                        console.log(\"on state change triggered\", (newWorker.state === \"installed\" || newWorker.state === \"activated\" || newWorker.state === 'redundant'), navigator.serviceWorker.controller);\n                                        // if (newWorker.state === 'activated' && navigator.serviceWorker.controller) {\n                                        if ((newWorker.state === \"installed\" || newWorker.state === \"activated\" || newWorker.state === 'redundant') && navigator.serviceWorker.controller) {\n                                            // && navigator.serviceWorker.controller) {\n                                            console.log(\"New Service Worker is active\", registration);\n                                            serviceWorker = newWorker;\n                                            // serviceWorker = registration.active;\n                                            // Send init message now that it's active\n                                            yield sendMessage(\"init\", {\n                                                url,\n                                                aiurl,\n                                                accessToken,\n                                                nodeUrl,\n                                                enableAi,\n                                                applicationName,\n                                                isTest,\n                                            });\n                                            success = true;\n                                            serviceWorkerReady = true;\n                                            processMessageQueue();\n                                            resolve();\n                                        }\n                                    });\n                                }\n                            };\n                            // Listen for the activation of the new service worker\n                            registration.addEventListener('controllerchange', () => __awaiter(this, void 0, void 0, function* () {\n                                console.warn('controller change triggered', navigator.serviceWorker.controller);\n                                if (navigator.serviceWorker.controller) {\n                                    serviceWorker = navigator.serviceWorker.controller;\n                                    console.log('Service worker has been activated');\n                                    yield sendMessage(\"init\", {\n                                        url,\n                                        aiurl,\n                                        accessToken,\n                                        nodeUrl,\n                                        enableAi,\n                                        applicationName,\n                                        isTest,\n                                    });\n                                    // The new service worker is now controlling the page\n                                    // You can reload the page if necessary or handle the update process here\n                                }\n                            }));\n                        }))\n                            .catch((error) => __awaiter(this, void 0, void 0, function* () {\n                            yield initConceptConnection();\n                            reject(error);\n                            console.error(\"Service Worker registration failed:\", error);\n                        }));\n                    });\n                    //   }\n                    // })\n                    // .catch((err) => {\n                    //   console.log(\"Unable to register\", err);\n                    // });\n                }\n                catch (error) {\n                    yield initConceptConnection();\n                    console.error(\"Unable to start service worker\", error);\n                }\n            }\n            else {\n                yield initConceptConnection();\n                console.warn('Service Worker not activated');\n            }\n            return true;\n        }\n        catch (error) {\n            yield initConceptConnection();\n            console.warn(\"Cannot initialize the system\", error);\n        }\n    });\n}\n/**\n * Method to send message to the service worker from main thread\n * @param type string\n * @param payload any\n * @returns Promise<any>\n */\nexport function sendMessage(type, payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const messageId = Math.random().toString(36).substring(2); // Generate a unique message ID\n        payload.messageId = messageId;\n        payload.TABID = TABID;\n        // let actions = payload.actions\n        const newPayload = JSON.parse(JSON.stringify(payload));\n        return new Promise((resolve, reject) => {\n            // navigator.serviceWorker.ready\n            //   .then((registration) => {\n            if ((navigator.serviceWorker.controller || serviceWorker) && (serviceWorkerReady || type == 'init')) {\n                const responseHandler = (event) => {\n                    var _a, _b, _c, _d, _e, _f;\n                    if (((_a = event === null || event === void 0 ? void 0 : event.data) === null || _a === void 0 ? void 0 : _a.messageId) == messageId) { // Check if the message ID matches\n                        if (!event.data.success) {\n                            if (((_b = event === null || event === void 0 ? void 0 : event.data) === null || _b === void 0 ? void 0 : _b.status) == 401) {\n                                reject(HandleHttpError(new Response('Unauthorized', { status: 401, statusText: (_c = event === null || event === void 0 ? void 0 : event.data) === null || _c === void 0 ? void 0 : _c.statusText })));\n                            }\n                            else if (((_d = event === null || event === void 0 ? void 0 : event.data) === null || _d === void 0 ? void 0 : _d.status) == 500) {\n                                reject(HandleInternalError(new Response('Unauthorized', { status: 401, statusText: (_e = event === null || event === void 0 ? void 0 : event.data) === null || _e === void 0 ? void 0 : _e.statusText })));\n                            }\n                            else {\n                                reject(`Failed to handle action ${type} ${JSON.stringify(payload)}`);\n                            }\n                        }\n                        if ((_f = event.data) === null || _f === void 0 ? void 0 : _f.actions) {\n                            payload.actions = JSON.parse(JSON.stringify(event.data.actions));\n                        }\n                        resolve(event.data);\n                        navigator.serviceWorker.removeEventListener(\"message\", responseHandler);\n                    }\n                };\n                navigator.serviceWorker.addEventListener(\"message\", responseHandler);\n                // console.log(\"before sending message\", type, 'new', newPayload);\n                // serviceWorker?.postMessage({ type, payload });\n                // Send the message to the service worker\n                if (serviceWorker) {\n                    try {\n                        serviceWorker.postMessage({ type, payload: newPayload });\n                    }\n                    catch (err) {\n                        console.log(err);\n                        // serviceWorker.postMessage({ type, payload: newPayload });\n                        serviceWorker.postMessage({ type, payload: newPayload });\n                    }\n                    // navigator.serviceWorker.controller.postMessage({ type, payload });\n                }\n                else {\n                    // wait one second before checking again\n                    setTimeout(() => {\n                        // if (navigator.serviceWorker.controller) {\n                        if (serviceWorker) {\n                            // serviceWorker.postMessage({ type, payload });\n                            console.info('This is triggered ');\n                            serviceWorker === null || serviceWorker === void 0 ? void 0 : serviceWorker.postMessage({ type, payload });\n                        }\n                        else {\n                            console.log('not ready', type);\n                            reject(\"Service worker not ready\");\n                        }\n                    }, 90000); // 90 seconds\n                }\n                // Timeout for waiting for the response (e.g., 5 seconds)\n                setTimeout(() => {\n                    reject(`No response from service worker after timeout: ${type}`);\n                    navigator.serviceWorker.removeEventListener(\"message\", responseHandler);\n                }, 90000); // 90 sec\n            }\n            else {\n                messageQueue.push({ message: { type, payload: newPayload } });\n                console.log('Message Queued', type, payload);\n                if (type == 'init')\n                    resolve(null);\n            }\n            // })\n            // .catch(err => reject(err))\n            // .finally(() => console.log('finally'))\n        });\n    });\n}\n// export function sendMessage(type: string, payload: any) {\n//    return new Promise((resolve) => {\n//      const responseHandler = (event: any) => {\n//        resolve(event.data);\n//        navigator.serviceWorker.removeEventListener(\"message\", responseHandler);\n//      };\n//      navigator.serviceWorker.addEventListener(\"message\", responseHandler);\n//      navigator.serviceWorker.controller?.postMessage({ type, payload });\n//    });\n//  }\n// actions for message received on broadcast channel (specially from service worker)\nconst broadcastActions = {\n    GetLinkListener: (payload) => __awaiter(void 0, void 0, void 0, function* () {\n        const listener = subscribedListeners.find(listener => listener.listenerId == payload.listenerId);\n        listener === null || listener === void 0 ? void 0 : listener.callback(payload.data);\n        return { success: true };\n    }),\n    dispatchEvent: (payload) => __awaiter(void 0, void 0, void 0, function* () {\n        if (serviceWorker) {\n            let event = new Event(payload.id || '');\n            dispatchEvent(event);\n        }\n        // self.clients.matchAll({ includeUncontrolled: true }).then(clients => {\n        //   clients.forEach(client => {\n        //     client.postMessage({ id, updatedData });\n        //   });\n        // });\n        return { success: true };\n    }),\n    checkInit: (payload) => __awaiter(void 0, void 0, void 0, function* () {\n        console.log('service worker init 0');\n        if (navigator.serviceWorker.controller) {\n            console.log('service worker init 1');\n            serviceWorker = navigator.serviceWorker.controller;\n        }\n        yield sendMessage(\"init\", {\n            url: BaseUrl.BASE_URL,\n            aiurl: BaseUrl.AI_URL,\n            accessToken: TokenStorage.BearerAccessToken,\n            nodeUrl: BaseUrl.NODE_URL,\n            enableAi: false,\n            applicationName: BaseUrl.BASE_APPLICATION\n        });\n        return { success: true };\n    })\n};\n/**\n * Method to trigger broadcast message listener\n */\nfunction listenBroadCastMessages() {\n    // broadcast event can be listened through both the service worker and other tabs\n    broadcastChannel.addEventListener('message', (event) => __awaiter(this, void 0, void 0, function* () {\n        const { type, payload } = event.data;\n        if (!type)\n            return;\n        let responseData = { success: false, data: undefined };\n        if (broadcastActions[type]) {\n            responseData = yield broadcastActions[type](payload);\n        }\n        else {\n            console.log(`Unable to handle \"${type}\" case in BC service worker`);\n        }\n    }));\n}\n/**\n * Method to initialize the initial data\n * @param url string\n * @param aiurl string\n * @param accessToken string\n * @param nodeUrl string\n * @param enableAi boolean\n * @param applicationName string\n * @param isTest boolean\n * @returns Promise<any>\n */\nfunction initConceptConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n        /**\n         * We initialize the system so that we get all the concepts from the backend system that are most likely to be used\n         * We use some sort of AI algorithm to initilize these concepts with the most used concept.\n         * @param enableAi enableAi is a flag that the user can choose to set if they want to use this enable AI feature\n         * If the developer does not want to use this feature then they can just set enableAi to false.\n         */\n        yield InitializeSystem();\n        const start = new Date().getTime();\n        /**\n         * This  will create a binary tree in the memory from the indexdb.\n         * This process will set Flags to denote that the binary tree is loaded, the character binary tree is  loaded\n         * and that the type binary tree has been loaded.\n         * These trees are helpful in caching concepts and connections for the data fabric.\n         */\n        yield CreateConceptBinaryTreeFromIndexDb()\n            .then(() => {\n            // IdentifierFlags.isDataLoaded= true;\n            // IdentifierFlags.isCharacterLoaded= true;\n            // IdentifierFlags.isTypeLoaded= true;\n            let elapsed = new Date().getTime() - start;\n            console.log(\"The time taken to prepare concept  data is  \", elapsed);\n        })\n            .catch((event) => {\n            // console.log(\"This is the error in creating binary tree\", IdentifierFlags.isDataLoaded, IdentifierFlags.isCharacterLoaded, IdentifierFlags.isTypeLoaded);\n            throw event;\n        });\n        /**\n         * This will create a binary tree of local concepts that is saved from the indexdb.\n         * This process after finishing creating a binary tree of local concepts then set flag to denote that\n         * LocalBinaryTree has been created from the concepts in indexdb\n         * Local Binary Type tree has been loaded to the index db (flag is set to denote that)\n         * Character Binary Tree has been loaded from indexdb to memory (flag is set to denote that)\n         */\n        yield CreateLocalBinaryTreeFromIndexDb()\n            .then(() => {\n            // IdentifierFlags.isLocalDataLoaded = true;\n            // IdentifierFlags.isLocalTypeLoaded = true;\n            // IdentifierFlags.isLocalCharacterLoaded = true;\n            let elapsed = new Date().getTime() - start;\n            console.log(\"The time taken to prepare local concept  \", elapsed);\n        })\n            .catch((event) => {\n            throw event;\n        });\n        /**\n         * This process gets the local connections from indexdb and loads it to the local connections array which is inside of\n         * a static class called LocalConnectionData.\n         * This function will also set and IdentifierFlag that tells the whole program that this process has finished.\n         */\n        yield GetConnectionsFromIndexDbLocal()\n            .then(() => {\n            IdentifierFlags.isLocalConnectionLoaded = true;\n        })\n            .catch((event) => {\n            //console.log(\"This is the error in creating local connections binary tree\");\n            throw event;\n        });\n        /**\n         * We have designed our system to use local concepts and connections with its own local ids(negative ids) that\n         * is only valid for the browser that creates this. We have a translator in our node server.\n         * This function does this process in initlization.\n         */\n        yield PopulateTheLocalConnectionToMemory().catch((event) => {\n            console.log(\"This is the error in populating binary tree\");\n            throw event;\n        });\n        ;\n        /**\n         * This process gets the connections from indexdb and loads it to the connections array which is inside of\n         * a static class called ConnectionData.\n         * This function will also set and IdentifierFlag that tells the whole program that this process has finished.\n         */\n        yield GetConnectionsFromIndexDb()\n            .then(() => {\n            IdentifierFlags.isConnectionLoaded = true;\n            IdentifierFlags.isConnectionTypeLoaded = true;\n            let elapsed = new Date().getTime() - start;\n            console.log(\"The time taken to prepare connections  \", elapsed);\n        })\n            .catch((event) => {\n            //console.log(\"This is the error in creating connections tree\");\n            throw event;\n        });\n    });\n}\n/**\n * Method to dispatch Event received from SW\n * @param id number|string\n * @param data any\n */\nexport function dispatchIdEvent(id, data = {}) {\n    // console.log('id event dispatched', id)\n    if (serviceWorker) {\n        // let event = new Event(`${id}`);\n        let event = new CustomEvent(`${id}`, data);\n        console.log(\"event fired from\", event);\n        dispatchEvent(event);\n    }\n    else {\n        broadcastChannel.postMessage({ type: 'dispatchEvent', payload: { id } });\n    }\n}\nfunction processMessageQueue() {\n    return __awaiter(this, void 0, void 0, function* () {\n        while (messageQueue.length > 0) {\n            const { message, resolve, reject } = messageQueue.shift();\n            yield sendMessage(message.type, message.payload);\n        }\n    });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/app.ts\");\n",""],"names":[],"sourceRoot":""}